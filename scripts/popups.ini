[cpopup]
n0=$wwy(#) $+ Channel Settings - # $+ : ls
n1=-
n2=$pnln Join / Leave / Invite
n3=.$iif($wwy(#), $+ $pnln Return to This Channel,Hop [Leave / Rejoin]): $iif($wwk(#), hop, join #)
n4=.$wwy(#) $+ Invite Someone Here: invite $$quik.d(doubled,incorrigo syx $pipe send invitation¿Enter nickname to invite to # $+ :) #
n5=.$iif($wwy(#) == $style(2),Close This Window,Leave This Channel): {
n6=  if ($wwy(#) == $style(2)) { part # | halt }
n7=  %part.o = $decision(gvbn¿incorrigo syx $pipe leave # $+ ¿Do you want to leave a parting message while you leave?)
n8=  if (%part.o == $yes) { part # $decision(qeg¿incorrigo syx $pipe leave # $+ ¿Enter parting message for # $+ :) }
n9=  if (%part.o == $no) { part # } 
n10=  else { halt }
n11=}
n12=.Join Another Channel: join $$decision(eg¿incorrigo syx $pipe join channel¿Enter channel name: $+ $crlf $crlf $+ [if you type a second word - it will be used as a password])
n13=.-
n14=.Find Other Channels: {
n15=  var %criterion $$decision(yvg¿incorrigo syx $pipe find channels¿Do you wish to enter a keyword?)
n16=  if (%criterion == $yes) {
n17=    var %criterioin $decision(geq¿incorrigo syx $pipe channel list search¿Enter keyword(s) to refine your channel list:)
n18=  }
n19=  list %criterioin
n20=}
n21=$pnln $wwy(#) $+ Channel Notice
n22=.Send Message: notice # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter channel notice message:)
n23=.-
n24=.$wzy(#) $+ Voice: notice + $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: voice +up])
n25=.$wzy(#) $+ Half Op: notice $percenti $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: half-op +up])
n26=.$wdy(#) $+ Channel Operator: notice @ $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: ch. operator +up])
n27=.$wdy(#) $+ Channel Admin: notice $ampersand $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: ch. admin +up])
n28=.$wdy(#) $+ Owner: notice ~ $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: owner])
n29=$pnln Away From Keyboard: awaymgr
n30=$pnln Change Your Nickname: nick $$decision(qebg¿incorrigo syx $pipe change nickname¿Enter new nickname:)
n31=$pnln $+ $iif($me ison #,Send,Show) Time Until Next Year: $iif($me ison #,msg #,echo -atc Mode) * This year remaining time: $endofyear
n32=-
n33=$iif($nln && $me ison #,$null,$style(2)) $+ Send Local Time: msg # local time: $gettime
n34=$iif($nln && $me ison #,$null,$style(2)) $+ Direct Channel URL
n35=.$chr(91) $+ ircs $+ $chr(58) $+ //irc.incorrigo.io/ $+ $right($chan,-1) $+ $chr(93): msg # IRCS Link: ircs://irc.incorrigo.io/ $+ $right($chan, -1)
n36=.$chr(91) $+ https  $+ $chr(58) $+ //incorrigo.io/irc?ch= $+ $right($chan,-1) $+ $chr(93): msg # Social Media Safe Link: https://incorrigo.io/irc?ch= $+ $right($chan, -1)
n37=.$chr(91) $+ https  $+ $chr(58) $+ //incorrigo.io/web?ch= $+ $right($chan,-1) $+ $chr(93): msg # Browser Client Link: https://incorrigo.io/web?ch= $+ $right($chan, -1)
n38=$iif($nln && $me ison #,Channel History Playback,$nul)): history # $$decision(qeg¿incorrigo syx $pipe history playback¿How many lines to play back?)
n39=$iif($nln && $me ison #,Reply to a Message,$null)): r #
n40=-
n41=Ban / Except / Invite Lists
n42=.$iif($wzy(#) == $$style(2),$null,Ban List)
n43=..Add Ban: mode # +b $$quik.d(doubled, incorrigo syx $pipe ban entry¿Enter user/mask to add to ban list: $+ $crlf $crlf $+ nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n44=..Remove Ban: mode # -b $$quik.d(doubled, incorrigo syx $pipe ban entry¿Enter user/mask to add to ban list: $+ $crlf $crlf $+ nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n45=..-
n46=..Clear All Bans: clear.bans #
n47=..-
n48=..About Ban List: noop $decision(ugo¿incorrigo syx $pipe channel ban list¿You can add an entry onto the ban list using mode +b $+ $crlf $crlf $+ When you match something on the ban list $+ $c you will not be allowed to join the channel $+ $crlf $crlf $+ If you are already on the channel it doesn't remove you $+ $c but some restrictions will be placed until you are either kicked / leave of your own accord)
n49=.$iif($wzy(#) == $style(2),$null,Invite List)
n50=..Add Invite: mode # +I $$quik.d(doubled, incorrigo syx $pipe invite entry¿Enter user/mask to add to invite list: $+ $crlf $crlf $+ nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n51=..Remove Invite: mode # -I $$quik.d(doubled, incorrigo syx $pipe invite entry¿Enter user/mask to remove from invite list: $+ $crlf $crlf $+ nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n52=..-
n53=..Clear All Invites: clear.invites #
n54=..-
n55=..About Invite List: explain An entry on the channel's invite list is added using mode +I $+ $crlf $crlf $+ The invite list allows people to join without being manually invited $+ $c when the channel is invite only [+i] $+ $crlf $crlf $+ Being on the invite list does not let you in if you are banned $+ $c but strangely the /invite command does
n56=.$iif($wzy(#) == $style(2),$null,Exception List)
n57=..Add Exception: mode # +e $$quik.d(doubled, incorrigo syx $pipe exception entry¿Enter user/mask to add to exception list: $+ $crlf $crlf $+ nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n58=..Remove Exception: mode # -e $$quik.d(doubled, incorrigo syx $pipe exception entry¿Enter user/mask to remove from exception list: $+ $crlf $crlf $+ nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n59=..-
n60=..Clear All Exceptions: clear.exceptions #
n61=..-
n62=..About Exceptions: explain If someone matches an exception $+ $c it will override any bans that they also may match. This does nothing if the channel is invite only.
n63=.-
n64=.$wwy(#) $+ View Ban List: mode # +b
n65=.$wwy(#) $+ View Invite List: mode # +I
n66=.$wwy(#) $+ View Exception List: mode # +e
n67=.-
n68=.Help About Channel Lists: text-reader incorrigo-syx\docu-mental\list-modes.tr Ban, Except, Invite lists
n69=$iif($wzy(#) != $null,$null,Extended Ban Creator): extbanner #
n70=$iif($sysop,Network Engineer Menu,$null)
n71=.Operator Chat
n72=..Global Ops: globops $$decision(egt¿incorrigo syx $pipe /globops message¿Enter Global Message:)
n73=..Local Ops: locops $$decision(egt¿incorrigo syx $pipe /locops message¿Enter Server Ops Message:)
n74=..-
n75=..Services GLOBAL: global global $$decision(egt¿incorrigo syx $pipe services announcement¿Enter global announcement:)
n76=..-
n77=.. $+ $server Announce: msg $chr(36) $+ $server $$decision(egt¿incorrigo syx $pipe server announcement¿Enter Message for Server - All Users:)
n78=..Entire Network Announce: msg $chr(36) $+ * $$decision(egt¿incorrigo syx $pipe entire network - calling all users¿Enter Message for Network - All Users:)
n79=..-
n80=.. $+ $server Notice All: notice $chr(36) $+ $server $$decision(egt¿incorrigo syx $pipe server - all users¿Enter Message for Server - All Users:)
n81=..Notice All Network: notice $chr(36) $+ * $$decision(egt¿incorrigo syx $pipe network - all users¿Enter Message for Network - All Users:)
n82=..-
n83=..Wallops Message: wallops $$decision(egt¿incorrigo syx $pipe wallops message¿Enter message to send over wallops: $+ $crlf $crlf $+ [ordinary users can use mode +w])
n84=.Operator Join: {
n85=  var %op.join $$decision(geu¿incorrigo syx $pipe operator join¿Enter channel to operator join:)
n86=  .timer -m 1 1 invite $me %op.join
n87=  .timer -m 1 450 join %op.join
n88=}
n89=.-
n90=.Override Modes
n91=..Channel Owner: mode # +q $me
n92=..Channel Admin: mode # +a $me
n93=..Channel Operator: mode # +o $me
n94=..Half Operator: mode # +h $me
n95=..Voice: mode # +v $me
n96=..Set Channel Modes: mode # $$decision(eg¿incorrigo syx $pipe channel mode change¿Enter channel mode change: $+ $crlf $crlf $+ [you can +set and -unset modes])
n97=.Operserv FORBID
n98=..Add Nickname: os forbid add nick + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter FORBID duration:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter nickname to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter nickname forbidden message:)
n99=..Add Channel: os forbid add chan + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter FORBID duration:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter channel to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter channel forbidden message:)
n100=..Add Email: os forbid add email + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter FORBID duration:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter email address to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Why is this email address being forbidden?)
n101=..-
n102=..Delete Nickname: os forbid del nick $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n103=..Delete Channel: os forbid del chan $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n104=..Delete Email: os forbid del email $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n105=..-
n106=..List Nicknames: os forbid list nick
n107=..List Channels: os forbid list chan
n108=..List Emails: os forbid list email
n109=.Services IGNORE
n110=..Add Nick / Mask: {
n111=  var %os.ignore.dur = $$decision(eg¿incorrigo syx $pipe services ignore¿Enter duration of services ignore:)
n112=  var %pervert = $decision(egb¿incorrigo syx $pipe services ignore¿Enter nick or mask: $+ $crlf $crlf $+ [Mask: nick!user@ho.st.na.me])
n113=  os ignore add %os.ignore.dur %pervert $$decision(eg¿incorrigo syx $pipe services ignore¿Why are you adding a services ignore agsint %pervert $+ ?)
n114=}
n115=..Delete Nick / Mask: {
n116=  os ignore del $$decision(eg¿incorrigo syx $pipe services ignore¿Enter nick or mask: $+ $crlf $crlf $+ [Mask: nick!user@ho.st.na.me])
n117=}
n118=..-
n119=..View Services Ignore List: os ignore list
n120=..What is this list?: {
n121=  noop $$decision(iog¿incorrigo syx $pipe services ignore list¿The services ignore list contains nicknames or masks of people who are not permitted to interact with network services $+ $crlf $crlf $+ If you match an entry on this list services will completely ignore you and you will not be able to use them $+ $crlf $crlf $+ If you are experiencing a services ignore, you can still log in to your account )
n122=}
n123=..-
n124=..Clear Services Ignore List: {
n125=  var %clear.signore = $$decision(wyvgb¿incorrigo syx $pipe clear ignore list¿This will clear the entire services ignore list $+ $crlf $crlf $+ Do you wish to proceed?)
n126=  if (%clear.signore == $yes) {
n127=    os ignore clear
n128=  }
n129=}
n130=.Network N-Line List
n131=..Add N-Line: {
n132=  os snline add + $+ $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter n-line duration:) $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter name mask:) $+ : $+ $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter n-line reason:)
n133=}
n134=..Remove N-Line: {
n135=  os snline del $$decision(qeg¿incorrigo syx $pipe delete n-line¿Enter N-Line list number or mask:)
n136=}
n137=..-
n138=..View Services N-Line List: os snline view
n139=..What is this list?: {
n140=  noop $decision(iog¿incorrigo syx $pipe services n-line list¿The services N-Line list is for banning a certain "Real Names" $obk $+ or gecos $+ $cbk from being used $+ $crlf $crlf $+ Setting or trying to connect with a banned name will automatically close your connection until you change it to a different one)
n141=}
n142=..-
n143=..Clear N-Line List: {
n144=  var %pervert $$decision(wyvgb¿incorrigo syx $pipe clear n-line list¿This will clear the services n-line list $+ $crlf $crlf $+ Are you sure?)
n145=  if (%pervert == $yes) {
n146=    os snline clear
n147=  }
n148=}
n149=.Q-Line List
n150=..Add Q-Line: {
n151=  os sqline add + $+ $$decision(qeg¿incorrigo syx $pipe add Q-line¿Enter Q-line duration:) $$decision(qeg¿incorrigo syx $pipe add Q-line¿Enter nick/channel mask to ban:) $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter nick/chan refused message:)
n152=}
n153=..Delete Q-Line: os sqline del $$decision(qeg¿incorrigo syx $pipe delete Q-line¿Enter N-Line list number or mask:)
n154=..-
n155=..View Services Q-Line List: os sqline view
n156=..What is this list?: {
n157=  explain A Q-line is a nickname or channel that is prohibited $+ $crlf $crlf $+ If the entry starts with a $rhash then operserv will treat it as a channel name $+ $crlf $crlf $+ If a user tries to use a nick / channel that matches an entry on this list $+ $c your reason will be given in the form of an error message
n158=}
n159=..-
n160=..Clear Q-Line List: {
n161=  var %pervert $$decision(wyvgb¿incorrigo syx $pipe clear Q-line list¿This will clear the services Q-line list $+ $crlf $crlf $+ Are you sure?)
n162=  if (%pervert == $yes) {
n163=    os sqline clear
n164=  }
n165=}
n166=.Operator KICK: os kick $$decision(eg¿incorrigo syx $pipe services kick¿Enter channel name:) $$decision(eg¿incorrigo syx $pipe services kick¿Enter nickname:)
n167=.Operserv KILL: os kill $$decision(qeg¿incorrigo syx $pipe services kill¿Enter user to kill:) $$decision(qeg¿incorrigo syx $pipe services kill¿Why are you disconnecting this person?)
n168=.-
n169=.Server Admin Commands
n170=..Force Join a Channel: SAJOIN $me $$decision(gte¿incorrigo syx $pipe force join¿Which channel to join?)
n171=..-
n172=.. $+ $iif($wwk(#) == $true,SAJOIN Someone Here,SAJOIN Yourself Inside): $iif($wwk(#) == $true,SAJOIN $$decision(etg¿incorrigo syx $pipe sajoin user¿Enter nickname to bring here:) #,sajoin $me #)
n173=..SAPART Someone From Here: sapart $$decision(etg¿incorrigo syx $pipe force part¿Enter person to leave channel:) #
n174=..SAMODE Set Channel Mode: samode # $$decision(etg¿incorrigo syx $pipe server mode change¿Enter mode change for channel: $+ $crlf $crlf $+ [Mode change will be done by server])
n175=..-
n176=..Server Admin Commands Explained: text-reader incorrigo-syx\docu-mental\sa-cmds.tr S.A. Commands Explained
n177=.Server Only Commands
n178=..Svsjoin Yourself to a Channel: operserv svsjoin $me $$decision(gte¿incorrigo syx $pipe svsjoin a channel¿Which channel to join?)
n179=..Svsjoin Someone Here: operserv svsjoin $$decision(gte¿incorrigo syx $pipe svsjoin user¿Enter nickname to svsjoin here:) #
n180=..Svsnick A User: operserv svsnick $$decision(gte¿incorrigo syx $pipe force nickname change¿Enter nickname to change:) $$decision(gte¿incorrigo syx $pipe force nickname change¿Enter new nickname:)
n181=..Svspart Someone From #: operserv svspart $$decision(gte¿incorrigo syx $pipe svspart douche¿Enter user to SVSPART from here:) #
n182=.$iif($aopper.rmenu(on),$style(1) $+,$null $+) Self-AOP
n183=..$iif($aopper.rmenu(self),$style(1) $+,$null $+) Oper-Override (self): aopper.set self
n184=..$iif($aopper.rmenu(csvc),$style(1) $+,$null $+) Chanserv: {
n185=  if ($decision(tygv¿incorrigo syx $pipe chanserv self-aop¿This setting will only work on registered channels. Proceed?) == $yes) {
n186=    aopper.set csvc
n187=  }
n188=}
n189=..$iif($aopper.rmenu(scmd),$style(1) $+,$null $+) Samode Command: aopper.set scmd
n190=..$iif($aopper.rmenu(svcs),$style(1) $+,$null $+) Operserv Mode: aopper.set svcs
n191=..-
n192=..$iif($aopper.rmenu(off),$style(1) $+,$null $+) Switch Off: aopper.set off
n193=..Set Level $chr(91) $+ $aopper.what $+ $chr(93)
n194=...$iif($aopper.what == +v,$style(1),$null) $+ Voice: aopper.what v
n195=...$iif($aopper.what == +h,$style(1),$null) $+ Half-Op: aopper.what h
n196=...$iif($aopper.what == +o,$style(1),$null) $+ Operator: aopper.what o
n197=...$iif($aopper.what == +a,$style(1),$null) $+ Admin: aopper.what a
n198=..-
n199=..What is Self-AOP?: aopper.details
n200=.Set /whois Response: set %sysop.whois $$decision(teg¿incorrigo syx $pipe whois response¿This will send a private message to people who /whois you $+ $crlf $cflf $+ Enter message to send:)
n201=$iif($wzy(#) != $null,$null,Change Topic): topic # $$decision(qeg¿incorrigo syx $pipe set new topic¿Enter new channel topic:)
n202=$iif($wzy(#) != $null,$null,Set Channel Modes)
n203=.Understanding Channel Settings: text-reader incorrigo-syx\docu-mental\channel-modes.tr Understanding Channel Settings and How They Work
n204=.-
n205=.Manual Mode Entry: mode # $$decision(egb¿incorrigo syx $pipe mode change¿Enter mode change parameters:)
n206=.-
n207=.$wdy(#) $+ Block Colour Codes [c]
n208=..+c: mode # +c
n209=..-c: mode # -c
n210=.$wzy(#) $+ No Channel CTCP Messages [C]
n211=..+C: mode # +C
n212=..-C: mode # -C
n213=..-
n214=..What is this?: { explain CTCP requests are for client responses i.e. what client [& version], local time, etc. $+ $crlf $crlf $+ Sending it to the channel gets a response from everyone all at once $+ $crlf $crlf $+ Setting this mode will stop people from doing this to the whole channel }
n215=.$wdy(#) $+ Lurker Mode [D]
n216=..+D: mode # +D
n217=..-D: mode # -D
n218=..-
n219=..What is this?: explain Delayed Join [+D] will hide someone from ordinary users until they send a first message or become a channel operator. It looks like they joined at the same time $+ $crlf $crlf $+ When opped, it looks like they all joined. When de-opped, it looks like they all left if they haven't said anything yet $+ $crlf $+ $crlf $+ It will allow you to lurk if you don't say anything
n220=.$wdy(#) $+ Flood Protection Profile [F]
n221=..+F <profile>: mode # +F $$decision(egb¿incorrigo syx $pipe input request¿Enter server flood protect profile name:)
n222=..-F: mode # -F
n223=.$wdy(#) $+ Flood Protection Control [f]
n224=..+f <exact controls>: mode # +f $$decision(egb¿incorrigo syx $pipe input request¿Enter specific flood protection settings:)
n225=..-f: mode # -f
n226=.$wdy(#) $+ Profanity Censor [G]
n227=..+G: mode # +G
n228=..-G: mode # -G
n229=..-
n230=..What is this?: explain Setting this mode [+G] will block / censor various bad words and profanity from channel messages
n231=.$wdy(#) $+ Channel History [H]
n232=..+H: mode # +H $$decision(egb¿incorrigo syx $pipe input request¿Chat history playback parameter is of the format lines:time $+ $crlf $crlf $+ Example - 750:5d is max 750 lines within a time frame of five days $+ $crlf $crlf $+ Enter chat history parameter:)
n233=..-H: mode # -H
n234=.$wzy(#) $+ Invite Only [i]
n235=..+i: mode # +i
n236=..-i: mode # -i
n237=..-
n238=..More Information: explain This setting will make # invite only. Only people who are invited may join $+ $crlf $crlf $+ - You can let someone in as a one-off using the /INVITE command $crlf $+ - Any number of people can come if they are on the channel's invite list
n239=.$wdy(#) $+ Calm Down Kick [j]
n240=..+j: mode # +j $$decision(egb¿incorrigo syx $pipe input request¿How many seconds of delay when kicked? $+ $crlf $crlf $+ [a number from 1-20])
n241=..-j: mode # -j
n242=..-
n243=..What is this?: explain Kick-Join Delay [+j 1-20] stops someone from re-joining the channel until 1-20 seconds have passed since they have been kicked
n244=.$wzy(#) $+ Channel Password [k]
n245=..+k <password>: mode # +k $$quik.d(pdoubled,incorrigo syx $eval($chr(124), 0) set channel key¿Enter channel key: $+ $crlf $crlf $+ NB: Everyone inside the channel will be able to see the channel key!)
n246=..-k: mode # -k
n247=.$wzy(#) $+ Disable /KNOCK [K]
n248=..+K: mode # +K
n249=..-K: mode # -K
n250=...-
n251=...What is this?: explain If someone has an invite only channel $+ $c and they don't really care, then no one on will be able to /KNOCK on your channel $+ $crlf $crlf $+ When someone knocks on a channel it asks channel operators for an invitation. Mode +K will remove this function from the channel
n252=.$wdy(#) $+ Link Channel [L]
n253=..+L <channel>: mode # +L $$decision(egb¿incorrigo syx $pipe input request¿Enter channel name to send people who fail to join to:)
n254=..-L: mode # -L *
n255=..-
n256=..What is this?: explain A linked channel [+L #channelname] is the channel someone is redirected to if they fail to join your channel [e.g. if the channel is full, or they have the wrong password etc.]
n257=.$wzy(#) $+ Limit Number of Users [l]
n258=..+l <max users>: mode # +l $$decision(qeg¿incorrigo syx $pipe chnnel limit¿Enter maximum number of users:)
n259=..-l: mode # -l
n260=.$wzy(#) $+ Moderated [m]
n261=..+m: mode # +m
n262=..-m: mode # -m
n263=..-
n264=..What is this?: explain Moderated [+m] means that users need to be specifically given voice [+v] or higher to send any message in the channel
n265=.$wzy(#) $+ Moderate Unregistered [M]
n266=..+M: mode # +M
n267=..-M: mode # -M
n268=..-
n269=..What is this?: explain Moderated Unregistered [+M] users that are unregistered / not logged into an account will need to be given voice [+v] to speak
n270=.$wdy(#) $+ No Nickname Changes [N]
n271=..+N: mode # +N
n272=..-N: mode # -N
n273=.$wzy(#) $+ No External Messages [n]
n274=..+n: mode # +n
n275=..-n: mode # -n
n276=.$iif($sysop,Systems Operator Lockout [O],$null)
n277=..+O: mode # +O
n278=..-O: mode # -O
n279=..-
n280=..What is this?: explain When this mode is in effect, only an IRC Operator is able to join the channel $+ $crlf $crlf $+ Not all operators have permission to set / unset this mode. There is a separate permission specifically to allow access to a +O channel
n281=.$wdy(#) $+ Channel is Permanent [P]
n282=..+P: mode # +P
n283=..-P: mode # -P
n284=..-
n285=..What is this?: explain Permanent channels [+P] are not destroyed when everyone leaves, even in the search results of /LIST
n286=.$wzy(#) $+ Channel is Private [p]
n287=..+p: mode # +p
n288=..-p: mode # -p
n289=..-
n290=..What is this?: explain Private [+p] channels will not appear in /LIST searches. It will also be hidden from another user's /WHOIS information. Unless you are currently on that channel yourself
n291=.$wdy(#) $+ Disable /KICK [Q]
n292=..+Q: mode # +Q
n293=..-Q: mode # -Q
n294=..-
n295=..What is This?: explain Channel mode Q disables the kick command from being used. Normal users will be unable to kick others out of the channel, for any reason, at any permission level $+ $crlf $crlf $+ This mode is normally used to make kicks only possible by people with chanserv access using the KICK command $+ $crlf $crlf $+ Services bots and network operators are still able to kick users with /KICK, whether or not they have channel operator permissions
n296=.$wzy(#) $+ Registered Users Only [R]
n297=..+R: mode # +R
n298=..-R: mode # -R
n299=. $+ $style(2) $+ Channel is Registered [r]
n300=..+r: mode # +r
n301=..-r: mode # -r
n302=.$wzy(#) $+ Channel is Secret [s]
n303=..+s: mode # +s
n304=..-s: mode # -s
n305=..-
n306=..What is this?: explain Secret [+s] channels are the same as private [p] but the server will act like the channel doesn't exist in searches like /TOPIC /NAMES /LIST etc ...
n307=.$wdy(#) $+ Strip Colour Codes [S]
n308=..+S: mode # +S
n309=..-S: mode # -S
n310=.$wdy(#) $+ No Channel Notices [T]
n311=..+T: mode # +T
n312=..-T: mode # -T
n313=.$wzy(#) $+ Only Ops Set Topic [t]
n314=..+t: mode # +t
n315=..-t: mode # -t
n316=.$wdy(#) $+ Disable /INVITE [V]
n317=..+V: mode # +V
n318=..-V: mode # -V
n319=.$wdy(#) $+ Secure Connections Only [z]
n320=..+z: mode # +z
n321=..-z: mode # -z
n322=..-
n323=..What is this?: explain Secure only channel mode [+z] will only let users with secure [TLS] connections enter the channel $+ $crlf $crlf $+ Incorrigo Syx uses Strict Transport Security (STS) which will not let mIRC connect if a secure connection cannot be made $+ $c and you would have to go out of your way to do so otherwise $+ $crlf $crlf $+ If # is +z that someone would not be allowed to join because their connection to the network is not secure $crlf $crlf $+ All web and mIRC connections are secure
n324=-
n325=$iif($nln,$null,$style(2)) $+ Channel Information: chanserv info #
n326=$iif($idf,Open Chanserv Query,$null): query chanserv help
n327=$iif(!$idf,$null,Chanserv Menu)
n328=.$wdy(#) $+ $iif($wdy(#) == $style(2),Registration [Requires Channel Operator],Register / Drop #)
n329=..REGISTER This Channel: chanserv register # $$decision(ebg¿incorrigo syx $pipe channel register description¿Please enter a description for the channel services register:)
n330=..DROP [Unregister] This Channel: $iif($$decision(vgby¿incorrigo syx $pipe unregister channel¿This will permanently delete the channel and all settings from the network services register. Do you wish to continue?) == $yes, chanserv drop # #,noop $$decision(iugob¿incorrigo syx $pipe registered channel¿Channel # was not deleted))
n331=.-
n332=.Permissions
n333=..UP: chanserv up #
n334=..DOWN: chanserv down #
n335=..-
n336=..Owner [~]
n337=...[+q]: chanserv owner #
n338=...[-q]: chanserv deowner #
n339=..Channel Admin [&&]
n340=...[+a]: chanserv protect #
n341=...[-a]: chanserv deprotect #
n342=..Channel Operator [@]
n343=...[+o]: chanserv op #
n344=...[-o]: chanserv deop #
n345=..Half-Operator [%]
n346=...[+h]: chanserv halfop #
n347=...[-h]: chanserv dehalfop #
n348=..Voice [+]
n349=...[+v]: chanserv voice #
n350=...[-v]: chanserv devoice #
n351=..-
n352=..About Registered Channel Status Modes: text-reader incorrigo-syx\docu-mental\chanserv-modes.tr Status Modes w/Chanserv Commands
n353=.Set Channel Options
n354=..Auto Op
n355=...ON: cs set autoop # on
n356=...OFF: cs set autoop # off
n357=...-
n358=...What is this?: explain When someone joins who is on the channel's /ACCESS list, they will automatically be made channel operator - or whatever status they are given by the access list
n359=..Ban Type
n360=...0 [*!user@host.or.ip]: cs set bantype # 0
n361=...1 [*!*user@host.or.ip]: cs set bantype # 1
n362=...2 [*!*@host.or.ip]: cs set bantype # 2
n363=...3 [*!*user@*.domain.ip]: cs set bantype # 3
n364=...-
n365=...What is this?: explain The BANTYPE setting tells chanserv the parts of someone's address to use when it is banning them for any reason $+ $crlf $crlf $+ If you have not changed this setting on a channel yet, the default setting is [2]
n366=..Channel Register Description: cs set description # $$decision(ebg¿incorrigo syx $pipe channel register description¿Enter new description for # $+ :)
n367=..Channel Email Address: cs set email # $$decision(ebg¿incorrigo syx $pipe channel email¿Enter an e-mail address to associate with # $+ :)
n368=..Keep Modes
n369=...ON: cs set keepmodes # on
n370=...OFF: cs set keepmodes # off
n371=...-
n372=...What is this?: explain KEEPMODES will remember the channel modes if it goes empty, and set them again when it is no longer empty
n373=..Keep / Lock Topic
n374=...Keep Topic ON: cs set keeptopic # on
n375=...Keep Topic OFF: cs set keeptopic # off
n376=...LOCK Topic: cs topic # lock
n377=...Remove LOCK: cs topic # unlock
n378=...-
n379=...What is this?: explain KEEPTOPIC will remember the topic if the channel goes empty, and set it again when it is no longer empty $+ $crlf $crlf $+ Topic LOCK will stop it from being changed by anyone that isn't on the channel's /ACCESS list
n380=..Peace
n381=...ON: cs set peace # on
n382=...OFF: cs set peace # off
n383=...-
n384=...What is this?: explain PEACE will prevent people from being kicked or de-opped by services, if they are on the access list
n385=..Private
n386=...ON: cs set private # on
n387=...OFF: cs set private # off
n388=...-
n389=...What is this?: explain When PRIVATE is set, # will not appear in any results of the chanserv LIST command
n390=..Restricted
n391=...ON: cs set restricted # on
n392=...OFF: cs set restricted # off
n393=...-
n394=...What is this?: explain RESTRICTED CHANNEL MODE $+ $crlf $crlf $+ In a restricted channel, everyone who joins must be on the /ACCESS list $+ $crlf $crlf $+ Even if they are only set as NOKICK and nothing else $+ $crlf $crlf $+ Anyone who is not on the access list will be automatically kicked and banned by services $+ $crlf $crlf $+ Anyone on the access list can use /CHANSERV UNBAN # to regain entry
n395=..Secure
n396=...ON: cs set secure # on
n397=...OFF: cs set secure # off
n398=...-
n399=...What is this?: explain SECURE will not give users with permissions on the /ACCESS list their status mode / chanserv commands until they have successfully logged into their account after / during connect
n400=..Secure Founder
n401=...ON: cs set securefounder # on
n402=...OFF: cs set securefounder # off
n403=...-
n404=...What is this?: explain SECUREFOUNDER will make sure only the REAL channel founder is allowed to DROP [unregister] the channel $+ $c change the channel founder and its successor $+ $c and not anyone with special permissions using QOP or are set to founder level on the # $+ 's /ACCESS list
n405=..Secure Ops
n406=...ON: cs set secureops # on
n407=...OFF: cs set secureops # off
n408=...-
n409=...What is this?: explain SECUREOPS will not allow someone to become a channel operator if they are not in the channel's /ACCESS list
n410=..Sign Kick
n411=...[Default Voice - 3]: chanserv levels # set SIGNKICK 3
n412=...[Default Half-Op - 4]: chanserv levels # set SIGNKICK 4
n413=...[Default Op - 5]: chanserv levels # set SIGNKICK 5
n414=...[Default Protect - 10]: chanserv levels # set SIGNKICK 10
n415=...[Default Owner - 9999]: chanserv levels # set SIGNKICK 9999
n416=...FOUNDER Only: chanserv levels # set SIGNKICK FOUNDER
n417=...-
n418=...Use Your Own Numeric: cs set signkick # $$decision(eg¿incorrigo syx $pipe signkick level¿Enter sign kick level: $+ $crlf $crlf $+ [must be a value between 1-10000])
n419=...-
n420=...ON [any level]: chanserv set signkick # on
n421=...OFF: chanserv set signkick # off
n422=...-
n423=...What is this?: explain SIGNKICK sets the user level in the channel's /ACCESS list where someone using the KICK command will have their name added to the KICK reason $+ $crlf $crlf $+ Anyone at an higher level than the SIGNKICK setting will NOT have their nickname added to the KICK reason used by chanserv
n424=..Successor
n425=...Set Channel Successor: cs set successor # $$decision(ebg¿incorrigo syx $pipe set channel successor¿Enter user account nickname of # successor:)
n426=...-
n427=...What is this?: explain The SUCCESSOR of a channel is the last hope of it surviving $+ $c if the channel's FOUNDER has their account dropped [unregistered], or if their account expires while the channel is still registered to them $+ $crlf $crlf $+ In either of these events $+ $c the successor will automatically become the channel founder and # will live on!
n428=..Channel URL: cs set url # $$decision(gbe¿incorrigo syx $pipe set url for # $+ ¿Enter URL to associate with # $+ :)
n429=.Channel Entry Message
n430=..Add Line: chanserv entrymsg # add $$decision(eubg¿incorrigo syx $pipe channel entry message¿Enter channel entry message to add:)
n431=..Remove Line: chanserv entrymsg # del $$decision(eubg¿incorrigo syx $pipe channel entry message¿Enter line number to remove:)
n432=..View All Lines: chanserv entrymsg # list
n433=..-
n434=..Clear All Entry Message: chanserv entrymsg # clear
n435=.$iif(!$sysop, $null, -)
n436=.$iif(!$sysop, $null, Operator Informaton #)
n437=..Add Operator Notes: operserv info add # $$decision(etgb¿incorrigo syx $pipe add oper info¿Enter operator info note:)
n438=..Delete Note: operserv info del # $$decision(etgb¿incorrigo syx $pipe add oper info¿Type / paste the entry you wish to remove:)
n439=..Clear Operator Notes: operserv info clear #
n440=..-
n441=..What is Operator Info?: noop $$decision(tgo¿incorrigo syx $pipe what this is¿When you use the chanserv INFO command $+ $c there is additional info only available to services operators $+ $crlf $crlf $+ You can use operserv INFO to add or remove lines of oper-only info about a nickname or channel)
n442=.$iif(!$sysop, $null, Suspend #)
n443=..Suspend This Channel: cs suspend # $$decision(teg¿incorrigo syx $pipe suspend channel¿How long should the channel be suspended? $+ $crlf $crlf [e.g. 28d for 28 days, 0 for indefinite]) $$decision(teg¿incorrigo syx $pipe suspend channel¿Enter channel suspended reason:)
n444=..Unsuspend Now: cs unsuspend #
n445=.Lock Modes on #
n446=..Add a Mode Lock: chanserv mode # lock add $$decision(qgbe¿incorrigo syx $pipe lock modes¿Enter mode [and any parameter] to lock:)
n447=..Remove a Mode Lock: chanserv mode # lock del $$decision(qgbe¿incorrigo syx $pipe lock modes¿Enter mode to unlock:)
n448=..Set Mode Lock: chanserv mode # lock set $$decision(qgbe¿incorrigo syx $pipe lock modes¿Enter mode lock to set: $+ $crlf $crlf $+ [these modes will replace ALL that are currently locked])
n449=..-
n450=..What is Mode Lock?: noop $$decision(igo¿incorrigo syx $pipe about mode lock¿When a mode is locked $+ $c nobody can unset / change it $+ $c even if they are a channel operator $+ $crlf $crlf $+ You must have chanserv permissions on # to lock or unlock modes $+ $crlf $crlf $+ Bans %+ $c invites $+ $c and exceptions can also be locked as well as regular modes $+ $crlf $crlf $+ Locked modes will persist if the channel goes empty / is created again)
n451=.$iif(!$idf,$null,Remove Access Restrictions)
n452=..Unban Yourself: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv unban %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n453=..Services Invite: { var %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker lock add +I ~a: $+ $me | chanserv invite %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker } }
n454=..-
n455=..Channel Key [+k]: { var %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv getkey %cserv.wanker }
n456=..Remove Key [-k]: { var %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -k wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker } }
n457=..-
n458=..Remove User Limit [+l]: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -l | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n459=..-
n460=..What is this?: explain '(Re)gain Channel Access' is for channel owner / operator who has ended up being unable to join their own channel $+ $crlf $crlf $+ Obviously this couldn't be used to regain access to just any channel $+ $c you would need permission from chanserv first $+ $crlf $crlf $+ If you are a network operator $+ $c then this will work whether you have permissions on the channel's access list or you don't
n461=.$iif(!$sysop, $null, Channel Kill): os chankill # + $+ $$decision(teg¿incorrigo syx $pipe channel a-kill¿How long should everyone's AKILL last? $+ $crlf $crlf $+ [e.g. 28d for 29 days, 0 for indefinite]) $$decision(teg¿incorrigo syx $pipe channel a-kill¿Enter reason message for everyone's a-kill:) $$decision(tgb¿incorrigo syx $pipe channel a-kill¿CAUTION: This will ban every user in # from the network. $+ $crlf $crlf $+ Do you wish to continue with channel a-kill?)
n462=$iif(!$idf,$null, Access List)
n463=.# Access List: access # list
n464=.-
n465=.Grant Access [No Kick]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $+ $crlf $crlf $+ [mask format: nick!user@host.name.or.ip]) nokick
n466=.Add Voice [+]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $+ $crlf $crlf $+ [mask format: nick!user@host.name.or.ip]) autovoice
n467=.Add Half-Op [%]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $+ $crlf $crlf $+ [mask format: nick!user@host.name.or.ip]) halfopme
n468=.Add Operator [@]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $+ $crlf $crlf $+ [mask format: nick!user@host.name.or.ip]) op
n469=.Add Channel Admin [&&]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $+ $crlf $crlf $+ [mask format: nick!user@host.name.or.ip]) autoprotect
n470=.Add Owner [~]: {
n471=  var %plank = $$decision(eg¿incorrigo syx $pipe access list¿Enter account/nick name or mask for access entry: $+ $crlf $crlf $+ [mask format: nick!user@host.name.or.ip])
n472=  var %plimp = $decision(wyvbg¿incorrigo syx $pipe grant access¿You are about to give the following user/mask: $+ $crlf $crlf $+ %plank $+ $crlf $crlf $+ Channel owner status. Do you wish to proceed?)
n473=  if (%plimp == $yes) {
n474=    access # add %plank ownerme
n475=  }
n476=}
n477=.-
n478=.Remove Entry From Access List: access # del $$quik.d(doubled,incorrigo syx $pipe access list¿Enter [registered] nickname or mask to remove from access list: $+ $crlf $crlf $+ [mask format: nick!user@host.name.or.ip])
n479=.Numeric Access Entry: access # add $$quik.d(doubled,incorrigo syx $pipe access numeric¿Enter [registered] nickname or mask to add access entry: $+ $crlf $crlf $+ [mask format: nick!user@host.name.or.ip]) $$decision(eg¿incorrigo syx $pipe level numeric¿Enter an access level between [1 - 10000])
n480=.-
n481=.Change Access Levels
n482=..About Access Levels: chanserv help levels desc
n483=..-
n484=..LEVELS Reset: if ($$decision(wgb¿incorrigo syx $pipe levels reset¿This will completely reset all levels. Proceed?)) { chanserv levels # reset }
n485=..Disable a Level: chanserv levels # disable $$decision(eg¿incorrigo syx $pipe levels disable¿Enter access type to be disabled: $+ $crlf $crlf $+ [Find out level's name by looking up the levels list]))
n486=..Set a Level to Founder Only: chanserv levels # set founder $$decision(eg¿incorrigo syx $pipe founder level¿Enter level to become founder only: $+ $crlf $crlf $+ [Find out what a level is called by looking at the list])
n487=..View # Levels: chanserv levels # list
n488=..-
n489=..ACCESS_CHANGE: chanserv levels # set ACCESS_CHANGE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for ACCESS_CHANGE: $+ $crlf $crlf $+ [Between 1 and 10000])
n490=..ACCESS LIST: chanserv levels # set ACCESS_LIST $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for ACCESS_LIST: $+ $crlf $crlf $+ [Between 1 and 10000])
n491=..NOKICK (for Restricted Channel): chanserv levels # set NOKICK $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for NOKICK: $+ $crlf $crlf $+ [Between 1 and 10000])
n492=..!FANTASIA (Bot): chanserv levels # set FANTASIA $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for FANTASIA: $+ $crlf $crlf $+ [Between 1 and 10000])
n493=..GREET: chanserv levels # set GREET $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for GREET: $+ $crlf $crlf $+ [Between 1 and 10000])
n494=..AUTOVOICE: chanserv levels # set AUTOVOICE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOVOICE: $+ $crlf $crlf $+ [Between 1 and 10000])
n495=..VOICEME: chanserv levels # set VOICEME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for VOICEME: $+ $crlf $crlf $+ [Between 1 and 10000])
n496=..VOICE: chanserv levels # set VOICE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for VOICE: $+ $crlf $crlf $+ [Between 1 and 10000])
n497=..INFO: chanserv levels # set INFO $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for INFO: $+ $crlf $crlf $+ [Between 1 and 10000])
n498=..SAY (Channel Bot): chanserv levels # set SAY $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for SAY: $+ $crlf $crlf $+ [Between 1 and 10000])
n499=..AUTOHALFOP: chanserv levels # set AUTOHALFOP $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOHALFOP: $+ $crlf $crlf $+ [Between 1 and 10000])
n500=..HALFOPME: chanserv levels # set HALFOPME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for HALFOPME: $+ $crlf $crlf $+ [Between 1 and 10000])
n501=..HALFOP: chanserv levels # set HALFOP $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for HALFOP: $+ $crlf $crlf $+ [Between 1 and 10000])
n502=..KICK: chanserv levels # set KICK $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for KICK: $+ $crlf $crlf $+ [Between 1 and 10000])
n503=..SIGNKICK: chanserv levels # set SIGNKICK $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for SIGNKICK: $+ $crlf $crlf $+ [Between 1 and 10000])
n504=..BAN: chanserv levels # set BAN $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for BAN: $+ $crlf $crlf $+ [Between 1 and 10000])
n505=..TOPIC: chanserv levels # set TOPIC $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for TOPIC: $+ $crlf $crlf $+ [Between 1 and 10000])
n506=..MODE: chanserv levels # set MODE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for MODE: $+ $crlf $crlf $+ [Between 1 and 10000])
n507=..GETKEY: chanserv levels # set GETKEY $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for GETKEY: $+ $crlf $crlf $+ [Between 1 and 10000])
n508=..INVITE: chanserv levels # set INVITE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for INVITE: $+ $crlf $crlf $+ [Between 1 and 10000])
n509=..UNBAN: chanserv levels # set UNBAN $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for UNBAN: $+ $crlf $crlf $+ [Between 1 and 10000])
n510=..AUTOOP: chanserv levels # set AUTOOP $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOOP: $+ $crlf $crlf $+ [Between 1 and 10000])
n511=..OPME: chanserv levels # set OPME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for OPME: $+ $crlf $crlf $+ [Between 1 and 10000])
n512=..OP: chanserv levels # set OP $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for OP: $+ $crlf $crlf $+ [Between 1 and 10000])
n513=..AUTOPROTECT: chanserv levels # set AUTOPROTECT $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOPROTECT: $+ $crlf $crlf $+ [Between 1 and 10000])
n514=..AKICK: chanserv levels # set AKICK $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AKICK: $+ $crlf $crlf $+ [Between 1 and 10000])
n515=..BADWORDS (Bot): chanserv levels # set BADWORDS $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for BADWORDS: $+ $crlf $crlf $+ [Between 1 and 10000])
n516=..$style(2) $+ ASSIGN (Bot) [Founder Only]: noop
n517=..MEMO: chanserv levels # set MEMO $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for MEMO: $+ $crlf $crlf $+ [Between 1 and 10000])
n518=..PROTECTME: chanserv levels # set PROTECTME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for PROTECTME: $+ $crlf $crlf $+ [Between 1 and 10000])
n519=..PROTECT: chanserv levels # set PROTECT $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for PROTECT: $+ $crlf $crlf $+ [Between 1 and 10000])
n520=..SET: chanserv levels # set SET $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for SET: $+ $crlf $crlf $+ [Between 1 and 10000])
n521=..AUTOOWNER: chanserv levels # set AUTOOWNER $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOOWNER: $+ $crlf $crlf $+ [Between 1 and 10000])
n522=..OWNERME: chanserv levels # set OWNERME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for OWNERME $+ $crlf $crlf $+ [Between 1 and 10000])
n523=..$style(2) $+ OWNER Command [Founder Only]: noop
n524=..FOUNDER: chanserv levels # set FOUNDER $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for FOUNDER: $+ $crlf $crlf $+ [Between 1 and 10000])
n525=$iif(!$idf,$null,Auto Kick Menu)
n526=.Add Auto-Kick: chanserv akick # add $$decision(eg¿incorrigo syx $pipe auto kick list¿Enter account / nickname or mask: $+ $crlf $crlf $+ [Mask: nick!user@host.or.ip]) $$decision(egi¿incorrigo syx $pipe auto kick list¿Enter reason for auto kick:)
n527=.Remove Auto-Kick: chanserv akick # del $$decision(qeg¿incorrigo syx $pipe remove auto kick¿Entry to remove from # AKICK list: $+ $crlf $crlf $+ [It's easier to put the number from the akick list])
n528=.-
n529=.View List: chanserv akick # view
n530=.What is auto-kick?: explain Auto-Kick is a list of people who will be kicked and banned by services as soon as they are detected in the channel $+ $crlf $crlf $+ An akick can either be a registered account holder or an address with wildcards permitted $+ $crlf $crlf $+ To remove an akick easily just enter the number of the entry from the akick list
n531=-
n532=$iif(!$idf,$null,Memoserv Lists)
n533=.Send a Memo: memoserv send $$decision(qeg¿incorrigo syx $pipe send memo¿Enter registered nickname or channel:) $$decision(qeg¿incorrigo syx $pipe send memo¿Enter the content of your message:))
n534=.-
n535=.# Inbox: {
n536=  query memoserv
n537=  clear memoserv
n538=  memoserv help all
n539=  .timer -m 1 600 msg memoserv LIST #
n540=}
n541=.$me Inbox: {
n542=  query memoserv
n543=  clear memoserv
n544=  memoserv help all
n545=  .timer -m 1 600 msg memoserv LIST
n546=}
n547=.-
n548=.Memoserv Menu: query memoserv help
n549=.-
n550=.What is memoserv?: explain Memoserv provides a message inbox for your account / regustered channel - it allows messages to be sent and kept for you by services, whether you are online or not
n551=$iif(!$idfr,$null,vHost Settings)
n552=.On: hostserv on
n553=.Off: hostserv off
n554=.-
n555=.Request a vHost: hostserv request $lHngen $+ . $+ $$decision(qeg¿incorrigo syx $pipe request vHost¿Enter vHost to request:)
n556=.-
n557=.What is hostserv?: explain Hostserv is the vanity hostname (vHost) service $+ $crlf $crlf $+ You use it to request a vHost, which will be approved by an operator $+ $crlf $crlf $+ Once approved, your address will be changed automatically when you log into your registered nickname / user account
n558=$iif(!$idf,$null,Botserv / Channel Bot)
n559=.Say Something: botserv say # $$decision(eg¿incorrigo syx $pipe bot - say [message]¿Enter message for bot to channel:)
n560=.Do Something: botserv act # $$decision(eg¿incorrigo syx $pipe bot - do [action]¿Enter /me action for bot to channel:)
n561=.-
n562=.Botserv Info - #: botserv info #
n563=.Start a Botserv Session: {
n564=  query botserv info #
n565=  .timer -m 1 400 query botserv help
n566=}
n567=.-
n568=.View List of Bots: botserv botlist
n569=.Bot Assignment
n570=..Assign Bot: { botserv botlist | botserv assign # $$decision(eg¿incorrigo syx $pipe assign bot¿Enter nickname from bot list to assign here:) }
n571=..Remove Assigned Bot: botserv unassign #
n572=.-
n573=.Badwords List
n574=..Add [Word Beginning]: botserv badwords # add $$decision(qeg¿incorrigo syx $pipe add badwords¿Enter 'word beginning' badword:) START
n575=..Add [Word Ending]: botserv badwords # add $$decision(qeg¿incorrigo syx $pipe add badwords¿Enter 'word beginning' badword:) END
n576=..Add [Single Word]: botserv badwords # add $$decision(qeg¿incorrigo syx $pipe add badwords¿Enter 'word beginning' badword:) SINGLE
n577=..-
n578=..Delete Entry: botserv badwords # del $$decision(qeg¿incorrigo syx $pipe badwords list¿Enter word / list number to remove:)
n579=..Clear Badwords List: {
n580=  var %pervert = $$decision(wyvgb¿incorrigo syx $pipe clear badwords¿You are about to clear the badwords list for # $+ $crlf $crlf $+ Do you wish to proceed?)
n581=  if (%pervert == $yes) {
n582=    botserv badwords # clear
n583=  }
n584=}
n585=..-
n586=..# Badwords List: botserv badwords # list
n587=.Change Bot Settings
n588=..Ban Expire Time
n589=...Set Timer: botserv set banexpire # $$decision(egb¿incorrigo syx $pipe botserv ban time¿Enter ban expire timer for # $+ : $+ $crlf $crlf $+ [Use time notation like 28m or 1d])
n590=...Bot Ban Info: noop $$decision(igo¿incorrigo syx $pipe channel bot bans¿If you have a services bot on your channel then you can customise how and why users will be disciplined for breaking the bot's rules that are set $+ $crlf $crlf $+ In the bot's 'kick' settings there is an option to ban a user when they have been kicked X amount of times. This is when the ban with your duration of choice will be set by your bot)
n591=..Don't Kick Ops
n592=...ON: botserv set dontkickops # on
n593=...OFF: botserv set dontkickops # off
n594=...-
n595=...What is this?: explain When in 'Don't Kick Ops' mode $+ $c the channel bot will not kick someone who would normally trigger a kick ... if they are a channel operator of any kind
n596=..Don't Kick Voices
n597=...ON: botserv set dontkickvoices # on
n598=...OFF: botserv set dontkickvoices # off
n599=...-
n600=...What is this?: explain This setting is the same as 'Don't Kick Ops' but it applies to users who currently have voice when they would otherwise be kicked
n601=..Fantasy Commands
n602=...ON: botserv set fantasy # on
n603=...OFF: botserv set fantasy # off
n604=...-
n605=...What is this?: explain Fantasy setting emulates a real bot by accepting commands that begin with ! or . $+ $crlf $crlf $+ Type !help in the channel when this setting is enabled to see a full list of commands that the channel bot will accept $+ $crlf $crlf $+ Only users on the channel access list will be able to use these commands
n606=..Greet Messages
n607=...ON: botserv set greet # on
n608=...OFF: botserv set greet # off
n609=...-
n610=...What is this?: explain The GREET setting will make the bot say a joining user's greeting message set by nickserv $+ $crlf $crlf $+ For more information: /nickserv help set greet
n611=.Kick Settings
n612=..Kick for AMSG
n613=...ON: botserv kick amsg # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many times will result in a ban?)
n614=...OFF: botserv kick amsg # off
n615=...-
n616=...What is this?: explain The AMSG kicker will kick users who are detected saying the same message to multiple channels at the same time
n617=..Badwords Kick
n618=...ON: botserv kick badwords # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many badword kicks will result in a ban?)
n619=...OFF: botserv kick badwords # off
n620=...-
n621=...What is this?: explain This function will kick users who use the badwords that you can also configure using this menu in the channel $+ $crlf $crlf $+ Even if you use the same bot for another channel $+ $c each channel has its own badwords list for you to configure $+ $crlf $crlf $+ As with the other kick settings - you can control how many times someone is kicked before it also results in a ban
n622=..Kick for Bolds
n623=...ON: botserv kick bolds # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for bolds result in a ban?)
n624=...OFF: botserv kick bolds # off
n625=...-
n626=...What is this?: explain This setting will kick users who use bold formatting codes in their messages $+ $crlf $crlf $+ You can configure how many times someone is kicked for using bolds until it results in a ban
n627=..CAPS Kick
n628=...ON
n629=....25%: botserv kick caps # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for caps will result in a ban?) 15 25
n630=....50%: botserv kick caps # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for caps will result in a ban?) 20 50
n631=....75%: botserv kick caps # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for caps will result in a ban?) 25 75
n632=...OFF: botserv kick caps # off
n633=...-
n634=...What is this?: explain The caps kick setting will remove users who send their messages to the channel using capital letters. The severity of the caps messages is measured as a percentage of the user's entire message $+ $crlf $crlf $+ Many people consider messages which are written in caps akin to shouting and find them offensive
n635=..Colours Kick
n636=...ON: botserv kick colors # ON $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for colours will result in a ban?)
n637=...OFF: botserv kick colors # OFF
n638=...-
n639=...What is thi?: explain This kicker will remove users who use colour codes in their messages. This will normalise the messages that are sent to the channel without there being some obnoxious colouring to the messages that are caused by using colour codes
n640=..Flooding Kick
n641=...ON: botserv kick flood # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for flooding will result in a ban?) $$decision(beg¿incorrigo syx $pipe bot kick config¿Enter how many lines in X seconds that will count as flooding: $+ $crlf $crlf $+ [example: 8 5 will be 8 messages in 5 seconds)
n642=...OFF: botserv kick flood # off
n643=...-
n644=...What is this?: explain The flood kicker does not affect other anti flood features such as channel mode +f. $+ $crlf $crlf $+ This kicker will kick a user from the channel if they send X messages in Y seconds (set by you) ... and if they are kicked for this Z number of times they are banned - also set by you
n645=..Italics Kick
n646=...ON: botserv kick italics # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for italic formatting will result in a ban?)
n647=...OFF: botserv kick italics # off
n648=..Underlines Kick
n649=...ON: botserv kick underlines # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for underline formatting will result in a ban?)
n650=...OFF: botserv kick underlines # off
n651=..Repeating Messages Kick
n652=...ON: botserv kick repeat # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for repetitive messages will result in a ban?) $$decision(beg¿incorrigo syx $pipe bot kick config¿How many times does a message have to repeat itself to cause a kick?)
n653=...OFF: botserv kick repeat # off
n654=..Reversing Messages Kick
n655=...ON: botserv kick reverses # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for reversing messages will result in a ban?)
n656=...OFF: botserv kick reverses # off
n657=.-
n658=.Network Bots Policy: text-reader incorrigo-syx\docu-mental\bot-services.tr Channel Bot Policy + Services
n659=$pnln $iif(!$idf,Identify / Account Login,User Account Menu)
n660=.$pnln Identify as $me $+ : {
n661=  if (r !isin $usermode) { id $$quik.d(pdoubled,incorrigo syx $pipe nickserv identify¿Enter account password for $me $+ :) }
n662=  else { rawbak.d words incorrigo syx $eval($pipe,0) identify nickname¿You are already identified as $me and don't need to log in }
n663=}
n664=.-
n665=.$pnln Recover a Different Nickname: {
n666=  set -e %main.rnick $$decision(qbeg¿incorrigo syx $pipe nickname recovery¿Enter registered nickname to recover:)
n667=  set -e %main.rlpwd $$decision(qbpg¿incorrigo syx $pipe login to nickname¿Enter account password:)
n668=  nickserv RECOVER %main.rnick %main.rlpwd
n669=  .timer 1 1 nick %main.rnick
n670=  .timer 1 2 { unset %main.rnick | unset %main.rlpwd }
n671=}
n672=.$pnln $iif($!idf,Create New Account,$null): {
n673=  register $$decision(qpgb¿incorrigo syx $pipe new account¿Enter account password: $+ $crlf $crlf $+ [no one else will ever have access to this password]) $$decision(qegb¿incorrigo syx $pipe new account¿Enter your email address: $+ $crlf $crlf $+ [required for account verification])
n674=}
n675=.$pnln $iif($getuserID != $null && $getuserID != $me,Use Account Nickname - $getuserID,$null): { nick $getuserID }
n676=.$pnln $iif(!$idf,User Account Login,Log out From $getuserID) $+ : {
n677=  if (!$idf) { nickserv identify $$decision(qeg¿incorrigo syx $pipe user account login¿Enter account name:) $$decision(qpg¿incorrigo syx $pipe user account login¿Enter account password:) }
n678=  else { nickserv logout }
n679=}
n680=.$pnln $iif($idf && !$idfr,Register $me to $getuserID Account,$null) $+ : nickserv group $getuserID
n681=.$pnln $iif(!$idf && !$idfr,Add $me to an Existing Account,$null) $+ : nickserv group $$decision(ebgoq¿incorrigo syx $pipe group nickname¿Enter your account name:) $$decision(pbgoq¿incorrigo syx $pipe group nickname¿Enter account password:)
n682=.$pnln $iif(!$idf,Recover Registered Nickname,$null): {
n683=  var %nicknamed = $$decision(qbego¿incorrigo syx $pipe nickname recovery¿Enter account nickname to recover:)
n684=  var %capsllwdd = $$decision(qbpgo¿incorrigo syx $pipe login to nickname¿Enter account password:)
n685=  nickserv RECOVER %nicknamed %capsllwd
n686=  nick %nicknamed
n687=}
n688=.-
n689=.User Account Options Explained: text-reader incorrigo-syx\docu-mental\account-login.tr Understanding User Account Options
n690=$pnln $iif(!$idf,$null,Nickserv)
n691=.Nickserv Session: query nickserv help
n692=.-
n693=.Auto Join List
n694=..Add Channel: nickserv ajoin add $$decision(eg¿incorrigo syx $pipe auto join list¿Enter channel (and optional key) to add to auto join list:)
n695=..Remove Channel: nickserv ajoin del $$decision(eg¿incorrigo syx $pipe auto join list¿Enter channel to delete from list:)
n696=..-
n697=..List Auto-Join Channels: nickserv ajoin list
n698=.Client Certificates
n699=..Add Certificate: $iif($ironnik(link.certfp), ns cert add, noop $decision(ogu¿incorrigo syx $pipe client certificate¿There is no TLS certificate being used by your IRC client))
n700=..Delete a Certificate: ns cert del $$decision(egu¿incorrigo syx $pipe delete certificate¿Enter / paste certificate fingerprint to delete:)
n701=..-
n702=..View Certificate Lists: ns cert list
n703=-
n704=Script Displa&y Settings
n705=.Check Menu Visibility
n706=..$iif($wzy(#) == $null,$style(1),$null) $+ Channel Half-Operator: noop $decision(go¿incorrigo syx $pipe half-op commands¿When you are an half operator $chr(91) $+ $percenti $+ $chr(93) several limited channel op functions become available)
n707=..$iif($wdy(#) == $null,$style(1),$null) $+ Channel Operator: noop $decision(go¿incorrigo syx $pipe channel op commands¿A channel operator [@] can perform all the commands that are needed to register / control a channel $+ $crlf $crlf $+ All the commands on that channel will appear alongside the rest of them)
n708=..$iif($idf == $true,$style(1),$null) $+ User Account Login: noop $decision(go¿incorrigo syx $pipe menu visibility¿When you log in to your account $+ $c services menus will appear $+ $crlf $crlf $+ If you don't have permission to use a particular command $+ $c it won't work $+ $crlf $crlf $+ However if you do have permissions $+ $c you don't need to be a channel operator in order to use them)
n709=..$iif($idfr == $true,$style(1),$null) $+ Using Registered Nickname: noop $decision(go¿incorrigo syx $pipe menu visibility¿If you are logged in to an account you can use any nickname that's available $+ $crlf $crlf $+ Registered nicknames are protected $+ $c and some features - like hostserv requests - require you to be using your registered nickname $+ $obk $+ s $+ $cbk)
n710=..$iif($sysop,$style(1),$null) $+ Network Engineer: noop $decision(tgo¿incorrigo syx $pipe menu visibility¿A successful IRC operator login will show all of the controls and some oper-only ones)
n711=.Light / Dark Mode
n712=..$iif($dark.mode == $false,$style(1),$null) $+ Light: golight
n713=..$iif($dark.mode == $true,$style(1),$null) $+ Dark: godark
n714=..$iif($dark.mode == auto,$style(1),$null) $+ Auto: goauto
n715=.Local Time Format
n716=..$timewy(1) Very Long Date && Time: { %ctcp.timeformat = 1 | echo -atc Info * Local Time: $gettime }
n717=..$timewy(2) Long Date && Time: { %ctcp.timeformat = 2 | echo -atc Info * Local Time: $gettime }
n718=..$timewy(3) Local Time Only: { %ctcp.timeformat = 3 | echo -atc Info * Local Time: $gettime }
n719=..$timewy(4) Brief Time && Date: { %ctcp.timeformat = 4 | echo -atc Info * Local Time: $gettime }
n720=..$timewy(5) Time of Day && Date: { %ctcp.timeformat = 5 | echo -atc Info * Local Time: $gettime }
n721=.Remote Assist
n722=..$iif(!%remote.assist,Enable Remote Assist,$style(1) $+ Enable Remote Assist): %remote.assist = $iif(!%remote.assist,$true,$false)
n723=..What is remote assist? : explain.ra channel
n724=.-
n725=.$smc Read Out Permission Changes: togglesmc
n726=.$iif($extjoin.status == on, $style(1), $null) $+ Show Extended Join Information: extjoin
n727=.$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops

[bpopup]
n0=Incorrigo Sy&x
n1=$iif($server,$pnln --> $me,Connect to Network): {
n2=  if (!$server) { F3 }
n3=  else { checkme }
n4=}
n5=-
n6=Incorrigo Syx User / Script Guide: run https://syxi.incorrigo.io/how-to
n7=-
n8=$pnln Identify With Nickserv: {
n9=  if (!$idf) { id $$quik.d(pdoubled,incorrigo syx $pipe services identification¿Enter your password to log in with nickserv:) | halt }
n10=  else { rawbak.d words incorrigo syx $eval($pipe,0) services identification¿You are already identified $+ $c and don't need to log in | halt }
n11=}
n12=$pnln User Account && Registration Menu
n13=.New Account Registration: {
n14=  register $$decision(qpgb¿incorrigo syx $pipe new account¿Enter account password: $+ $crlf $crlf $+ [no one else will ever have access to this password]) $$decision(qegb¿incorrigo syx $pipe new account¿Enter your email address: $+ $crlf $crlf $+ [required for account verification])
n15=}
n16=.Re-send Confirmation Code Email: nickserv resend
n17=.Input Confirmation Code: nickserv confirm $$decision(qeg¿incorrigo syx $pipe registration code¿Enter nickserv confirmation code: $+ $crlf $crlf $+ [you should have got this in your email])
n18=$iif($idf,$iif(o !isin $usermode,$pnln Network Engineer,$null),$null): oper $$decision(etbg¿incorrigo syx $pipe network engineer¿Enter engineer ID:) $$decision(ptbg¿incorrigo syx $pipe network engineer¿Enter engineer code: $+ $crlf $crlf $+ [NB: Failed engineer login attempts are monitored])
n19=$pnln Away Manager: awaymgr
n20=$pnln $iif(!$idf,Identify with Nickserv,User Account Options)
n21=.$pnln Identify as $me $+ : {
n22=  if (r !isin $usermode) { id $$quik.d(pdoubled,incorrigo syx $pipe nickserv identify¿Enter account password for $me $+ :) }
n23=  else { rawbak.d words incorrigo syx $eval($pipe,0) identify nickname¿You are already identified as $me and don't need to log in }
n24=}
n25=.-
n26=.$pnln $iif($getuserID != $null && $getuserID != $me,Use Account Nickname - $getuserID,$null): { nick $getuserID }
n27=.$pnln $iif(!$idf,User Account Login,Log out From $getuserID) $+ : {
n28=  if (!$idf) { nickserv identify $$decision(qeg¿incorrigo syx $pipe user account login¿Enter account name:) $$decision(qpg¿incorrigo syx $pipe user account login¿Enter account password:) }
n29=  else { nickserv logout }
n30=}
n31=.$pnln $iif($idf && !$idfr,Register $me to $getuserID Account,$null) $+ : nickserv group $getuserID
n32=.$pnln $iif(!$idf && !$idfr,Add $me to an Existing Account,$null) $+ : nickserv group $$decision(ebgoq¿incorrigo syx $pipe group nickname¿Enter your account name:) $$decision(pbgoq¿incorrigo syx $pipe group nickname¿Enter account password:)
n33=.$pnln $iif(!$idf,Recover Registered Nickname,$null): nickserv RECOVER $$decision(qbego¿incorrigo syx $pipe nickname recovery¿Enter registered nickname to recover:) $$decision(qbpgo¿incorrigo syx $pipe login to nickname¿Enter account password:)
n34=.-
n35=.User Account Options Explained: text-reader incorrigo-syx\docu-mental\account-login.tr Understanding User Account Options
n36=$iif(!$idf,$null,(Re)gain Access to Channel)
n37=.Remove Matching Bans: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv unban %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n38=.Invitation Requirements: { %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker lock add +I ~a: $+ $me | chanserv invite %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker } }
n39=.Channel Key Setting [+k]
n40=..Get Current Key: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv getkey %cserv.wanker
n41=..Remove Key: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -k wanker | if ($me !ison 5cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n42=.Channel Limit Derestriction [+l]: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -l | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n43=.-
n44=.What is this?: explain If you are on a channel's access list $+ $c then you can use chanserv to regain access to the channel $+ $crlf $crlf $+ There are a number of reasons a channel operator can be unable to join. These options will give you a range of different ways you may need to use chanserv to get back inside
n45=$iif(!$idf,$null,Hostserv Menu)
n46=.Switch On: hostserv on
n47=.Switch Off: hostserv off
n48=.-
n49=.Server vHost Login: vhost $$decision(egbt¿incorrigo syx $pipe vHost login¿Enter vHost Operator Number:) $$decision(pgbt¿incorrigo syx $pipe vHost login¿Your password please:)
n50=.-
n51=.Request vHost: {
n52=  if (!$idfr) { return $$decision(hugob¿incorrigo syx $pipe hostserv error¿You get a vHost per-nickname that you have registered $+ $crlf $crlf $+ To request a vHost you need to be identified to nickserv as one of your registered nicknames) }
n53=  else { %main.hsr = $$quik.d(doubled,incorrigo syx $pipe make vhost request¿Enter a vhost / user@vhost request:) }
n54=  if ($left(%main.hsr,3) == lH-) {
n55=    hostserv request %main.hsr
n56=  }
n57=  else { hostserv request $lHngen $+ . $+ %main.hsr }
n58=}
n59=.Generate lH Number: lhnumber
n60=.-
n61=.About Hostserv / vHost: noop $decision(og¿incorrigo syx $pipe about vHost¿When you have a registered nickname $+ $c you can request a vHost from hostserv $+ $crlf $crlf $+ A vHost is a vanity hostname that lets your hostname / ip address be anything you want. When it is activated $+ $c it is automatically applied when you identify for that nickname $+ $crlf $crlf $+ You can have a different vHost for each nickname. You can register multiple nicknames under one account using the nickserv GROUP command)
n62=.What is lH number?: text-reader incorrigo-syx\docu-mental\understanding-vhost.tr Understanding vHost and lH numbers
n63=-
n64=$pnln Change User Info
n65=.Change Nickname: nick $$decision(evq¿incorrigo syx $pipe change username¿Enter new nickname:)
n66=.Change Ident (User Name): setident $$decision(evq¿incorrigo syx $pipe change username¿Enter new ident: $+ $crlf $crlf $+ [nickname!ident@host.vhost.or.ip])
n67=.Change 'Real Name': setname $$decision(evq¿incorrigo syx $pipe change username¿Enter new real name: $+ $crlf $crlf $+ [you are not required to use your real name])
n68=.-
n69=.Server vHost Login: vhost $$decision(egt¿incorrigo syx $pipe server vHost¿Enter vHost Login Name:) $$decision(pgt¿incorrigo syx $pipe server vHost¿Enter vHost Password:)
n70=$pnln Set User Modes
n71=.Bot Mode [B]
n72=..+B: mode $me +B
n73=..-B: mode $me -B
n74=..-
n75=..What is this?: explain Bot Mode [+B] is a flag that adds a tag to your outgoing messages / line in your /WHOIS response that identifies you as being a bot $+ $crlf $crlf $+ Bots are permitted on our network and this mode helps others identify / facilitate your bot's status
n76=.Bot Deaf Mode [d]
n77=..+d: mode $me +d
n78=..-d: mode $me -d
n79=..-
n80=..What is this?: explain Deaf mode [+d] will stop you from receiving any channel messages that don't start with the designated bot command character $+ $crlf $crlf $+ It is not recommended except if your client is a bot. Messages that will come through only start with either exclamation mark '!' or full stop '.'
n81=.Decline Private Messages [D]
n82=..+D: mode $me +D
n83=..-D: mode $me -D
n84=..-
n85=..What is this?: explain Private denied mode [+D] will decline all private messages from other users $+ $c telling them that you don't accept private messages $+ $crlf $crlf $+ With this mode set $+ $c only systems operators / network services are able to send you private messages $+ $c so you will still be able to use services and ask for help while still rejecting othersuch private messages
n86=.Profanity Censor [G]
n87=..+G: mode $me +G
n88=..-G: mode $me -G
n89=..-
n90=..What is this?: explain Profanity censor mode [+G] does the same thing as channel mode +G but with private messages $+ $crlf $crlf $+ If someone uses a word or phrase that is configured as profanity by the server $+ $c then the word / phrase will either be [censor]ed $+ $c or blocked completely
n91=.$iif($sysop,Hide IRC Operator Status $chr(91) $+ H $+ $chr(93),$null)
n92=..+H: mode $me +H
n93=..-H: mode $me -H
n94=..-
n95=..What is this?: explain This mode [+H] will hide your operator status from /WHOIS $+ $c /WHO $+ $c and other user lookups
n96=.Hide Online Time [I]
n97=..+I: mode $me +I
n98=..-I: mode $me -I
n99=..-
n100=..What is this?: explain Hide time mode [+I] will hide your online / idle time(s) from your /WHOIS and othersuch look-ups
n101=.Invisible Mode [i]
n102=..+i: mode $me +i
n103=..-i: mode $me -i
n104=..-
n105=..What is this?: explain Invisible mode [+i] will hide your presence from /WHO and /NAMES requests done by anyone who doesn't share any channels with you $+ $crlf $crlf $+ This is usually set by mIRC automatically when you have successfully connected. But this option gives you more control over it if that's what you want
n106=.IRC Operator [o]
n107=..$iif($sysop,-o,$style(2) $+ -o): mode $me -o
n108=..-
n109=..What is this?: explain IRC Operator status is represented by the user mode [+o] which can only be given from a successful oper login $+ $crlf $crlf $+ Simply having this mode means nothing. However $+ $c all operator privileges can be removed by setting user mode [-o]
n110=.Private User [p]
n111=..+p: mode $me +p
n112=..-p: mode $me -p
n113=..-
n114=..What is this?: explain Private mode [+p] hides information from other people $+ $c such as all the channels you are in from your /WHOIS response. It is supposed to prevent intrusive behaviour from other users
n115=.$iif($sysop,Unkickable Mode [q],$null)
n116=..+q: mode $me +q
n117=..-q: mode $me -q
n118=..-
n119=..What is this?: explain Unkickable mode [+q] protects you from being removed by channel operators $+ $crlf $crlf $+ This mode is for preventing normal users from removing you when an operator presence is needed in the channel $+ $crlf $crlf $+ You will be alerted by the server in a private message when an attempt to kick you has failed
n120=.Registered Nickname [r]
n121=..$style(2) $+ +r: mode $me +r
n122=..$style(2) $+ -r: mode $me -r
n123=..-
n124=..What is this?: explain Registered nickname [+r] can only be set / unset by services or the server that you are connected to $+ $crlf $crlf $+ It denotes that the nickname you are using is registered and you have successfully identified as the owner of it
n125=.Registered Messages Only [R]
n126=..+R: mode $me +R
n127=..-R: mode $me -R
n128=..-
n129=..What is this?: explain Registered Messages Only [+R] will only allow private messages that are sent from a registered user who is currently logged into an account $+ $crlf $crlf $+ Users who message you will be told that they must be logged in to an account to send you messages $+ $c and their message to you will not be delivered
n130=.$iif($sysop,Network Service [S],$null)
n131=..+S: mode $me +S
n132=..-S: mode $me -S
n133=..-
n134=..What is this?: explain Network Services mode [+S] protects service bots on the channels that they are currently on $+ $crlf $crlf $+ This mode can't normally be set by users but services admins with access to the UMODE command by operserv can use it to set this mode onto themselves
n135=.Server Notices [s]
n136=..+s <snomask>: mode $me +s $$decision(teg¿incorrigo syx $pipe snomask set¿Enter snomask parameters:)
n137=..-s: mode $me -s
n138=..-
n139=..Server Notices: text-reader incorrigo-syx\docu-mental\snomasks.tr Server Notice Masks [Snomasks]
n140=.No CTCP Requests [T]
n141=..+T: mode $me +T
n142=..-T: mode $me -T
n143=..-
n144=..What is this?: explain No CTCP Mode [+T] will prevent you from receiving CTCP requests sent to you by other users
n145=.Using a vHost [t]
n146=..+t: mode $me +t
n147=..-t: mode $me -t
n148=..-
n149=..What is this?: explain vHost mode [+t] is usually set by the server [/VHOST] or services [hostserv] to denote that you are currently using a vanity hostname [vHost] $+ $crlf $crlf $+ This is not to be confused by cloaked host mode [+x] which is given to users on connecting
n150=.$iif(o isincs $usermode,Show /WHOIS [W],$null)
n151=..+W: mode $me +W
n152=..-W: mode $me -W
n153=..-
n154=..What is this?: explain Show Whois [+W] is a mode that can be set by an IRC operator $+ $c which will notify you when another user looks you up via the /WHOIS command
n155=.Receive Wallops [w]
n156=..$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops
n157=..-
n158=..What is this?: explain Receive Wallops [+w] will show you when message are sent by a systems operator via the /WALLOPS command $+ $crlf $crlf $+ Only an operator can send wallops messages $+ $c but any user through this mode is allowed to receive them
n159=.Cloaked Host [x]
n160=..+x: mode $me +x
n161=..-x: mode $me -x
n162=..-
n163=..What is this?: explain Cloaked hostname mode [+x] gives you a 'cloaked' hostname $+ $crlf $crlf $+ A cloaked hostname will still uniquely identify you / any clones you have online $+ $c but can not be used to connect to you over the internet
n164=.Secure Messages Only [Z]
n165=..+Z: mode $me +Z
n166=..-Z: mode $me -Z
n167=..-
n168=..What is this?: explain Secure Messages Only [+Z] will only allow private messages from users who are connected securely using TLS $+ $crlf $crlf $+ Any users who only have plaintext connections which are not secure $+ $c will receive an error and their message to you will not be delivered $+ $crlf $crlf $+ All users connected via web browser client are connected securely so this will not be an issue for them-
n169=$pnln Join Channel: join $$decision(eg¿incorrigo syx $pipe join channel¿Enter channel name to join: $+ $crlf $crlf $+ [You can add a password by adding another word e.g. #channelname letmein $+ ])
n170=$pnln Find Channels: list $decision(eg¿incorrigo syx $pipe channels¿Throw in a word or leave blank to list all:)
n171=$iif(!$idf,$null,Check Memo List): {
n172=  query memoserv
n173=  clear memoserv
n174=  ms help all
n175=  .timer -m 1 700 msg memoserv LIST
n176=}
n177=-
n178=$pnln Check Online Time: {
n179=  echo -astc Mode * Online: This connection has been active for $getconnectid
n180=}
n181=System Menu
n182=.Light / Dark Mode
n183=..$iif($dark.mode == $false,$style(1),$null) $+ Light Mode: golight
n184=..$iif($dark.mode == $true,$style(1),$null) $+ Dark Mode: godark
n185=..$iif($dark.mode == auto,$style(1),$null) $+ Auto: goauto
n186=.Check Menu Visibility
n187=..$style(2) $+ Channel Half Operator: noop
n188=..$style(2) $+ Channel Operator: noop
n189=..$iif($idf == $true,$style(1),$null) $+ User Account Login: noop $decision(go¿incorrigo syx $pipe menu visibility¿Extensive menus that give you access to our network services $+ $crlf $crlf $+ Services that are available include: nickserv $+ $c chanserv $+ $c memoserv $+ $c hostserv $+ $c and botserv $+ $crlf $crlf $+ You can access new account registration from the [Identify / User Account] menu in the menubar $+ $c status $+ $c and in the channel window)
n190=..$iif($idfr == $true,$style(1),$null) $+ Using Registered Nickname: noop $decision(go¿incorrigo syx $pipe menu visibility¿When you are logged into an account you can still use any available nickname. Multiple nicknames can be added to your account by using the options in the user account menu in status / channel / menubar $+ $crlf $crlf $+ A registered nickname is protected and requires you to login in order to use them. User mode +r is services acknowledgement you are identified for the nickname you are using $+ $crlf $crlf $+ Other menus can behave differently if a registered nickname is required as well as an account login $+ $c but most of the functionality will be visible by a successful account login)
n191=..$iif($sysop,$style(1),$null) $+ Network Engineer: noop $decision(tgo¿incorrigo syx $pipe menu visibility¿In status / channel / top menu bar there will be an option called Network Engineer $+ $crlf $crlf $+ In those places $+ $c you will find the Network Engineer menu $+ $c which contains extensive IRC operator [+ services] commands $+ $crlf $crlf $+ NB: You may not have the correct permissions to use all of the commands that become available)
n192=.-
n193=.Local Time Format
n194=..$timewy(1) Very Long Date && Time: { %ctcp.timeformat = 1 | echo -atc Info * Local Time: $gettime }
n195=..$timewy(2) Long Date && Time: { %ctcp.timeformat = 2 | echo -atc Info * Local Time: $gettime }
n196=..$timewy(3) Local Time Only: { %ctcp.timeformat = 3 | echo -atc Info * Local Time: $gettime }
n197=..$timewy(4) Brief Time && Date: { %ctcp.timeformat = 4 | echo -atc Info * Local Time: $gettime }
n198=..$timewy(5) Time of Day && Date: { %ctcp.timeformat = 5 | echo -atc Info * Local Time: $gettime }
n199=.$smc Read Out Permission Changes: togglesmc
n200=.$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops
n201=.$iif($extjoin.status == on, $style(1), $null) $+ Show Extended Join Information: extjoin
n202=.-
n203=.Delete All Settings - Factory Reset: {
n204=  var %do.it $$decision(yvbgw¿incorrigo syx $pipe factory reset!¿IMPORTANT: A factory reset will remove all your settings and start again. Files will not be deleted but your settings will all be permanently erased $+ $crlf $crlf $+ This is the final decision. Do you wish to continue?)
n205=  if (%do.it == $yes) {
n206=    noop $decision(og¿incorrigo syx $pipe factory reset¿Factory reset is complete. mIRC will now restart)
n207=    unset %*
n208=    exit -nr
n209=  }
n210=}

[mpopup]
n0=$iif($server,$pnln --> $me,Connect to Network): {
n1=  if (!$server) { server irc.incorrigo.io }
n2=  else { checkme }
n3=}
n4=-
n5=$pnln Join a Channel: join $$decision(eg¿incorrigo syx $pipe join channel¿Enter channel name to join:)
n6=.$pnln Find Channels: {
n7=  var %criterion $$decision(yvg¿incorrigo syx $pipe find channels¿Do you wish to enter a keyword?)
n8=  if (%criterion == $yes) {
n9=    var %criterioin $decision(geq¿incorrigo syx $pipe channel list search¿Enter keyword(s) to refine your channel list:)
n10=  }
n11=  list %criterioin
n12=}
n13=-
n14=$pnln Away Manager: awaymgr
n15=$iif($idf,$iif(o !isin $usermode,$pnln Network Engineer,$null),$null): oper $$decision(etbg¿incorrigo syx $pipe network engineer¿Enter engineer ID:) $$decision(ptbg¿incorrigo syx $pipe network operator¿Enter engineer code: $+ $crlf $crlf $+ [NB: Failed engineer login attempts are monitored])
n16=$iif($idf,$pnln Query Network Services,$null)
n17=.Nickserv Session: query nickserv help
n18=.Chanserv Session: query chanserv help
n19=.Hostserv Session: query hostserv help
n20=.Memoserv Session: query memoserv help
n21=.Botserv Session: query botserv help
n22=.$iif(!$idf || o !isincs $usermode,$null,Operserv Session): query operserv help
n23=$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops
n24=.-
n25=$pnln Server Help Menu
n26=.Main Menu: helpop
n27=.Help Directory: helpop directory
n28=.-
n29=.Good Modes
n30=..Good Modes Information: helpop goodmodes
n31=..-
n32=..Mode Profiles: helpop modeprofiles
n33=..-
n34=..Small Side Channel: helpop modeprofile.office
n35=.."Main" Channel: helpop modeprofile.bigtime
n36=..Technical Support: helpop modeprofile.techsupport
n37=.User Modes: helpop umodes
n38=.Channel Modes: helpop chmodes
n39=.-
n40=.User Commands: helpop usercmds
n41=.Operator Commands: helpop opercmds
n42=.Server Only Commands: helpop svscmds
n43=.-
n44=.About Incorrigo Syx: helpop about
n45=-
n46=$pnln Change Your Info
n47=.Change Nickname: nick $$decision(evq¿incorrigo syx $pipe change username¿Enter new nickname:)
n48=.Change Ident (User Name): setident $$decision(evq¿incorrigo syx $pipe change username¿Enter new ident: $+ $crlf $crlf $+ [nickname!ident@host.vhost.or.ip])
n49=.Change 'Real Name': setname $$decision(evq¿incorrigo syx $pipe change username¿Enter new real name: $+ $crlf $crlf $+ [you are not required to use your real name])
n50=.$iif($sysop,IP / Hostname,$null): sethost $$decision(evt¿incorrigo syx $pipe manual vHost¿Enter your new host.name.or.ip: $+ $crlf $crlf $+ [this will not stop bans containing your real info from working])
n51=.-
n52=.Server vHost Login: vhost $$decision(egt¿incorrigo syx $pipe server vHost¿Enter vHost Login Name:) $$decision(pgt¿incorrigo syx $pipe server vHost¿Enter vHost Password:)
n53=$pnln Set User Modes
n54=.Bot Mode [B]
n55=..+B: mode $me +B
n56=..-B: mode $me -B
n57=..-
n58=..What is this?: explain Bot Mode [+B] adds a flag to your activity that tells other users you are a bot $+ $crlf $crlf $+ Bots are permitted on this network and this flag will help your bot be recognised by other people
n59=.Bot Deaf Mode [d]
n60=..+d: mode $me +d
n61=..-d: mode $me -d
n62=..-
n63=..What is this?: explain Deaf mode [+d] will stop you from receiving any channel messages that don't start with a bot command sign $+ $crlf $crlf $+ If a message doesn't start with ! or . then you won't see it. This is not recommended! Unless you are a bot
n64=.Decline Private Messages [D]
n65=..+D: mode $me +D
n66=..-D: mode $me -D
n67=..-
n68=..What is this?: explain Private denied mode [+D] will decline all private messages from other users $+ $c telling them that you don't accept private messages $+ $crlf $crlf $+ With this mode set $+ $c only systems operators / network services are able to send you private messages $+ $c so you will still be able to use services and ask for help while still rejecting othersuch private messages
n69=.Profanity Censor [G]
n70=..+G: mode $me +G
n71=..-G: mode $me -G
n72=..-
n73=..What is this?: explain Profanity censor mode [+G] does the same thing as channel mode +G but with private messages $+ $crlf $crlf $+ If someone uses a word or phrase that is configured as profanity by the server $+ $c then the word / phrase will either be [censor]ed $+ $c or blocked completely
n74=.$iif($sysop,Hide IRC Operator Status $chr(91) $+ H $+ $chr(93),$null)
n75=..+H: mode $me +H
n76=..-H: mode $me -H
n77=..-
n78=..What is this?: explain This mode [+H] will hide your operator status from /WHOIS $+ $c /WHO $+ $c and other user lookups
n79=.Hide Online Time [I]
n80=..+I: mode $me +I
n81=..-I: mode $me -I
n82=..-
n83=..What is this?: explain Hide time mode [+I] will hide your online / idle time(s) from your /WHOIS and othersuch look-ups
n84=.Invisible Mode [i]
n85=..+i: mode $me +i
n86=..-i: mode $me -i
n87=..-
n88=..What is this?: explain Invisible mode [+i] will hide your presence from /WHO and /NAMES requests done by anyone who doesn't share any channels with you $+ $crlf $crlf $+ This is usually set by mIRC automatically when you have successfully connected. But this option gives you more control over it if that's what you want
n89=.IRC Operator [o]
n90=..$iif($sysop,-o,$style(2) $+ -o): mode $me -o
n91=..-
n92=..What is this?: explain IRC Operator status is represented by the user mode [+o] which can only be given from a successful oper login $+ $crlf $crlf $+ Simply having this mode means nothing. However $+ $c all operator privileges can be removed by setting user mode [-o]
n93=.Private User [p]
n94=..+p: mode $me +p
n95=..-p: mode $me -p
n96=..-
n97=..What is this?: explain Private mode [+p] hides information from other people $+ $c such as all the channels you are in from your /WHOIS response. It is supposed to prevent intrusive behaviour from other users
n98=.$iif($sysop,Unkickable Mode [q],$null)
n99=..+q: mode $me +q
n100=..-q: mode $me -q
n101=..-
n102=..What is this?: explain Unkickable mode [+q] protects you from being removed by channel operators $+ $crlf $crlf $+ This mode is for preventing normal users from removing you when an operator presence is needed in the channel $+ $crlf $crlf $+ You will be alerted by the server in a private message when an attempt to kick you has failed
n103=.Registered Nickname [r]
n104=..$style(2) $+ +r: mode $me +r
n105=..$style(2) $+ -r: mode $me -r
n106=..-
n107=..What is this?: explain Registered nickname [+r] can only be set / unset by services or the server that you are connected to $+ $crlf $crlf $+ It denotes that the nickname you are using is registered and you have successfully identified as the owner of it
n108=.Registered Messages Only [R]
n109=..+R: mode $me +R
n110=..-R: mode $me -R
n111=..-
n112=..What is this?: explain Registered Messages Only [+R] will only allow private messages that are sent from a registered user who is currently logged into an account $+ $crlf $crlf $+ Users who message you will be told that they must be logged in to an account to send you messages $+ $c and their message to you will not be delivered
n113=.$iif($sysop,Network Service [S],$null)
n114=..+S: mode $me +S
n115=..-S: mode $me -S
n116=..-
n117=..What is this?: explain Network Services mode [+S] protects service bots on the channels that they are currently on $+ $crlf $crlf $+ This mode can't normally be set by users but services admins with access to the UMODE command by operserv can use it to set this mode onto themselves
n118=.Server Notices [s]
n119=..+s <snomask>: mode $me +s $$decision(teg¿incorrigo syx $pipe snomask set¿Enter snomask parameters:)
n120=..-s: mode $me -s
n121=..-
n122=..Server Notices: text-reader incorrigo-syx\docu-mental\snomasks.tr Server Notice Masks [Snomasks]
n123=.No CTCP Requests [T]
n124=..+T: mode $me +T
n125=..-T: mode $me -T
n126=..-
n127=..What is this?: explain No CTCP Mode [+T] will prevent you from receiving CTCP requests sent to you by other users
n128=.Using a vHost [t]
n129=..+t: mode $me +t
n130=..-t: mode $me -t
n131=..-
n132=..What is this?: explain vHost mode [+t] is usually set by the server [/VHOST] or services [hostserv] to denote that you are currently using a vanity hostname [vHost] $+ $crlf $crlf $+ This is not to be confused by cloaked host mode [+x] which is given to users on connecting
n133=.$iif(o isincs $usermode,Show /WHOIS [W],$null)
n134=..+W: mode $me +W
n135=..-W: mode $me -W
n136=..-
n137=..What is this?: explain Show Whois [+W] is a mode that can be set by an IRC operator $+ $c which will notify you when another user looks you up via the /WHOIS command
n138=.Receive Wallops [w]
n139=..$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops
n140=..-
n141=..What is this?: explain Receive Wallops [+w] will show you when message are sent by a systems operator via the /WALLOPS command $+ $crlf $crlf $+ Only an operator can send wallops messages $+ $c but any user through this mode is allowed to receive them
n142=.Cloaked Host [x]
n143=..+x: mode $me +x
n144=..-x: mode $me -x
n145=..-
n146=..What is this?: explain Cloaked hostname mode [+x] gives you a 'cloaked' hostname $+ $crlf $crlf $+ A cloaked hostname will still uniquely identify you / any clones you have online $+ $c but can not be used to connect to you over the internet
n147=.Secure Messages Only [Z]
n148=..+Z: mode $me +Z
n149=..-Z: mode $me -Z
n150=..-
n151=..What is this?: explain Secure Messages Only [+Z] will only allow private messages from users who are using a secure connection $+ $crlf $crlf $+ All web browser connections are secure
n152=$iif(o isincs $usermode,Network Engineer,$null)
n153=.Operator Chat
n154=..Global Ops: globops $$decision(egt¿incorrigo syx $pipe /globops message¿Enter Global Message:)
n155=..Local Ops: locops $$decision(egt¿incorrigo syx $pipe /locops message¿Enter Server Ops Message:)
n156=..-
n157=..Services GLOBAL: global global $$decision(egt¿incorrigo syx $pipe services announcement¿Enter global announcement:)
n158=..-
n159=.. $+ $server Announce: msg $chr(36) $+ $server $$decision(egt¿incorrigo syx $pipe server announcement¿Enter Message for Server - All Users:)
n160=..Entire Network Announce: msg $chr(36) $+ * $$decision(egt¿incorrigo syx $pipe entire network - calling all users¿Enter Message for Network - All Users:)
n161=..-
n162=.. $+ $server Notice All: notice $chr(36) $+ $server $$decision(egt¿incorrigo syx $pipe server - all users¿Enter Message for Server - All Users:)
n163=..Notice All Network: notice $chr(36) $+ * $$decision(egt¿incorrigo syx $pipe network - all users¿Enter Message for Network - All Users:)
n164=..-
n165=..Wallops Message: wallops $$decision(egt¿incorrigo syx $pipe wallops message¿Enter message to send over wallops: $+ $crlf $crlf $+ [ordinary users can use mode +w])
n166=.-
n167=.Operator Join
n168=..Override Join: {
n169=  var %ov.hazi $$decision(egb¿incorrigo syx $pipe oper override¿This join requires oper override permissions $+ $crlf $crlf $+ Enter channel to force join:)
n170=  if ($left(%ov.hazi, 1) == $chr(35)) {
n171=    .invite $me %ov.hazi
n172=    .timer -m 1 750 join %ov.hazi
n173=  }
n174=}
n175=..SVSJOIN: operserv svsjoin $me $$decision(eg¿incorrigo syx $pipe force join¿This join requires operserv permissions $+ $crlf $crlf $+ Enter channel to force join:)
n176=..SAJOIN: sajoin $me $$decision(eg¿incorrigo syx $pipe force join¿This join requires permission to use the /SAJOIN command $+ $crlf $crlf $+ Enter channel to force join:)
n177=.Operserv FORBID
n178=..Add Nickname: os forbid add nick + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter FORBID duration:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter nickname to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter nickname forbidden message:)
n179=..Add Channel: os forbid add chan + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter FORBID duration:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter channel to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter channel forbidden message:)
n180=..Add Email: os forbid add email + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter FORBID duration:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter email address to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Why is this email address being forbidden?)
n181=..-
n182=..Delete Nickname: os forbid del nick $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n183=..Delete Channel: os forbid del chan $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n184=..Delete Email: os forbid del email $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n185=..-
n186=..List Nicknames: os forbid list nick
n187=..List Channels: os forbid list chan
n188=..List Emails: os forbid list email
n189=.Services IGNORE
n190=..Add Nick / Mask: {
n191=  var %os.ignore.dur = $$decision(eg¿incorrigo syx $pipe services ignore¿Enter duration of services ignore:)
n192=  var %pervert = $decision(egb¿incorrigo syx $pipe services ignore¿Enter nick or mask: $+ $crlf $crlf $+ [Mask: nick!user@ho.st.na.me])
n193=  os ignore add %os.ignore.dur %pervert $$decision(eg¿incorrigo syx $pipe services ignore¿Why are you adding a services ignore agsint %pervert $+ ?)
n194=}
n195=..Delete Nick / Mask: {
n196=  os ignore del $$decision(eg¿incorrigo syx $pipe services ignore¿Enter nick or mask: $+ $crlf $crlf $+ [Mask: nick!user@ho.st.na.me])
n197=}
n198=..-
n199=..View Services Ignore List: os ignore list
n200=..What is this list?: {
n201=  noop $$decision(iog¿incorrigo syx $pipe services ignore list¿The services ignore list contains nicknames or masks of people who are not permitted to interact with network services $+ $crlf $crlf $+ If you match an entry on this list services will completely ignore you and you will not be able to use them $+ $crlf $crlf $+ If you are experiencing a services ignore, you can still log in to your account )
n202=}
n203=..-
n204=..Clear Services Ignore List: {
n205=  var %clear.signore = $$decision(wyvgb¿incorrigo syx $pipe clear ignore list¿This will clear the entire services ignore list $+ $crlf $crlf $+ Do you wish to proceed?)
n206=  if (%clear.signore == $yes) {
n207=    os ignore clear
n208=  }
n209=}
n210=.Network N-Line List
n211=..Add N-Line: {
n212=  os snline add + $+ $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter n-line duration:) $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter name mask:) $+ : $+ $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter n-line reason:)
n213=}
n214=..Remove N-Line: {
n215=  os snline del $$decision(qeg¿incorrigo syx $pipe delete n-line¿Enter N-Line list number or mask:)
n216=}
n217=..-
n218=..View Services N-Line List: os snline view
n219=..What is this list?: {
n220=  noop $decision(iog¿incorrigo syx $pipe services n-line list¿The services N-Line list is for banning a certain "Real Names" $obk $+ or gecos $+ $cbk from being used $+ $crlf $crlf $+ Setting or trying to connect with a banned name will automatically close your connection until you change it to a different one)
n221=}
n222=..-
n223=..Clear N-Line List: {
n224=  var %pervert $$decision(wyvgb¿incorrigo syx $pipe clear n-line list¿This will clear the services n-line list $+ $crlf $crlf $+ Are you sure?)
n225=  if (%pervert == $yes) {
n226=    os snline clear
n227=  }
n228=}
n229=.Q-Line List
n230=..Add Q-Line: {
n231=  os sqline add + $+ $$decision(qeg¿incorrigo syx $pipe add Q-line¿Enter Q-line duration:) $$decision(qeg¿incorrigo syx $pipe add Q-line¿Enter nick/channel mask to ban:) $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter nick/chan refused message:)
n232=}
n233=..Delete Q-Line: os sqline del $$decision(qeg¿incorrigo syx $pipe delete Q-line¿Enter Q-Line list number or mask:)
n234=..-
n235=..View Services Q-Line List: os sqline view
n236=..What is this list?: {
n237=  explain A Q-line is a nickname or channel that is prohibited $+ $crlf $crlf $+ If the entry starts with a $rhash then operserv will treat it as a channel name $+ $crlf $crlf $+ If a user tries to use a nick / channel that matches an entry on this list $+ $c your reason will be given in the form of an error message
n238=}
n239=..-
n240=..Clear Q-Line List: {
n241=  var %pervert $$decision(wyvgb¿incorrigo syx $pipe clear Q-line list¿This will clear the services Q-line list $+ $crlf $crlf $+ Are you sure?)
n242=  if (%pervert == $yes) {
n243=    os sqline clear
n244=  }
n245=}
n246=.Operator KICK: os kick $$decision(eg¿incorrigo syx $pipe services kick¿Enter channel name:) $$decision(eg¿incorrigo syx $pipe services kick¿Enter nickname:)
n247=.Operserv KILL: os kill $$decision(qeg¿incorrigo syx $pipe services kill¿Enter user to kill:) $$decision(qeg¿incorrigo syx $pipe services kill¿Why are you disconnecting this person?)
n248=.$iif($aopper.rmenu(on),$style(1) $+,$null $+) Self-AOP
n249=..$iif($aopper.rmenu(self),$style(1) $+,$null $+) Oper-Override (self): aopper.set self
n250=..$iif($aopper.rmenu(csvc),$style(1) $+,$null $+) Chanserv: {
n251=  if ($decision(tygv¿incorrigo syx $pipe chanserv self-aop¿This setting will only work on registered channels. Proceed?) == $yes) {
n252=    aopper.set csvc
n253=  }
n254=}
n255=..$iif($aopper.rmenu(scmd),$style(1) $+,$null $+) Samode Command: aopper.set scmd
n256=..$iif($aopper.rmenu(svcs),$style(1) $+,$null $+) Operserv Mode: aopper.set svcs
n257=..-
n258=..$iif($aopper.rmenu(off),$style(1) $+,$null $+) Switch Off: aopper.set off
n259=..Set Level $chr(91) $+ $aopper.what $+ $chr(93)
n260=...$iif($aopper.what == +v,$style(1),$null) $+ Voice: aopper.what v
n261=...$iif($aopper.what == +h,$style(1),$null) $+ Half-Op: aopper.what h
n262=...$iif($aopper.what == +o,$style(1),$null) $+ Operator: aopper.what o
n263=...$iif($aopper.what == +a,$style(1),$null) $+ Admin: aopper.what a
n264=..-
n265=..What is Self-AOP?: aopper.details
n266=$pnln $iif(!$idf,Identify with Nickserv,User Account Options)
n267=.$pnln Identify as $me $+ : {
n268=  if (r !isin $usermode) { id $$quik.d(pdoubled,incorrigo syx $pipe nickserv identify¿Enter account password for $me $+ :) }
n269=  else { rawbak.d words incorrigo syx $eval($pipe,0) identify nickname¿You are already identified as $me and don't need to log in }
n270=}
n271=.$iif(!$idf,Create New Account,$null): {
n272=  register $$decision(qpgb¿incorrigo syx $pipe new account¿Enter account password: $+ $crlf $crlf $+ [no one else will ever have access to this password]) $$decision(qegb¿incorrigo syx $pipe new account¿Enter your email address: $+ $crlf $crlf $+ [required for account verification])
n273=}
n274=.-
n275=.$pnln $iif($getuserID != $null && $getuserID != $me,Use Account Nickname - $getuserID,$null): { nick $getuserID }
n276=.$pnln $iif(!$idf,User Account Login,Log out From $getuserID) $+ : {
n277=  if (!$idf) { nickserv identify $$decision(qeg¿incorrigo syx $pipe user account login¿Enter account name:) $$decision(qpg¿incorrigo syx $pipe user account login¿Enter account password:) }
n278=  else { nickserv logout }
n279=}
n280=.$pnln $iif($idf && !$idfr,Register $me to $getuserID Account,$null) $+ : nickserv group $getuserID
n281=.$pnln $iif(!$idf && !$idfr,Add $me to an Existing Account,$null) $+ : nickserv group $$decision(ebgoq¿incorrigo syx $pipe group nickname¿Enter your account name:) $$decision(pbgoq¿incorrigo syx $pipe group nickname¿Enter account password:)
n282=.$pnln $iif(!$idf,Recover Registered Nickname,$null): nickserv RECOVER $$decision(qbego¿incorrigo syx $pipe nickname recovery¿Enter registered nickname to recover:) $$decision(qbpgo¿incorrigo syx $pipe login to nickname¿Enter account password:)
n283=.-
n284=.User Account Options Explained: text-reader incorrigo-syx\docu-mental\account-login.tr Understanding User Account Options
n285=$$iif(!$idfr,$null,Hostserv Menu)
n286=.Switch On: hostserv on
n287=.Switch Off: hostserv off
n288=.-
n289=.Request vHost: {
n290=  if (!$idfr) { return $$decision(hugob¿incorrigo syx $pipe hostserv error¿You get a vHost per-nickname that you have registered $+ $crlf $crlf $+ To request a vHost you need to be identified to nickserv as one of your registered nicknames) }
n291=  else { %main.hsr = $$quik.d(tellme,incorrigo syx $pipe make vhost request¿Enter a vhost / user@vhost request:) }
n292=  if ($left(%main.hsr,3) == lH-) {
n293=    hostserv request %main.hsr
n294=  }
n295=  else { hostserv request $lHngen $+ . $+ %main.hsr }
n296=}
n297=.Generate lH Number: lhnumber
n298=.-
n299=.About Hostserv / vHost: noop $decision(og¿incorrigo syx $pipe about vHost¿When you have a registered nickname $+ $c you can request a vHost from hostserv $+ $crlf $crlf $+ A vHost is a vanity hostname that lets your hostname / ip address be anything you want. When it is activated $+ $c it is automatically applied when you identify for that nickname $+ $crlf $crlf $+ You can have a different vHost for each nickname. You can register multiple nicknames under one account using the nickserv GROUP command)
n300=.What is lH number?: text-reader incorrigo-syx\docu-mental\understanding-vhost.tr Understanding vHost and lH numbers
n301=$iif(!$idf,$null,(Re)gain Channel Access)
n302=.Remove Matching Bans: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv unban %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n303=.Invitation Requirements: { %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker lock add +I ~a: $+ $me | chanserv invite %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker } }
n304=.Channel Key Setting [+k]
n305=..Get Current Key: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv getkey %cserv.wanker
n306=..Remove Key: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -k wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n307=.Channel Limit Derestriction [+l]: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -l | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n308=.-
n309=.What is this?: explain 'Regain Channel Access' is for channel owner / operator who has ended up being unable to join their own channel $+ $crlf $crlf $+ Obviously this couldn't be used to regain access to just any channel $+ $c you would need permission from chanserv first
n310=-
n311=Script Display Setting&s
n312=.Local Time Format
n313=..$timewy(1) Very Long Date && Time: { %ctcp.timeformat = 1 | echo -atc Info * Local Time: $gettime }
n314=..$timewy(2) Long Date && Time: { %ctcp.timeformat = 2 | echo -atc Info * Local Time: $gettime }
n315=..$timewy(3) Local Time Only: { %ctcp.timeformat = 3 | echo -atc Info * Local Time: $gettime }
n316=..$timewy(4) Brief Time && Date: { %ctcp.timeformat = 4 | echo -atc Info * Local Time: $gettime }
n317=..$timewy(5) Time of Day && Date: { %ctcp.timeformat = 5 | echo -atc Info * Local Time: $gettime }
n318=.Check Menu Visibility
n319=..$style(2) $+ Channel Half Operator: noop
n320=..$style(2) $+ Channel Operator: noop
n321=..$iif($idf == $true,$style(1),$null) $+ User Account Login: noop $decision(go¿incorrigo syx $pipe menu visibility¿When you log in to your account $+ $c services menus will appear $+ $crlf $crlf $+ If you don't have permission to use a particular command $+ $c it won't work $+ $crlf $crlf $+ However if you do have permissions $+ $c you don't need to be a channel operator in order to use them)
n322=..$iif($idfr == $true,$style(1),$null) $+ Using Registered Nickname: noop $decision(go¿incorrigo syx $pipe menu visibility¿You will stay logged into your account if you change your nickname $+ $crlf $crlf $+ Using one of your registered nicknames is not so different from being logged in)
n323=..$iif($sysop,$style(1),$null) $+ Network Engineer: noop $decision(tgo¿incorrigo syx $pipe menu visibility¿A successful IRC operator login will show all of the controls and some oper-only ones)
n324=.Light / Dark Mode
n325=..$iif($dark.mode == $false,$style(1),$null) $+ Light Mode: golight
n326=..$iif($dark.mode == $true,$style(1),$null) $+ Dark Mode: godark
n327=..$iif($dark.mode == auto,$style(1),$null) $+ Auto: goauto
n328=.Remote Assist
n329=..Remote Assist Manager: ram
n330=..$iif(!%remote.assist,Enable Remote Assist,$style(1) $+ Enable Remote Assist): %remote.assist = $iif(!%remote.assist,$true,$false)
n331=..What is remote assist? : explain.ra status
n332=.-
n333=.$iif($extjoin.status == on, $style(1), $null) $+ Show Extended Join Information: extjoin

[qpopup]
n0=--> $$1: whois $$1 $$1
n1=-
n2=Nickserv Account Info: .nickserv info $$1
n3=$iif($ignore($address($$1, 2)),$style(1) $+ Active Ignores For,Ignore) $$1
n4=.Ignore $$1: .ignore $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  ...
n5=.-
n6=.Temporary Ignore
n7=..For 30 Seconds: .ignore -u30 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 30 seconds
n8=..For 60 Seconds: .ignore -u60 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 60 seconds
n9=..For 2 minutes: .ignore -u120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 2 minutes
n10=..For 4 minutes: .ignore -u240 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 4 minutes
n11=..For 8 minutes: .ignore -u480 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 8 minutes
n12=..For 16 minutes: .ignore -u960 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 16 minutes
n13=..For 32 minutes: .ignore -u1920 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 32 minutes
n14=..For an hour: .ignore -u3840 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 hour
n15=..For a day: .ignore -u92160 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 day 
n16=..For a week: .ignore -u645120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 week 
n17=.Ignore Private Things
n18=..All Text / Requests: .ignore -pcntidhy $$1 2 | echo -atc Info2 * Ignore: Ignoring $$1 Private messages & requests
n19=..-
n20=..For 30 Seconds: .ignore -pcntidhyu30 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 30 seconds
n21=..For 60 Seconds: .ignore -pcntidhyu60 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 60 seconds
n22=..For 2 minutes: .ignore -pcntidhyu120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 2 minutes
n23=..For 4 minutes: .ignore -pcntidhyu240 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 4 minutes
n24=..For 8 minutes: .ignore -pcntidhyu480 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 8 minutes
n25=..For 16 minutes: .ignore -pcntidhyu960 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 16 minutes
n26=..For 32 minutes: .ignore -pcntidhyu1920 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 32 minutes
n27=..For an hour: ignore -pcntidhyu3840 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 hour
n28=..For a day: ignore -pcntidhyu92160 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 day 
n29=..For a week: ignore -pcntidhyu645120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 week 
n30=.-
n31=.Stop Ignoring $$1: .ignore -r $$1 2 | echo -atc Info2 * Ignore: No longer ignoring  $+ $$1 $+ 
n32=-
n33=Set User Mode
n34=.DMs Disabled [D]
n35=..+D: mode $me +D
n36=..-D: mode $me -D
n37=..-
n38=..What is this?: explain Mode [+D] blocks all private messages from any user $+ $crlf $crlf $+ Systems operators $+ $c network services $+ $c and servers can still send you private messages
n39=.Private User [p]
n40=..+p: mode $me +p
n41=..-p: mode $me -p
n42=..-
n43=..What is this?: explain Setting mode [+p] will hide all channels you are in from your --> whois response
n44=.Censor Profanity [G]
n45=..+G: mode $me +G
n46=..-G: mode $me -G
n47=..-
n48=..What is this?: explain User mode [G] will block explicit language by censoring the words with something else $+ $crlf $crlf $+ While some effort has been made to block vulgar words and phrases $+ $c we can not guarantee that this will be effective all the time
n49=.Registered Users Only [R]
n50=..+R: mode $me +R
n51=..-R: mode $me -R
n52=..-
n53=..What is this?: explain Setting more [R] will receive private messages from people logged into a user account only
n54=.No CTCP Requests [T]
n55=..+T: mode $me +T
n56=..-T: mode $me -T
n57=..-
n58=..What is this?: explain When more [T] is in place, all CTCP requests are denied. But this means you won't be able to send them either
n59=.Secure Clients Only [Z]
n60=..+Z: mode $me +Z
n61=..-Z: mode $me -Z
n62=..-
n63=..What is this?: explain User mode [Z] means you won't receive messages from plaintext [not securely connected] users
n64=-
n65=CTCP(X) Request
n66=.Ping: echo -tac CTCP * Requestions $$1 $+ 's ping [network latency] ... | .ctcp $$1 PING
n67=.Version: echo -tac CTCP * Requesting $$1 $+ 's version ... | .ctcp $$1 VERSION
n68=.Time: echo -tac CTCP * Requesting $$1 $+ 's local time ... | .ctcp $$1 TIME
n69=.Finger: echo -tac CTCP * Requesting $$1 $+ 's finger ... | .ctcp $$1 FINGER
n70=.-
n71=.Friendly Name: ctcp-x $$1 NAME
n72=.Ident / Email: ctcp-x $$1 EMAIL
n73=.IRC Client: ctcp-x $$1 VERSION
n74=.Script: ctcp-x $$1 SCRIPT
n75=.Local Time: ctcp-x $$1 TIME
n76=.Idle Time: ctcp-x $$1 IDLE
n77=.Website: ctcp-x $$1 URL
n78=.-
n79=.Custom Request: .ctcp $$1 $$decision(eugo¿incorrigo syx $pipe ctcp request¿Enter CTCP request:) | echo -tac CTCP * Sent $$1 client request ...
n80=.What is CTCP?: noop $decision(iugo¿incorrigo syx $pipe ctcp requests¿CTCP stands for "client to client protocol" $+ $crlf $crlf $+ It is a way that a client [app you are using] asks for information from another user's client that is not messaging related)
n81=DCC Actions
n82=.Send File: dcc send $$1
n83=.Direct Chat: dcc chat $$1
n84=.DCC Allow
n85=..Add: dccallow + $+ $$1
n86=..Delete: dccallow - $+ $$1
n87=..-
n88=..What is DCC Allow?: noop $$decision(iog¿incorrigo syx $pipe dcc allow¿Some file types are blocked from being sent by the server $+ $c because they could be malicious software $+ $crlf $crlf $+ To allow someone to send you a blocked file $+ $c you must add them to your DCC allow list. $+ $crlf $crkf $+ Once you have added someone $+ $c they will need to send whatever was blocked once again $+ $c if it was previously blocked
n89=.Trusted User
n90=..Trust $$1: dcc-entrust $$1
n91=..Trust $address($$1, 4): dcc-entrust $address($$1, 4)
n92=..Trust $address($$1, 2): dcc-entrust $address($$1, 2)
n93=..-
n94=..-
n95=..Detrust $$1: dcc-detrust $$1
n96=..Detrust $address($$1, 4): dcc-detrust $address($$1, 4)
n97=..Detrust $address($$1, 2): dcc-detrust $address($$1, 2)
n98=..What is trust?: noop $$decision(oi¿incorrigo syx $pipe dcc trust list¿When you add someone to your DCC trust list $+ $c you will automatically accept their files and chat requests $+ $crlf $crlf $+ You can add someone by their vHost / cloaked hostname and it will still work $+ $crlf $crlf $+ Your trust list is part of mIRC and will still apply between IRC sessions))
n99=.-
n100=.What are these?: text-reader incorrigo-syx\docu-mental\about-dcc.tr Direct Client to Client-
n101=$iif($window($1).type == query,Close This Conversation,$null): {
n102=  if ($decision(ygq¿incorrigo syx $pipe private conversation¿Tell them you've closed?) == $yes) {
n103=    say ACTION has closed the conversation window
n104=  }
n105=  close -cm $$1
n106=}

[lpopup]
n0=--> $$1: whois $$1 $1
n1=User Account Info: nickserv info $$1
n2=Whisper: notice $$1 $$decision(eg¿incorrigo syx $pipe whisper¿Private message to send $$1 $+ :)
n3=Private Conversation: query $$1
n4=-
n5=Notify List
n6=.Add $$1: .notify $$1 | echo -atc Notify * Notify: Added  $+ $$1 $+  to your notify list
n7=.Remove $$1: .notify -r $$1 | echo -atc Notify * Notify: Removed  $+ $$1 $+  from your notify list
n8=$iif(%remote.assist,Remote Assist,$null)
n9=.Give Permission: .auser 50 $address($$1, 2) | echo -atc Info2 * Assist: $$1 [ $+ $address($$1, 2) $+ ] is now allowed to assist
n10=.Remove Permission: .ruser 50 $address($$1, 2) | echo -atc Info2 * Assist: $$1 [ $+ $address($$1, 2) $+ ] is no longer allowed to assist
n11=.-
n12=.Remote Assist Readme: explain.ra nicklist
n13=$iif($ignore($address($$1, 2)),$style(1) $+ Active Ignores for,Ignore) $$1
n14=.Ignore $$1: .ignore $$1 2 | echo -atc Info2 * Ignore: Everything that comes from $address($$1, 2) [ $+ $1 $+ ] is now ignored
n15=.Partial Ignore
n16=..Private Messages and Requests: .ignore -pidhy $$1 2 | echo -atc Info2 * Ignore: Private Messages and Requests from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] are now being ignored
n17=..Invitations to Join Channels: .ignore -i $$1 2 | echo -atc Info2 * Ignore: Invitations to Join Channels from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] are now being ignored
n18=..Strip Message Formatting Codes: .ignore -k $$1 2 | echo -atc Info2 * Ignore: Colour / Text Formatting Codes from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will be stripped
n19=..Matched Highlight List Triggers: .ignore -sh $$1 2 | echo -atc Info2 * Ignore: Matching entries on your highlight list from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will no longer be triggered
n20=..Highlights and Pop-up As Well: .ignore -shy $$1 2 | echo -atc Info2 * Ignore: Pop-ups as well as highlights from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will no longer be triggered
n21=..File / Direct Chat [DCC] Requests: .ignore -d $$1 2 | echo -atc Info2 * Ignore: Direct connection file / chat requests from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will now be disregarded
n22=..CTCP Requests: .ignore -t $$1 2 | echo -atc Info2 * Ignore: CTCP Requests from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will no longer trigger replies
n23=..Notices / Formatting Codes: .ignore -nkh $$1 2 | echo -atc Info2 * Ignore: Notice messages / Text formatting from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will now be stripped
n24=..All Except Private Messages: .ignore -cnt $$1 2 | echo -atc Info2 * Ignore: All channel / CTCP / notice messages - except private messages from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will no longer be displayed
n25=..-
n26=..What is this?: .timer -m 1 150 noop $decision(og¿incorrigo syx $pipe ignore switches¿Partial ignore gives you the option to include someone in your session but at the same time relieve yourself of unwanted private messages / requests etc. $+ $crlf $crlf $+ Direct file transfers / chat requests will _share your real IP address / host name_! if you accept. You can use this menu to block such requests so you can avoid inadvertently choosing that $+ $crlf $crlf $+ NB: Choosing one of these settings will replace any other [even if you are ignoring $$1 completely] that is currently set)
n27=.Temporarily Ignore
n28=..For 30 Seconds: .ignore -u30 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 30 seconds
n29=..For 60 Seconds: .ignore -u60 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 60 seconds
n30=..For 2 minutes: .ignore -u120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 2 minutes
n31=..For 4 minutes: .ignore -u240 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 4 minutes
n32=..For 8 minutes: .ignore -u480 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 8 minutes
n33=..For 16 minutes: .ignore -u960 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 16 minutes
n34=..For 32 minutes: .ignore -u1920 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 32 minutes
n35=.Silence $$1
n36=..Add Silence: .silence $address($$1, 2)
n37=..Unsilence: .silence - $+ $address($$1, 2)
n38=..-
n39=..What is silence?: noop $decision(quoy¿incorrigo syx $pipe silence for session¿Silence is a special type of ignore that blocks someone at the server level. An ignore continues for as long as you want, but a silence only lasts until you disconnect from the server $+ $crlf $crlf $+ Because it's easy to change your nickname $+ $c silence is added for the user's address instead)
n40=.-
n41=.Stop Ignoring $$1: .ignore -r $$1 2 | echo -atc Info2 * Ignore: All ignored activities and requests from  $+ $$1 $+   $+ $chr(91) $+  $+ $address($$1, 2) $+  $+ $chr(93) $+  have been removed from your ignore list
n42=-
n43=CTCP(X) Request
n44=.Ping: echo -tac CTCP * Requestions $$1 $+ 's ping [network latency] ... | .ctcp $$1 PING
n45=.Version: echo -tac CTCP * Requesting $$1 $+ 's version ... | .ctcp $$1 VERSION
n46=.Time: echo -tac CTCP * Requesting $$1 $+ 's local time ... | .ctcp $$1 TIME
n47=.Finger: echo -tac CTCP * Requesting $$1 $+ 's finger ... | .ctcp $$1 FINGER
n48=.-
n49=.Friendly Name: ctcp-x $$1 NAME
n50=.Ident / Email: ctcp-x $$1 EMAIL
n51=.IRC Client: ctcp-x $$1 VERSION
n52=.Script: ctcp-x $$1 SCRIPT
n53=.Local Time: ctcp-x $$1 TIME
n54=.Idle Time: ctcp-x $$1 IDLE
n55=.Website: ctcp-x $$1 URL
n56=.-
n57=.Custom Request: .ctcp $$1 $$decision(eugo¿incorrigo syx $pipe ctcp request¿Enter CTCP request:) | echo -tac CTCP * Sent $$1 client request ...
n58=.What is CTCP?: noop $decision(iugo¿incorrigo syx $pipe ctcp requests¿CTCP stands for "client to client protocol" $+ $crlf $crlf $+ It is a way that a client [app you are using] asks for information from another user's client that is not messaging related)
n59=.-
n60=.Nickname Colours: text-reader incorrigo-syx\docu-mental\nick-colours.tr Nickname Colours Explained [Default Colour Profile]
n61=DCC Actions
n62=.Send File: dcc send $$1
n63=.Direct Chat: dcc chat $$1
n64=.DCC Allow
n65=..Add: dccallow + $+ $$1
n66=..Delete: dccallow - $+ $$1
n67=..-
n68=..What is DCC Allow?: noop $$decision(iog¿incorrigo syx $pipe dcc allow¿Some files are an obvious security risk to you and they will be blocked $+ $crlf $crlf $+ To send such files $+ $c the recipient must add the sender to their DCCALLOW list $+ $crlf $crlf $+ If a file has been blocked before the DCCALLOW $+ $c it will need to be sent again)
n69=.Trusted User
n70=..Trust $$1: dcc-entrust $$1
n71=..Trust $address($$1, 4): dcc-entrust $address($$1, 4)
n72=..Trust $address($$1, 2): dcc-entrust $address($$1, 2)
n73=..-
n74=..-
n75=..Detrust $$1: dcc-detrust $$1
n76=..Detrust $address($$1, 4): dcc-detrust $address($$1, 4)
n77=..Detrust $address($$1, 2): dcc-detrust $address($$1, 2)
n78=..What is trust?: noop $$decision(oi¿incorrigo syx $pipe dcc trust list¿Adding someone to your DCC trust list means you are completely alright with them and will accept anything that they send your way $+ $crlf $crlf $+ If anyone matches an entry in this list $+ $c their files and chats will be automatically accepted and start sending to you)
n79=.-
n80=.What are these?: text-reader incorrigo-syx\docu-mental\about-dcc.tr Direct Client to Client
n81=-
n82=$iif(o isin $usermode,Network Engineer,$null)
n83=.SA Commands
n84=..SAJOIN $$1 $+ : sajoin $$1 $$decision(teg¿incorrigo syx $pipe sajoin¿Enter channel name to send $$1 $+ :)
n85=..SAPART $$1 From #: if ($$decision(vty¿incorrigo syx $pipe sapart¿Are you sure you want $$1 to leave #) == $yes $+ ) { sapart $$1 # }
n86=.Change User Info
n87=..Change Ident: chgident $$1 $$decision(qeg¿incorrigo syx $pipe change username¿Enter new username:)
n88=..Change Hostname: chghost $$1 $lHngen $+ . $+ $$decision(qeg¿incorrigo syx $pipe change hostname¿Enter new hostname / visible address:)
n89=..Change 'Real Name': chgname $$1 $$decision(qeg¿incorrigo syx $pipe change gecos¿Enter new Friendly Name: $+ $crlf $crlf $+ [You are under no obligation to use your real name])
n90=.-
n91=.$idfc Services Operator
n92=...Server Only Commands
n93=....SVSJOIN: operserv svsjoin $$1 $$decision(egb¿incorrigo syx $pipe svsjoin¿What channel should $$1 join?)
n94=....SVSNICK: operserv svsnick $$1 $$decision(egb¿incorrigo syx $pipe svsjoin¿What nickname do you want $$1 to be?)
n95=....SVSPART: operserv svspart $$1 # $$decision(egb¿incorrigo syx $pipe svsjoin¿Why are you making $$1 leave # $+ ?)
n96=..Forbid Nickname $$1
n97=...10 minutes: operserv forbid add nick +10m $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $+ $crlf $crlf $+ [ $+ $$1 will be renamed to a guest nickname $+ ])
n98=...An hour: operserv forbid add nick +1h $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $+ $crlf $crlf $+ [ $+ $$1 will be renamed to a guest nickname $+ ])
n99=...A day: operserv forbid add nick +1d $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $+ $crlf $crlf $+ [ $+ $$1 will be renamed to a guest nickname $+ ])
n100=...A week: operserv forbid add nick +1w $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $+ $crlf $crlf $+ [ $+ $$1 will be renamed to a guest nickname $+ ])
n101=...A Month: operserv forbid add nick +28d $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $+ $crlf $crlf $+ [ $+ $$1 will be renamed to a guest nickname $+ ])
n102=...Permanently: operserv forbid add nick +0 $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname permanently forbidden? $+ $crlf $crlf $+ [ $+ $$1 will be renamed to a guest nickname $+ ])
n103=..Oper Info
n104=...Add Operator Info: operserv info add $$1 $$decision(qeg¿incorrigo syx $pipe oper info line¿Enter oper notes line:)
n105=...Delete Info Line: operserv info del $$1 $$decision(Type the info that needs to be removed for some reason:)
n106=...-
n107=...What is this?: explain Extra information can be added by services operators that will show up on the /NICKSERV INFO command $+ $crlf $crlf $+ Only services operators can see this information who have the right operserv privileges
n108=..-
n109=..Services Kick: operserv kick # $$1 $$decision(egb¿incorrigo syx $pipe kill $$1 $+ ¿Enter kick reason / message:)
n110=..Set User Modes: operserv umode $$1 $$decision(egb¿incorrigo syx $pipe svsjoin¿Enter user mode to set on $$1 $+ $crlf $crlf $+ $chr(91) $+ you should use + / - $+ $chr(93))
n111=..Kill: operserv kill $$1 $$decision(egb¿incorrigo syx $pipe kill $$1 $+ ¿Why is $$1 $+ 's connection being closed?)
n112=$iif($wzy(#) != $null,$null,Give / Take Permissions)
n113=.$wdy(#) $+ Owner [~]
n114=..+ Owner: mode # +q $$1
n115=..- Owner: mode # -q $$1
n116=.$wdy(#) $+ Chan. Admin [&&]
n117=..+ Admin: mode # +a $$1
n118=..- Admin: mode # -a $$1
n119=.$wdy(#) $+ Chan. Operator [@]
n120=..+ Operator: mode # +o $$1
n121=..- Operator: mode # -o $$1
n122=.$wdy(#) $+ Half-Op $chr(91) $+ $eval(%,0) $+ $chr(93)
n123=..+ Half-Op: mode # +h $$1
n124=..- Half-Op: mode # -h $$1
n125=.Voice [+]
n126=..+ Voice: mode # +v $$1
n127=..- Voice: mode # -v $$1
n128=.-
n129=.$wdy(#) $+ Remove All Permissions: mode # -qaohv $$1 $1 $1 $1 $1
n130=.-
n131=.Permissions Explained: text-reader incorrigo-syx\docu-mental\statusmodes.tr Different Channel Permission Levels
n132=$iif($wzy(#) != $null,$null,Kick && Ban)
n133=.Quiet $$1: mode # +b ~q: $+ $address($$1, 2)
n134=.Unquiet $$1: mode # -b ~q: $+ $address($$1, 2)
n135=..-
n136=.Kick: kick # $$1 [unspecified]
n137=.Kick (why): kick # $$1 $$decision(vquge¿incorrigo syx $pipe kick $$1¿Enter kick reason:)
n138=.-
n139=.Ban: mode # +b $address($$1, 2)
n140=.Kick and Ban: {
n141=  .timer -m 1 500 kick # $$1 $$decision(vquge¿incorrigo syx $pipe kick $$1¿Why are you banning $$1 $+ ?)
n142=  .timer -m 1 1 mode # +b $address($$1,2)
n143=}
n144=.Temporary Ban: {
n145=  var %tban.duration $decision(vquge¿incorrigo syx $pipe temporary ban $$1¿How long $obk $+ minutes $+ $cbk do you wish to ban $$1 $+ ?)
n146=  var %tban.reason $$decision(vquge¿incorrigo syx $pipe kick $$1¿Why are you temporarily banning $$1 $+ ? $+ $crlf $crlf $+ [required])
n147=  .timer -m 1 250 kick # $$1 %tban.reason
n148=  .timer -m 1 1 mode # +b ~t: $+ %tban.duration $+ : $+ $address($$1,2)
n149=}
n150=.Unban: mode # -b $address($$1, 2)
n151=.-
n152=.Except Hostname: mode # +e $address($$1, 2)
n153=.Remove Exception: mode # -e $address($$1, 2)
n154=$iif($sysop,Kill && Network Ban Menu,$null)
n155=.Kill $$1: kill $$1 $$decision(tegb¿incorrigo syx $pipe kill $$1 $+ ¿Why are you banning $$1 $+ ?)
n156=.-
n157=.Set G Line
n158=..Temporary: {
n159=  var %gline.td $$decision(tegb¿incorrigo syx $pipe set g-line¿Enter duration parameter:)
n160=  var %gline.rs $$decision(tegb¿incorrigo syx $pipe set g-line¿Why are you banning $$1 $+ ?)
n161=  gline $$1 %gline.td banned: %gline.rs
n162=}
n163=..Permanent: {
n164=  var %gline.rs $$decision(tegb¿incorrigo syx $pipe set g-line¿Why are you banning $$1 $+ ?)
n165=  gline $$1 0 banned: %gline.rs
n166=}
n167=..-
n168=..Remove G Line: gline - $+ $$1
n169=.Set Z Line
n170=..Temporary: {
n171=  var %gzline.td $$decision(tegb¿incorrigo syx $pipe set g-zline¿Enter duration parameter:)
n172=  var %gzline.rs $$decision(tegb¿incorrigo syx $pipe set g-zline¿Why are you banning $$1 $+ ? $+ $crlf $crlf $+ [reason will not be shown on (re)connect attempt])
n173=  gzline $$1 %gzline.td banned: %gzline.rs
n174=}
n175=..Permanent: {
n176=  var %gzline.rs $$decision(tegb¿incorrigo syx $pipe set g-zline¿Why are you banning $$1 $+ ? $+ $crlf $crlf $+ [reason will not be shown on (re)connect attempt])
n177=  gzline $$1 0 banned: %gzline.rs
n178=}
n179=..-
n180=..Remove Global Z-Line: gzline - $+ $$1
n181=.Create Exception
n182=..Temporary: {
n183=  var %eline.td $$decision(tegb¿incorrigo syx $pipe set g-line¿How long should this exception remain in place?)
n184=  var %eline.rs $$decision(tegb¿incorrigo syx $pipe set g-line¿What reason is  $$1 $+ ?)
n185=  eline $$1 kGzZs %eline.td exception: %eline.rs
n186=}
n187=..Permanent: {
n188=  var %eline.rs $$decision(tegb¿incorrigo syx $pipe set exception¿Enter exception remarks for $$1 $+ ?)
n189=  eline $$1 kGzZs 0 exception: %eline.rs
n190=}
n191=..-
n192=..Extended Exceptions
n193=...Add User Account: eline ~a: $+ $$1 kGs 0 exception: account is exempt from network bans
n194=...Del User Acount: eline -~a: $+ $$1
n195=..-
n196=..Remove Exceptions: eline - $+ $$1
n197=.-
n198=.Important Information: text-reader incorrigo-syx\docu-mental\x-lines.tr Network Engineer's Notes About Kill and X-Lines
n199=$iif($wzy(#) != $null,$null,Extended Ban / Except)
n200=.Target $chr(91) $+ $extc.mode($$1) $+ $chr(93) Toggle: extc.toggle
n201=.-
n202=.Extended Ban
n203=..Quiet User: extc.setquiet # $$1
n204=..Forward to Channel: extc.forwardtochannel # $$1
n205=..No Nick Change: extc.setnonick # $$1
n206=..Block /join: extc.setnojoin # $$1
n207=..-
n208=..Remove Extended Bans: extc.unban # $$1
n209=.Extended Exemptions
n210=..Moderated Mode: extc.exempt.m # $$1
n211=..External Messages: extc.exempt.n # $$1
n212=..Colour && Control Codes: extc.exempt.c # $$1
n213=..Channel Notices: extc.exempt.p # $$1
n214=..-
n215=..Remove Exemptions: extc.dexempt # $$1
n216=.Target Types: noop $$decision(iuog¿incorrigo syx $pipe toggle ban target¿There are two different types of ban target ... $+ $crlf ~account: $+ $$1 $+ $crlf ... or $address($$1, 2) $+ $crlf $crlf $+ One targets the account of $$1 ... which is only useful if the user is logged into an account. $crlf $crlf $+ The other targets their address, which will apply no matter what $+ $c but need to be banned again when their IP / host address changes)
n217=-
n218=$iif(!$idf,$null,Access List)
n219=.Don't Kick on Join: access # add $$1 nokick
n220=.Add Voice [+]: access # add $$1 autovoice
n221=.Add Half-Op [%]: access # add $$1 halfopme
n222=.Add Operator [@]: access # add $$1 autoop
n223=.Add Channel Admin [&&]: access # add $$1 autoprotect
n224=.Add Owner [~]: access # add $$1 autoowner
n225=.Maximum Level: access # add $$1 10000
n226=.-
n227=.Remove $$1 From Access List: access # del $$1
n228=$iif(!$idf,$null,Chanserv Controls)
n229=.Channel Permissions
n230=..UP: chanserv up # $$1
n231=..DOWN: chanserv down # $$1
n232=..-
n233=..OWNER:
n234=...Make Owner: chanserv owner # $$1
n235=...Take Owner: chanserv deowner # $$1
n236=..PROTECT
n237=...Channel Admin: chanserv protect # $$1
n238=...Remove Admin: chanserv deprotect # $$1
n239=..OP
n240=...Channel Operator: chanserv op # $$1
n241=...Remove Ops: chanserv deop # $$1
n242=..HALFOP
n243=...Half-Op: chanserv halfop # $$1
n244=...De-Half Op: chanserv dehalfop # $$1
n245=..VOICE
n246=...Voice: chanserv voice # $$1
n247=...Devoice: chanserv devoice # $$1
n248=.Kick && Ban
n249=..Permanent Ban: chanserv ban # +0 $$1 $$decision(qeg¿incorrigo syx $pipe services ban¿Why are you permanently banning $$1 $+ ?)
n250=..Temporary Ban: chanserv ban # + $+ $$decision(egq¿incorrigo syx $pipe services ban¿How long are you banning $$1 $+ ? $+ $crlf $crlf $+ e.g. 20m / 12h / 3d etc:) $$1 $$decision(egq¿incorrigo syx $pipe services ban¿Why are you banning $$1 ?)
n251=..-
n252=..Remove All Matching Bans: chanserv unban # $$1
n253=.AKick $$1
n254=..AKick $$1: {
n255=  set -e %akick.reason $$decision(qegb¿incorrigo syx $pipe auto-kick¿Enter reason for a-kick:)
n256=  chanserv akick # add $$1 %akick.reason
n257=}
n258=..Delete AKick for $$1: chanserv akick # del $$1
n259=.About Services Control: noop $decision(iog¿incorrigo syx $pipe chanserv user controls¿You can control a user that's on your channel if you're logged into an account with access $+ $crlf $crlf $+ You do not have to be a channel operator to use your chanserv powers)
