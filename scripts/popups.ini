[cpopup]
n0=$wwy(#) $+ Channel Settings - # $+ : ls
n1=-
n2=$pnln Join / Leave / Invite
n3=.$iif($wwy(#), $+ $pnln Return to This Channel,Hop [Leave / Rejoin]): $iif($wwk(#), hop, join #)
n4=.$wwy(#) $+ Invite Someone Here: invite $$quik.d(doubled,incorrigo syx $pipe send invitation¿Enter nickname to invite to # $+ :) #
n5=.$iif($wwy(#) == $style(2),Close This Window,Leave This Channel): {
n6=  if ($wwy(#) == $style(2)) { part # | halt }
n7=  %part.o = $decision(gvbn¿incorrigo syx $pipe leave # $+ ¿Do you want to leave a parting message while you leave?)
n8=  if (%part.o == $yes) { part # $decision(qeg¿incorrigo syx $pipe leave # $+ ¿Enter parting message for # $+ :) }
n9=  if (%part.o == $no) { part # } 
n10=  else { halt }
n11=}
n12=.Join Another Channel: join $$decision(eg¿incorrigo syx $pipe join channel¿Enter channel name: $next [if you type a second word - it will be used as a password])
n13=.-
n14=.Find Other Channels: {
n15=  var %criterion $$decision(yvg¿incorrigo syx $pipe find channels¿Do you wish to enter a keyword?)
n16=  if (%criterion == $yes) {
n17=    var %criterioin $decision(geq¿incorrigo syx $pipe channel list search¿Enter keyword(s) to refine your channel list:)
n18=  }
n19=  list %criterioin
n20=}
n21=$pnln $wwy(#) $+ Channel Notice
n22=.Send Message: notice # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter channel notice message:)
n23=.-
n24=.$wzy(#) $+ Voice: notice + $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: voice +up])
n25=.$wzy(#) $+ Half Op: notice $percenti $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: half-op +up])
n26=.$wdy(#) $+ Channel Operator: notice @ $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: ch. operator +up])
n27=.$wdy(#) $+ Channel Admin: notice $ampersand $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: ch. admin +up])
n28=.$wdy(#) $+ Owner: notice ~ $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: owner])
n29=$pnln Away Manager: awaymgr
n30=$pnln Change Your Nickname: nick $$decision(qebg¿incorrigo syx $pipe change nickname¿Enter new nickname:)
n31=-
n32=Send Local Time: msg # local time: $gettime
n33=Direct Channel URL
n34=.$chr(91) $+ ircs $+ $chr(58) $+ //irc.incorrigo.io/ $+ $right($chan,-1) $+ $chr(93): msg # IRCS Link: ircs://irc.incorrigo.io/ $+ $right($chan, -1)
n35=.$chr(91) $+ https  $+ $chr(58) $+ //incorrigo.io/irc?ch= $+ $right($chan,-1) $+ $chr(93): msg # Social Media Safe Link: https://incorrigo.io/irc?ch= $+ $right($chan, -1)
n36=.$chr(91) $+ https  $+ $chr(58) $+ //incorrigo.io/web?ch= $+ $right($chan,-1) $+ $chr(93): msg # Browser Client Link: https://incorrigo.io/web?ch= $+ $right($chan, -1)
n37=$iif($nln && $me ison #,Channel History Playback,$nul)): history # $$decision(qeg¿incorrigo syx $pipe history playback¿How many lines to play back?)
n38=$iif($nln && $me ison #,Reply to a Message,$nul)): r #
n39=-
n40=Ban / Except / Invite Lists
n41=.$iif($wzy(#) == $$style(2),$null,Ban List)
n42=..Add Ban: mode # +b $$quik.d(doubled, incorrigo syx $pipe ban entry¿Enter user/mask to add to ban list: $next nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n43=..Remove Ban: mode # -b $$quik.d(doubled, incorrigo syx $pipe ban entry¿Enter user/mask to add to ban list: $next nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n44=..-
n45=..Clear All Bans: clear.bans #
n46=..-
n47=..About Ban List: noop $decision(ugo¿incorrigo syx $pipe channel ban list¿You can add an entry onto the ban list using mode +b $next When you match something on the ban list $+ $c you will not be allowed to join the channel $next If you are already on the channel it doesn't remove you $+ $c but some restrictions will be placed until you are either kicked / leave of your own accord)
n48=.$iif($wzy(#) == $style(2),$null,Invite List)
n49=..Add Invite: mode # +I $$quik.d(doubled, incorrigo syx $pipe invite entry¿Enter user/mask to add to invite list: $next nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n50=..Remove Invite: mode # -I $$quik.d(doubled, incorrigo syx $pipe invite entry¿Enter user/mask to remove from invite list: $next nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n51=..-
n52=..Clear All Invites: clear.invites #
n53=..-
n54=..About Invite List: explain An entry on the channel's invite list is added using mode +I $next The invite list allows people to join without being manually invited $+ $c when the channel is invite only [+i] $next Being on the invite list does not let you in if you are banned $+ $c but strangely the /invite command does
n55=.$iif($wzy(#) == $style(2),$null,Exception List)
n56=..Add Exception: mode # +e $$quik.d(doubled, incorrigo syx $pipe exception entry¿Enter user/mask to add to exception list: $next nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n57=..Remove Exception: mode # -e $$quik.d(doubled, incorrigo syx $pipe exception entry¿Enter user/mask to remove from exception list: $next nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n58=..-
n59=..Clear All Exceptions: clear.exceptions #
n60=..-
n61=..About Exceptions: explain If someone matches an exception $+ $c it will override any bans that they also may match. This does nothing if the channel is invite only.
n62=.-
n63=.$wwy(#) $+ View Ban List: mode # +b
n64=.$wwy(#) $+ View Invite List: mode # +I
n65=.$wwy(#) $+ View Exception List: mode # +e
n66=.-
n67=.Help About Channel Lists: text-reader incorrigo-syx\docu-mental\list-modes.tr Ban, Except, Invite lists
n68=$iif($wzy(#) != $null,$null,Extended Ban Creator): extbanner #
n69=$iif($sysop,Network Engineer Menu,$null)
n70=.Operator Chat
n71=..Global Ops: globops $$decision(egt¿incorrigo syx $pipe /globops message¿Enter Global Message:)
n72=..Local Ops: locops $$decision(egt¿incorrigo syx $pipe /locops message¿Enter Server Ops Message:)
n73=..-
n74=..Services GLOBAL: global global $$decision(egt¿incorrigo syx $pipe services announcement¿Enter global announcement:)
n75=..-
n76=.. $+ $server Announce: msg $chr(36) $+ $server $$decision(egt¿incorrigo syx $pipe server announcement¿Enter Message for Server - All Users:)
n77=..Entire Network Announce: msg $chr(36) $+ * $$decision(egt¿incorrigo syx $pipe entire network - calling all users¿Enter Message for Network - All Users:)
n78=..-
n79=.. $+ $server Notice All: notice $chr(36) $+ $server $$decision(egt¿incorrigo syx $pipe server - all users¿Enter Message for Server - All Users:)
n80=..Notice All Network: notice $chr(36) $+ * $$decision(egt¿incorrigo syx $pipe network - all users¿Enter Message for Network - All Users:)
n81=..-
n82=..Wallops Message: wallops $$decision(egt¿incorrigo syx $pipe wallops message¿Enter message to send over wallops: $next [ordinary users can use mode +w])
n83=.-
n84=.Override Modes
n85=..Channel Owner: mode # +q $me
n86=..Channel Admin: mode # +a $me
n87=..Channel Operator: mode # +o $me
n88=..Half Operator: mode # +h $me
n89=..Voice: mode # +v $me
n90=..Set Channel Modes: mode # $$decision(eg¿incorrigo syx $pipe channel mode change¿Enter channel mode change: $next [you can +set and -unset modes])
n91=.Operserv FORBID
n92=..Add Nickname: os forbid add nick + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter FORBID duration:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter nickname to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter nickname forbidden message:)
n93=..Add Channel: os forbid add chan + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter FORBID duration:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter channel to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter channel forbidden message:)
n94=..Add Email: os forbid add email + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter FORBID duration:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter email address to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Why is this email address being forbidden?)
n95=..-
n96=..Delete Nickname: os forbid del nick $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n97=..Delete Channel: os forbid del chan $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n98=..Delete Email: os forbid del email $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n99=..-
n100=..List Nicknames: os forbid list nick
n101=..List Channels: os forbid list chan
n102=..List Emails: os forbid list email
n103=.Services IGNORE
n104=..Add Nick / Mask: {
n105=  var %os.ignore.dur = $$decision(eg¿incorrigo syx $pipe services ignore¿Enter duration of services ignore:)
n106=  var %pervert = $decision(egb¿incorrigo syx $pipe services ignore¿Enter nick or mask: $next [Mask: nick!user@ho.st.na.me])
n107=  os ignore add %os.ignore.dur %pervert $$decision(eg¿incorrigo syx $pipe services ignore¿Why are you adding a services ignore agsint %pervert $+ ?)
n108=}
n109=..Delete Nick / Mask: {
n110=  os ignore del $$decision(eg¿incorrigo syx $pipe services ignore¿Enter nick or mask: $next [Mask: nick!user@ho.st.na.me])
n111=}
n112=..-
n113=..View Services Ignore List: os ignore list
n114=..What is this list?: {
n115=  noop $$decision(iog¿incorrigo syx $pipe services ignore list¿The services ignore list contains nicknames or masks of people who are not permitted to interact with network services $next If you match an entry on this list services will completely ignore you and you will not be able to use them $next If you are experiencing a services ignore, you can still log in to your account )
n116=}
n117=..-
n118=..Clear Services Ignore List: {
n119=  var %clear.signore = $$decision(wyvgb¿incorrigo syx $pipe clear ignore list¿This will clear the entire services ignore list $next Do you wish to proceed?)
n120=  if (%clear.signore == $yes) {
n121=    os ignore clear
n122=  }
n123=}
n124=.Network N-Line List
n125=..Add N-Line: {
n126=  os snline add + $+ $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter n-line duration:) $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter name mask:) $+ : $+ $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter n-line reason:)
n127=}
n128=..Remove N-Line: {
n129=  os snline del $$decision(qeg¿incorrigo syx $pipe delete n-line¿Enter N-Line list number or mask:)
n130=}
n131=..-
n132=..View Services N-Line List: os snline view
n133=..What is this list?: {
n134=  noop $decision(iog¿incorrigo syx $pipe services n-line list¿The services N-Line list is for banning a certain "Real Names" $obk $+ or gecos $+ $cbk from being used $next Setting or trying to connect with a banned name will automatically close your connection until you change it to a different one)
n135=}
n136=..-
n137=..Clear N-Line List: {
n138=  var %pervert $$decision(wyvgb¿incorrigo syx $pipe clear n-line list¿This will clear the services n-line list $next Are you sure?)
n139=  if (%pervert == $yes) {
n140=    os snline clear
n141=  }
n142=}
n143=.Q-Line List
n144=..Add Q-Line: {
n145=  os sqline add + $+ $$decision(qeg¿incorrigo syx $pipe add Q-line¿Enter Q-line duration:) $$decision(qeg¿incorrigo syx $pipe add Q-line¿Enter nick/channel mask to ban:) $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter nick/chan refused message:)
n146=}
n147=..Delete Q-Line: os sqline del $$decision(qeg¿incorrigo syx $pipe delete Q-line¿Enter N-Line list number or mask:)
n148=..-
n149=..View Services Q-Line List: os sqline view
n150=..What is this list?: {
n151=  explain A Q-line is a nickname or channel that is prohibited $next If the entry starts with a $rhash then operserv will treat it as a channel name $next If a user tries to use a nick / channel that matches an entry on this list $+ $c your reason will be given in the form of an error message
n152=}
n153=..-
n154=..Clear Q-Line List: {
n155=  var %pervert $$decision(wyvgb¿incorrigo syx $pipe clear Q-line list¿This will clear the services Q-line list $next Are you sure?)
n156=  if (%pervert == $yes) {
n157=    os sqline clear
n158=  }
n159=}
n160=.Operator KICK: os kick $$decision(eg¿incorrigo syx $pipe services kick¿Enter channel name:) $$decision(eg¿incorrigo syx $pipe services kick¿Enter nickname:)
n161=.Operserv KILL: os kill $$decision(qeg¿incorrigo syx $pipe services kill¿Enter user to kill:) $$decision(qeg¿incorrigo syx $pipe services kill¿Why are you disconnecting this person?)
n162=.-
n163=.Server Admin Commands
n164=..Force Join a Channel: SAJOIN $me $$decision(gte¿incorrigo syx $pipe force join¿Which channel to join?)
n165=..-
n166=.. $+ $iif($wwk(#) == $true,SAJOIN Someone Here,SAJOIN Yourself Inside): $iif($wwk(#) == $true,SAJOIN $$decision(etg¿incorrigo syx $pipe sajoin user¿Enter nickname to bring here:) #,sajoin $me #)
n167=..SAPART Someone From Here: sapart $$decision(etg¿incorrigo syx $pipe force part¿Enter person to leave channel:) #
n168=..SAMODE Set Channel Mode: samode # $$decision(etg¿incorrigo syx $pipe server mode change¿Enter mode change for channel: $next [Mode change will be done by server])
n169=..-
n170=..Server Admin Commands Explained: text-reader incorrigo-syx\docu-mental\sa-cmds.tr S.A. Commands Explained
n171=.Server Only Commands
n172=..Svsjoin Yourself to a Channel: operserv svsjoin $me $$decision(gte¿incorrigo syx $pipe svsjoin a channel¿Which channel to join?)
n173=..Svsjoin Someone Here: operserv svsjoin $$decision(gte¿incorrigo syx $pipe svsjoin user¿Enter nickname to svsjoin here:) #
n174=..Svsnick A User: operserv svsnick $$decision(gte¿incorrigo syx $pipe force nickname change¿Enter nickname to change:) $$decision(gte¿incorrigo syx $pipe force nickname change¿Enter new nickname:)
n175=..Svspart Someone From #: operserv svspart $$decision(gte¿incorrigo syx $pipe svspart douche¿Enter user to SVSPART from here:) #
n176=.$iif($aopper.rmenu(on),$style(1) $+,$null $+) Self-AOP
n177=..$iif($aopper.rmenu(self),$style(1) $+,$null $+) Oper-Override (self): aopper.set self
n178=..$iif($aopper.rmenu(csvc),$style(1) $+,$null $+) Chanserv: {
n179=  if ($decision(tygv¿incorrigo syx $pipe chanserv self-aop¿This setting will only work on registered channels. Proceed?) == $yes) {
n180=    aopper.set csvc
n181=  }
n182=}
n183=..$iif($aopper.rmenu(scmd),$style(1) $+,$null $+) Samode Command: aopper.set scmd
n184=..$iif($aopper.rmenu(svcs),$style(1) $+,$null $+) Operserv Mode: aopper.set svcs
n185=..-
n186=..$iif($aopper.rmenu(off),$style(1) $+,$null $+) Switch Off: aopper.set off
n187=..Set Level $chr(91) $+ $aopper.what $+ $chr(93)
n188=...$iif($aopper.what == +v,$style(1),$null) $+ Voice: aopper.what v
n189=...$iif($aopper.what == +h,$style(1),$null) $+ Half-Op: aopper.what h
n190=...$iif($aopper.what == +o,$style(1),$null) $+ Operator: aopper.what o
n191=...$iif($aopper.what == +a,$style(1),$null) $+ Admin: aopper.what a
n192=..-
n193=..What is Self-AOP?: aopper.details
n194=$iif($wzy(#) != $null,$null,Change Topic): topic # $$decision(qeg¿incorrigo syx $pipe set new topic¿Enter new channel topic:)
n195=$iif($wzy(#) != $null,$null,Set Channel Modes)
n196=.Understanding Channel Settings: text-reader incorrigo-syx\docu-mental\channel-modes.tr Understanding Channel Settings and How They Work
n197=.-
n198=.Manual Mode Entry: mode # $$decision(egb¿incorrigo syx $pipe mode change¿Enter mode change parameters:)
n199=.-
n200=.$wdy(#) $+ Block Colour Codes [c]
n201=..+c: mode # +c
n202=..-c: mode # -c
n203=.$wzy(#) $+ No Channel CTCP Messages [C]
n204=..+C: mode # +C
n205=..-C: mode # -C
n206=..-
n207=..What is this?: { explain CTCP requests are for client responses i.e. what client [& version], local time, etc. $next Sending it to the channel gets a response from everyone all at once $next Setting this mode will stop people from doing this to the whole channel }
n208=.$wdy(#) $+ Lurker Mode [D]
n209=..+D: mode # +D
n210=..-D: mode # -D
n211=..-
n212=..What is this?: explain Delayed Join [+D] will hide someone from ordinary users until they send a first message or become a channel operator. It looks like they joined at the same time $next When opped, it looks like they all joined. When de-opped, it looks like they all left if they haven't said anything yet $+ $crlf $+ $crlf $+ It will allow you to lurk if you don't say anything
n213=.$wdy(#) $+ Flood Protection Profile [F]
n214=..+F <profile>: mode # +F $$decision(egb¿incorrigo syx $pipe input request¿Enter server flood protect profile name:)
n215=..-F: mode # -F
n216=.$wdy(#) $+ Flood Protection Control [f]
n217=..+f <exact controls>: mode # +f $$decision(egb¿incorrigo syx $pipe input request¿Enter specific flood protection settings:)
n218=..-f: mode # -f
n219=.$wdy(#) $+ Profanity Censor [G]
n220=..+G: mode # +G
n221=..-G: mode # -G
n222=..-
n223=..What is this?: explain Setting this mode [+G] will block / censor various bad words and profanity from channel messages
n224=.$wdy(#) $+ Channel History [H]
n225=..+H: mode # +H $$decision(egb¿incorrigo syx $pipe input request¿Chat history playback parameter is of the format lines:time $next Example - 750:5d is max 750 lines within a time frame of five days $next Enter chat history parameter:)
n226=..-H: mode # -H
n227=.$wzy(#) $+ Invite Only [i]
n228=..+i: mode # +i
n229=..-i: mode # -i
n230=..-
n231=..More Information: explain This setting will make # invite only. Only people who are invited may join $next - You can let someone in as a one-off using the /INVITE command $crlf $+ - Any number of people can come if they are on the channel's invite list
n232=.$wdy(#) $+ Calm Down Kick [j]
n233=..+j: mode # +j $$decision(egb¿incorrigo syx $pipe input request¿How many seconds of delay when kicked? $next [a number from 1-20])
n234=..-j: mode # -j
n235=..-
n236=..What is this?: explain Kick-Join Delay [+j 1-20] stops someone from re-joining the channel until 1-20 seconds have passed since they have been kicked
n237=.$wzy(#) $+ Channel Password [k]
n238=..+k <password>: mode # +k $$quik.d(pdoubled,incorrigo syx $eval($chr(124), 0) set channel key¿Enter channel key: $next NB: Everyone inside the channel will be able to see the channel key!)
n239=..-k: mode # -k
n240=.$wzy(#) $+ Disable /KNOCK [K]
n241=..+K: mode # +K
n242=..-K: mode # -K
n243=...-
n244=...What is this?: explain If someone has an invite only channel $+ $c and they don't really care, then no one on will be able to /KNOCK on your channel $next When someone knocks on a channel it asks channel operators for an invitation. Mode +K will remove this function from the channel
n245=.$wdy(#) $+ Link Channel [L]
n246=..+L <channel>: mode # +L $$decision(egb¿incorrigo syx $pipe input request¿Enter channel name to send people who fail to join to:)
n247=..-L: mode # -L
n248=..-
n249=..What is this?: explain A linked channel [+L #channelname] is the channel someone is redirected to if they fail to join your channel [e.g. if the channel is full, or they have the wrong password etc.]
n250=.$wzy(#) $+ Limit Number of Users [l]
n251=..+l <max users>: mode # +l $$decision(qeg¿incorrigo syx $pipe chnnel limit¿Enter maximum number of users:)
n252=..-l: mode # -l
n253=.$wzy(#) $+ Moderated [m]
n254=..+m: mode # +m
n255=..-m: mode # -m
n256=..-
n257=..What is this?: explain Moderated [+m] means that users need to be specifically given voice [+v] to send any message in the channel
n258=.$wzy(#) $+ Moderate Unregistered [M]
n259=..+M: mode # +M
n260=..-M: mode # -M
n261=..-
n262=..What is this?: explain Moderated Unregistered [+M] users that are unregistered / not logged into an account will need to be given voice [+v] to speak
n263=.$wdy(#) $+ No Nickname Changes [N]
n264=..+N: mode # +N
n265=..-N: mode # -N
n266=.$wzy(#) $+ No External Messages [n]
n267=..+n: mode # +n
n268=..-n: mode # -n
n269=.$iif($sysop,Systems Operator Lockout [O],$null)
n270=..+O: mode # +O
n271=..-O: mode # -O
n272=..-
n273=..What is this?: explain When this mode is in effect, only an IRC Operator is able to join the channel $next Not all operators have permission to set / unset this mode. There is a separate permission specifically to allow access to a +O channel
n274=.$wdy(#) $+ Channel is Permanent [P]
n275=..+P: mode # +P
n276=..-P: mode # -P
n277=..-
n278=..What is this?: explain Permanent channels [+P] are not destroyed when everyone leaves, even in the search results of /LIST
n279=.$wzy(#) $+ Channel is Private [p]
n280=..+p: mode # +p
n281=..-p: mode # -p
n282=..-
n283=..What is this?: explain Private [+p] channels will not appear in /LIST searches. It will also be hidden from another user's /WHOIS information. Unless you are currently on that channel yourself
n284=.$wdy(#) $+ Disable /KICK [Q]
n285=..+Q: mode # +Q
n286=..-Q: mode # -Q
n287=..-
n288=..What is This?: explain Channel mode Q disables the kick command from being used. Normal users will be unable to kick others out of the channel, for any reason, at any permission level $next This mode is normally used to make kicks only possible by people with chanserv access using the KICK command $next Services bots and network operators are still able to kick users with /KICK, whether or not they have channel operator permissions
n289=.$wzy(#) $+ Registered Users Only [R]
n290=..+R: mode # +R
n291=..-R: mode # -R
n292=. $+ $style(2) $+ Channel is Registered [r]
n293=..+r: mode # +r
n294=..-r: mode # -r
n295=.$wzy(#) $+ Channel is Secret [s]
n296=..+s: mode # +s
n297=..-s: mode # -s
n298=..-
n299=..What is this?: explain Secret [+s] channels are the same as private [p] but the server will act like the channel doesn't exist in searches like /TOPIC /NAMES /LIST etc ...
n300=.$wdy(#) $+ Strip Colour Codes [S]
n301=..+S: mode # +S
n302=..-S: mode # -S
n303=.$wdy(#) $+ No Channel Notices [T]
n304=..+T: mode # +T
n305=..-T: mode # -T
n306=.$wzy(#) $+ Only Ops Set Topic [t]
n307=..+t: mode # +t
n308=..-t: mode # -t
n309=.$wdy(#) $+ Disable /INVITE [V]
n310=..+V: mode # +V
n311=..-V: mode # -V
n312=.$wdy(#) $+ Secure Connections Only [z]
n313=..+z: mode # +z
n314=..-z: mode # -z
n315=..-
n316=..What is this?: explain Secure only channel mode [+z] will only let users with secure [TLS] connections enter the channel $next Incorrigo Syx uses Strict Transport Security (STS) which will not let mIRC connect if a secure connection cannot be made $+ $c and you would have to go out of your way to do so otherwise $next If # is +z that someone would not be allowed to join because their connection to the network is not secure $crlf $crlf $+ All web and mIRC connections are secure
n317=-
n318=Chanserv Info: chanserv info #
n319=$iif($idf,Open Chanserv Query,$null): query chanserv help
n320=$iif(!$idf,$null,Chanserv Menu)
n321=.$wdy(#) $+ $iif($wdy(#) == $style(2),Registration [Requires Channel Operator],Register / Drop #)
n322=..REGISTER This Channel: chanserv register # $$decision(ebg¿incorrigo syx $pipe channel register description¿Please enter a description for the channel services register:)
n323=..DROP [Unregister] This Channel: $iif($$decision(vgby¿incorrigo syx $pipe unregister channel¿This will permanently delete the channel and all settings from the network services register. Do you wish to continue?) == $yes, chanserv drop # #,noop $$decision(iugob¿incorrigo syx $pipe registered channel¿Channel # was not deleted))
n324=.-
n325=.Permissions
n326=..UP: chanserv up #
n327=..DOWN: chanserv down #
n328=..-
n329=..Owner [~]
n330=...[+q]: chanserv owner #
n331=...[-q]: chanserv deowner #
n332=..Channel Admin [&&]
n333=...[+a]: chanserv protect #
n334=...[-a]: chanserv deprotect #
n335=..Channel Operator [@]
n336=...[+o]: chanserv op #
n337=...[-o]: chanserv deop #
n338=..Half-Operator [%]
n339=...[+h]: chanserv halfop #
n340=...[-h]: chanserv dehalfop #
n341=..Voice [+]
n342=...[+v]: chanserv voice #
n343=...[-v]: chanserv devoice #
n344=..-
n345=..About Registered Channel Status Modes: text-reader incorrigo-syx\docu-mental\chanserv-modes.tr Status Modes w/Chanserv Commands
n346=.Set Channel Options
n347=..Auto Op
n348=...ON: cs set autoop # on
n349=...OFF: cs set autoop # off
n350=...-
n351=...What is this?: explain When someone joins who is on the channel's /ACCESS list, they will automatically be made channel operator - or whatever status they are given by the access list
n352=..Ban Type
n353=...0 [*!user@host.or.ip]: cs set bantype # 0
n354=...1 [*!*user@host.or.ip]: cs set bantype # 1
n355=...2 [*!*@host.or.ip]: cs set bantype # 2
n356=...3 [*!*user@*.domain.ip]: cs set bantype # 3
n357=...-
n358=...What is this?: explain The BANTYPE setting tells chanserv the parts of someone's address to use when it is banning them for any reason $next If you have not changed this setting on a channel yet, the default setting is [2]
n359=..Channel Register Description: cs set description # $$decision(ebg¿incorrigo syx $pipe channel register description¿Enter new description for # $+ :)
n360=..Channel Email Address: cs set email # $$decision(ebg¿incorrigo syx $pipe channel email¿Enter an e-mail address to associate with # $+ :)
n361=..Keep Modes
n362=...ON: cs set keepmodes # on
n363=...OFF: cs set keepmodes # off
n364=...-
n365=...What is this?: explain KEEPMODES will remember the channel modes if it goes empty, and set them again when it is no longer empty
n366=..Keep / Lock Topic
n367=...Keep Topic ON: cs set keeptopic # on
n368=...Keep Topic OFF: cs set keeptopic # off
n369=...LOCK Topic: cs topic # lock
n370=...Remove LOCK: cs topic # unlock
n371=...-
n372=...What is this?: explain KEEPTOPIC will remember the topic if the channel goes empty, and set it again when it is no longer empty $next Topic LOCK will stop it from being changed by anyone that isn't on the channel's /ACCESS list
n373=..Peace
n374=...ON: cs set peace # on
n375=...OFF: cs set peace # off
n376=...-
n377=...What is this?: explain PEACE will prevent people from being kicked or de-opped by services, if they are on the access list
n378=..Private
n379=...ON: cs set private # on
n380=...OFF: cs set private # off
n381=...-
n382=...What is this?: explain When PRIVATE is set, # will not appear in any results of the chanserv LIST command
n383=..Restricted
n384=...ON: cs set restricted # on
n385=...OFF: cs set restricted # off
n386=...-
n387=...What is this?: explain RESTRICTED CHANNEL MODE $next In a restricted channel, everyone who joins must be on the /ACCESS list $next Even if they are only set as NOKICK and nothing else $next Anyone who is not on the access list will be automatically kicked and banned by services $next Anyone on the access list can use /CHANSERV UNBAN # to regain entry
n388=..Secure
n389=...ON: cs set secure # on
n390=...OFF: cs set secure # off
n391=...-
n392=...What is this?: explain SECURE will not give users with permissions on the /ACCESS list their status mode / chanserv commands until they have successfully logged into their account after / during connect
n393=..Secure Founder
n394=...ON: cs set securefounder # on
n395=...OFF: cs set securefounder # off
n396=...-
n397=...What is this?: explain SECUREFOUNDER will make sure only the REAL channel founder is allowed to DROP [unregister] the channel $+ $c change the channel founder and its successor $+ $c and not anyone with special permissions using QOP or are set to founder level on the # $+ 's /ACCESS list
n398=..Secure Ops
n399=...ON: cs set secureops # on
n400=...OFF: cs set secureops # off
n401=...-
n402=...What is this?: explain SECUREOPS will not allow someone to become a channel operator if they are not in the channel's /ACCESS list
n403=..Sign Kick
n404=...[Default Voice - 3]: chanserv levels # set SIGNKICK 3
n405=...[Default Half-Op - 4]: chanserv levels # set SIGNKICK 4
n406=...[Default Op - 5]: chanserv levels # set SIGNKICK 5
n407=...[Default Protect - 10]: chanserv levels # set SIGNKICK 10
n408=...[Default Owner - 9999]: chanserv levels # set SIGNKICK 9999
n409=...FOUNDER Only: chanserv levels # set SIGNKICK FOUNDER
n410=...-
n411=...Use Your Own Numeric: cs set signkick # $$decision(eg¿incorrigo syx $pipe signkick level¿Enter sign kick level: $next [must be a value between 1-10000])
n412=...-
n413=...ON [any level]: chanserv set signkick # on
n414=...OFF: chanserv set signkick # off
n415=...-
n416=...What is this?: explain SIGNKICK sets the user level in the channel's /ACCESS list where someone using the KICK command will have their name added to the KICK reason $next Anyone at an higher level than the SIGNKICK setting will NOT have their nickname added to the KICK reason used by chanserv
n417=..Successor
n418=...Set Channel Successor: cs set successor # $$decision(ebg¿incorrigo syx $pipe set channel successor¿Enter user account nickname of # successor:)
n419=...-
n420=...What is this?: explain The SUCCESSOR of a channel is the last hope of it surviving $+ $c if the channel's FOUNDER has their account dropped [unregistered], or if their account expires while the channel is still registered to them $next In either of these events $+ $c the successor will automatically become the channel founder and # will live on!
n421=..Channel URL: cs set url # $$decision(gbe¿incorrigo syx $pipe set url for # $+ ¿Enter URL to associate with # $+ :)
n422=.Channel Entry Message
n423=..Add Line: chanserv entrymsg # add $$decision(eubg¿incorrigo syx $pipe channel entry message¿Enter channel entry message to add:)
n424=..Remove Line: chanserv entrymsg # del $$decision(eubg¿incorrigo syx $pipe channel entry message¿Enter line number to remove:)
n425=..View All Lines: chanserv entrymsg # list
n426=..-
n427=..Clear All Entry Message: chanserv entrymsg # clear
n428=.$iif(!$sysop, $null, -)
n429=.$iif(!$sysop, $null, Operator Informaton #)
n430=..Add Operator Notes: operserv info add # $$decision(etgb¿incorrigo syx $pipe add oper info¿Enter operator info note:)
n431=..Delete Note: operserv info del # $$decision(etgb¿incorrigo syx $pipe add oper info¿Type / paste the entry you wish to remove:)
n432=..Clear Operator Notes: operserv info clear #
n433=..-
n434=..What is Operator Info?: noop $$decision(tgo¿incorrigo syx $pipe what this is¿When you use the chanserv INFO command $+ $c there is additional info only available to services operators $next You can use operserv INFO to add or remove lines of oper-only info about a nickname or channel)
n435=.$iif(!$sysop, $null, Suspend #)
n436=..Suspend This Channel: cs suspend # $$decision(teg¿incorrigo syx $pipe suspend channel¿How long should the channel be suspended? $+ $crlf $crlf [e.g. 28d for 28 days, 0 for indefinite]) $$decision(teg¿incorrigo syx $pipe suspend channel¿Enter channel suspended reason:)
n437=..Unsuspend Now: cs unsuspend #
n438=.Lock Modes on #
n439=..Add a Mode Lock: chanserv mode # lock add $$decision(qgbe¿incorrigo syx $pipe lock modes¿Enter mode [and any parameter] to lock:)
n440=..Remove a Mode Lock: chanserv mode # lock del $$decision(qgbe¿incorrigo syx $pipe lock modes¿Enter mode to unlock:)
n441=..Set Mode Lock: chanserv mode # lock set $$decision(qgbe¿incorrigo syx $pipe lock modes¿Enter mode lock to set: $next [these modes will replace ALL that are currently locked])
n442=..-
n443=..What is Mode Lock?: noop $$decision(igo¿incorrigo syx $pipe about mode lock¿When a mode is locked $+ $c nobody can unset / change it $+ $c even if they are a channel operator $next You must have chanserv permissions on # to lock or unlock modes $next Bans %+ $c invites $+ $c and exceptions can also be locked as well as regular modes $next Locked modes will persist if the channel goes empty / is created again)
n444=.$iif(!$idf,$null,Remove Access Restrictions)
n445=..Unban Yourself: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv unban %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n446=..Services Invite: { var %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker lock add +I ~a: $+ $me | chanserv invite %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker } }
n447=..-
n448=..Channel Key [+k]: { var %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv getkey %cserv.wanker }
n449=..Remove Key [-k]: { var %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -k wanker | if ($me !ison 5cserv.wanker) { .timer -m 1 250 join %cserv.wanker } }
n450=..-
n451=..Remove User Limit [+l]: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -l | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n452=..-
n453=..What is this?: explain '(Re)gain Channel Access' is for channel owner / operator who has ended up being unable to join their own channel $next Obviously this couldn't be used to regain access to just any channel $+ $c you would need permission from chanserv first $next If you are a network operator $+ $c then this will work whether you have permissions on the channel's access list or you don't
n454=.$iif(!$sysop, $null, Channel Kill): os chankill # + $+ $$decision(teg¿incorrigo syx $pipe channel a-kill¿How long should everyone's AKILL last? $next [e.g. 28d for 29 days, 0 for indefinite]) $$decision(teg¿incorrigo syx $pipe channel a-kill¿Enter reason message for everyone's a-kill:) $$decision(tgb¿incorrigo syx $pipe channel a-kill¿CAUTION: This will ban every user in # from the network. $next Do you wish to continue with channel a-kill?)
n455=$iif(!$idf,$null, Access List)
n456=.# Access List: access # list
n457=.-
n458=.Grant Access [No Kick]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $next [mask format: nick!user@host.name.or.ip]) nokick
n459=.Add Voice [+]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $next [mask format: nick!user@host.name.or.ip]) autovoice
n460=.Add Half-Op [%]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $next [mask format: nick!user@host.name.or.ip]) halfopme
n461=.Add Operator [@]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $next [mask format: nick!user@host.name.or.ip]) op
n462=.Add Channel Admin [&&]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $next [mask format: nick!user@host.name.or.ip]) autoprotect
n463=.Add Owner [~]: {
n464=  var %plank = $$decision(eg¿incorrigo syx $pipe access list¿Enter account/nick name or mask for access entry: $next [mask format: nick!user@host.name.or.ip])
n465=  var %plimp = $decision(wyvbg¿incorrigo syx $pipe grant access¿You are about to give the following user/mask: $next %plank $next Channel owner status. Do you wish to proceed?)
n466=  if (%plimp == $yes) {
n467=    access # add %plank ownerme
n468=  }
n469=}
n470=.-
n471=.Remove Entry From Access List: access # del $$quik.d(doubled,incorrigo syx $pipe access list¿Enter [registered] nickname or mask to remove from access list: $next [mask format: nick!user@host.name.or.ip])
n472=.Numeric Access Entry: access # add $$quik.d(doubled,incorrigo syx $pipe access numeric¿Enter [registered] nickname or mask to add access entry: $next [mask format: nick!user@host.name.or.ip]) $$decision(eg¿incorrigo syx $pipe level numeric¿Enter an access level between [1 - 10000])
n473=.-
n474=.Change Access Levels
n475=..About Access Levels: chanserv help levels desc
n476=..-
n477=..LEVELS Reset: if ($$decision(wgb¿incorrigo syx $pipe levels reset¿This will completely reset all levels. Proceed?)) { chanserv levels # reset }
n478=..Disable a Level: chanserv levels # disable $$decision(eg¿incorrigo syx $pipe levels disable¿Enter access type to be disabled: $next [Find out level's name by looking up the levels list]))
n479=..Set a Level to Founder Only: chanserv levels # set founder $$decision(eg¿incorrigo syx $pipe founder level¿Enter level to become founder only: $next [Find out what a level is called by looking at the list])
n480=..View # Levels: chanserv levels # list
n481=..-
n482=..ACCESS_CHANGE: chanserv levels # set ACCESS_CHANGE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for ACCESS_CHANGE: $next [Between 1 and 10000])
n483=..ACCESS LIST: chanserv levels # set ACCESS_LIST $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for ACCESS_LIST: $next [Between 1 and 10000])
n484=..NOKICK (for Restricted Channel): chanserv levels # set NOKICK $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for NOKICK: $next [Between 1 and 10000])
n485=..!FANTASIA (Bot): chanserv levels # set FANTASIA $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for FANTASIA: $next [Between 1 and 10000])
n486=..GREET: chanserv levels # set GREET $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for GREET: $next [Between 1 and 10000])
n487=..AUTOVOICE: chanserv levels # set AUTOVOICE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOVOICE: $next [Between 1 and 10000])
n488=..VOICEME: chanserv levels # set VOICEME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for VOICEME: $next [Between 1 and 10000])
n489=..VOICE: chanserv levels # set VOICE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for VOICE: $next [Between 1 and 10000])
n490=..INFO: chanserv levels # set INFO $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for INFO: $next [Between 1 and 10000])
n491=..SAY (Channel Bot): chanserv levels # set SAY $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for SAY: $next [Between 1 and 10000])
n492=..AUTOHALFOP: chanserv levels # set AUTOHALFOP $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOHALFOP: $next [Between 1 and 10000])
n493=..HALFOPME: chanserv levels # set HALFOPME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for HALFOPME: $next [Between 1 and 10000])
n494=..HALFOP: chanserv levels # set HALFOP $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for HALFOP: $next [Between 1 and 10000])
n495=..KICK: chanserv levels # set KICK $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for KICK: $next [Between 1 and 10000])
n496=..SIGNKICK: chanserv levels # set SIGNKICK $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for SIGNKICK: $next [Between 1 and 10000])
n497=..BAN: chanserv levels # set BAN $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for BAN: $next [Between 1 and 10000])
n498=..TOPIC: chanserv levels # set TOPIC $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for TOPIC: $next [Between 1 and 10000])
n499=..MODE: chanserv levels # set MODE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for MODE: $next [Between 1 and 10000])
n500=..GETKEY: chanserv levels # set GETKEY $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for GETKEY: $next [Between 1 and 10000])
n501=..INVITE: chanserv levels # set INVITE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for INVITE: $next [Between 1 and 10000])
n502=..UNBAN: chanserv levels # set UNBAN $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for UNBAN: $next [Between 1 and 10000])
n503=..AUTOOP: chanserv levels # set AUTOOP $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOOP: $next [Between 1 and 10000])
n504=..OPME: chanserv levels # set OPME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for OPME: $next [Between 1 and 10000])
n505=..OP: chanserv levels # set OP $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for OP: $next [Between 1 and 10000])
n506=..AUTOPROTECT: chanserv levels # set AUTOPROTECT $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOPROTECT: $next [Between 1 and 10000])
n507=..AKICK: chanserv levels # set AKICK $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AKICK: $next [Between 1 and 10000])
n508=..BADWORDS (Bot): chanserv levels # set BADWORDS $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for BADWORDS: $next [Between 1 and 10000])
n509=..$style(2) $+ ASSIGN (Bot) [Founder Only]: noop
n510=..MEMO: chanserv levels # set MEMO $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for MEMO: $next [Between 1 and 10000])
n511=..PROTECTME: chanserv levels # set PROTECTME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for PROTECTME: $next [Between 1 and 10000])
n512=..PROTECT: chanserv levels # set PROTECT $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for PROTECT: $next [Between 1 and 10000])
n513=..SET: chanserv levels # set SET $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for SET: $next [Between 1 and 10000])
n514=..AUTOOWNER: chanserv levels # set AUTOOWNER $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOOWNER: $next [Between 1 and 10000])
n515=..OWNERME: chanserv levels # set OWNERME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for OWNERME $next [Between 1 and 10000])
n516=..$style(2) $+ OWNER Command [Founder Only]: noop
n517=..FOUNDER: chanserv levels # set FOUNDER $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for FOUNDER: $next [Between 1 and 10000])
n518=$iif(!$idf,$null,Auto Kick Menu)
n519=.Add Auto-Kick: chanserv akick # add $$decision(eg¿incorrigo syx $pipe auto kick list¿Enter account / nickname or mask: $next [Mask: nick!user@host.or.ip]) $$decision(egi¿incorrigo syx $pipe auto kick list¿Enter reason for auto kick:)
n520=.Remove Auto-Kick: chanserv akick # del $$decision(qeg¿incorrigo syx $pipe remove auto kick¿Entry to remove from # AKICK list: $next [It's easier to put the number from the akick list])
n521=.-
n522=.View List: chanserv akick # view
n523=.What is auto-kick?: explain Auto-Kick is a list of people who will be kicked and banned by services as soon as they are detected in the channel $next An akick can either be a registered account holder or an address with wildcards permitted $next To remove an akick easily just enter the number of the entry from the akick list
n524=-
n525=$iif(!$idf,$null,Memoserv Lists)
n526=.Send a Memo: memoserv send $$decision(qeg¿incorrigo syx $pipe send memo¿Enter registered nickname or channel:) $$decision(qeg¿incorrigo syx $pipe send memo¿Enter the content of your message:))
n527=.-
n528=.# Inbox: {
n529=  query memoserv
n530=  clear memoserv
n531=  memoserv help all
n532=  .timer -m 1 600 msg memoserv LIST #
n533=}
n534=.$me Inbox: {
n535=  query memoserv
n536=  clear memoserv
n537=  memoserv help all
n538=  .timer -m 1 600 msg memoserv LIST
n539=}
n540=.-
n541=.Memoserv Menu: query memoserv help
n542=.-
n543=.What is memoserv?: explain Memoserv provides a message inbox for your account / regustered channel - it allows messages to be sent and kept for you by services, whether you are online or not
n544=$iif(!$idfr,$null,vHost Settings)
n545=.On: hostserv on
n546=.Off: hostserv off
n547=.-
n548=.Request a vHost: hostserv request $lHngen $+ . $+ $$decision(qeg¿incorrigo syx $pipe request vHost¿Enter vHost to request:)
n549=.-
n550=.What is hostserv?: explain Hostserv is the vanity hostname (vHost) service $next You use it to request a vHost, which will be approved by an operator $next Once approved, your address will be changed automatically when you log into your registered nickname / user account
n551=$iif(!$idf,$null,Botserv / Channel Bot)
n552=.Say Something: botserv say # $$decision(eg¿incorrigo syx $pipe bot - say [message]¿Enter message for bot to channel:)
n553=.Do Something: botserv act # $$decision(eg¿incorrigo syx $pipe bot - do [action]¿Enter /me action for bot to channel:)
n554=.-
n555=.Botserv Info - #: botserv info #
n556=.Start a Botserv Session: {
n557=  query botserv info #
n558=  .timer -m 1 400 query botserv help
n559=}
n560=.-
n561=.View List of Bots: botserv botlist
n562=.Bot Assignment
n563=..Assign Bot: { botserv botlist | botserv assign # $$decision(eg¿incorrigo syx $pipe assign bot¿Enter nickname from bot list to assign here:) }
n564=..Remove Assigned Bot: botserv unassign #
n565=.-
n566=.Badwords List
n567=..Add [Word Beginning]: botserv badwords # add $$decision(qeg¿incorrigo syx $pipe add badwords¿Enter 'word beginning' badword:) START
n568=..Add [Word Ending]: botserv badwords # add $$decision(qeg¿incorrigo syx $pipe add badwords¿Enter 'word beginning' badword:) END
n569=..Add [Single Word]: botserv badwords # add $$decision(qeg¿incorrigo syx $pipe add badwords¿Enter 'word beginning' badword:) SINGLE
n570=..-
n571=..Delete Entry: botserv badwords # del $$decision(qeg¿incorrigo syx $pipe badwords list¿Enter word / list number to remove:)
n572=..Clear Badwords List: {
n573=  var %pervert = $$decision(wyvgb¿incorrigo syx $pipe clear badwords¿You are about to clear the badwords list for # $next Do you wish to proceed?)
n574=  if (%pervert == $yes) {
n575=    botserv badwords # clear
n576=  }
n577=}
n578=..-
n579=..# Badwords List: botserv badwords # list
n580=.Change Bot Settings
n581=..Ban Expire Time
n582=...Set Timer: botserv set banexpire # $$decision(egb¿incorrigo syx $pipe botserv ban time¿Enter ban expire timer for # $+ : $next [Use time notation like 28m or 1d])
n583=...Bot Ban Info: noop $$decision(igo¿incorrigo syx $pipe channel bot bans¿If you have a services bot on your channel then you can customise how and why users will be disciplined for breaking the bot's rules that are set $next In the bot's 'kick' settings there is an option to ban a user when they have been kicked X amount of times. This is when the ban with your duration of choice will be set by your bot)
n584=..Don't Kick Ops
n585=...ON: botserv set dontkickops # on
n586=...OFF: botserv set dontkickops # off
n587=...-
n588=...What is this?: explain When in 'Don't Kick Ops' mode $+ $c the channel bot will not kick someone who would normally trigger a kick ... if they are a channel operator of any kind
n589=..Don't Kick Voices
n590=...ON: botserv set dontkickvoices # on
n591=...OFF: botserv set dontkickvoices # off
n592=...-
n593=...What is this?: explain This setting is the same as 'Don't Kick Ops' but it applies to users who currently have voice when they would otherwise be kicked
n594=..Fantasy Commands
n595=...ON: botserv set fantasy # on
n596=...OFF: botserv set fantasy # off
n597=...-
n598=...What is this?: explain Fantasy setting emulates a real bot by accepting commands that begin with ! or . $next Type !help in the channel when this setting is enabled to see a full list of commands that the channel bot will accept $next Only users on the channel access list will be able to use these commands
n599=..Greet Messages
n600=...ON: botserv set greet # on
n601=...OFF: botserv set greet # off
n602=...-
n603=...What is this?: explain The GREET setting will make the bot say a joining user's greeting message set by nickserv $next For more information: /nickserv help set greet
n604=.Kick Settings
n605=..Kick for AMSG
n606=...ON: botserv kick amsg # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many times will result in a ban?)
n607=...OFF: botserv kick amsg # off
n608=...-
n609=...What is this?: explain The AMSG kicker will kick users who are detected saying the same message to multiple channels at the same time
n610=..Badwords Kick
n611=...ON: botserv kick badwords # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many badword kicks will result in a ban?)
n612=...OFF: botserv kick badwords # off
n613=...-
n614=...What is this?: explain This function will kick users who use the badwords that you can also configure using this menu in the channel $next Even if you use the same bot for another channel $+ $c each channel has its own badwords list for you to configure $next As with the other kick settings - you can control how many times someone is kicked before it also results in a ban
n615=..Kick for Bolds
n616=...ON: botserv kick bolds # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for bolds result in a ban?)
n617=...OFF: botserv kick bolds # off
n618=...-
n619=...What is this?: explain This setting will kick users who use bold formatting codes in their messages $next You can configure how many times someone is kicked for using bolds until it results in a ban
n620=..CAPS Kick
n621=...ON
n622=....25%: botserv kick caps # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for caps will result in a ban?) 15 25
n623=....50%: botserv kick caps # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for caps will result in a ban?) 20 50
n624=....75%: botserv kick caps # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for caps will result in a ban?) 25 75
n625=...OFF: botserv kick caps # off
n626=...-
n627=...What is this?: explain The caps kick setting will remove users who send their messages to the channel using capital letters. The severity of the caps messages is measured as a percentage of the user's entire message $next Many people consider messages which are written in caps akin to shouting and find them offensive
n628=..Colours Kick
n629=...ON: botserv kick colors # ON $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for colours will result in a ban?)
n630=...OFF: botserv kick colors # OFF
n631=...-
n632=...What is thi?: explain This kicker will remove users who use colour codes in their messages. This will normalise the messages that are sent to the channel without there being some obnoxious colouring to the messages that are caused by using colour codes
n633=..Flooding Kick
n634=...ON: botserv kick flood # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for flooding will result in a ban?) $$decision(beg¿incorrigo syx $pipe bot kick config¿Enter how many lines in X seconds that will count as flooding: $next [example: 8 5 will be 8 messages in 5 seconds)
n635=...OFF: botserv kick flood # off
n636=...-
n637=...What is this?: explain The flood kicker does not affect other anti flood features such as channel mode +f. $next This kicker will kick a user from the channel if they send X messages in Y seconds (set by you) ... and if they are kicked for this Z number of times they are banned - also set by you
n638=..Italics Kick
n639=...ON: botserv kick italics # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for italic formatting will result in a ban?)
n640=...OFF: botserv kick italics # off
n641=..Underlines Kick
n642=...ON: botserv kick underlines # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for underline formatting will result in a ban?)
n643=...OFF: botserv kick underlines # off
n644=..Repeating Messages Kick
n645=...ON: botserv kick repeat # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for repetitive messages will result in a ban?) $$decision(beg¿incorrigo syx $pipe bot kick config¿How many times does a message have to repeat itself to cause a kick?)
n646=...OFF: botserv kick repeat # off
n647=..Reversing Messages Kick
n648=...ON: botserv kick reverses # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for reversing messages will result in a ban?)
n649=...OFF: botserv kick reverses # off
n650=.-
n651=.Network Bots Policy: text-reader incorrigo-syx\docu-mental\bot-services.tr Channel Bot Policy + Services
n652=$pnln $iif(!$idf,Identify / Account Login,User Account Menu)
n653=.$pnln Identify as $me $+ : {
n654=  if (r !isin $usermode) { id $$quik.d(pdoubled,incorrigo syx $pipe nickserv identify¿Enter account password for $me $+ :) }
n655=  else { rawbak.d words incorrigo syx $pipe identify nickname¿You are already identified as $me and don't need to log in }
n656=}
n657=.-
n658=.$pnln Recover a Different Nickname: {
n659=  set -e %main.rnick $$decision(qbeg¿incorrigo syx $pipe nickname recovery¿Enter registered nickname to recover:)
n660=  set -e %main.rlpwd $$decision(qbpg¿incorrigo syx $pipe login to nickname¿Enter account password:)
n661=  nickserv RECOVER %main.rnick %main.rlpwd
n662=  .timer 1 1 nick %main.rnick
n663=  .timer 1 2 { unset %main.rnick | unset %main.rlpwd }
n664=}
n665=.$pnln $iif($!idf,Create New Account,$null): {
n666=  register $$decision(qpgb¿incorrigo syx $pipe new account¿Enter account password: $next [no one else will ever have access to this password]) $$decision(qegb¿incorrigo syx $pipe new account¿Enter your email address: $next [required for account verification])
n667=}
n668=.$pnln $iif($getuserID != $null && $getuserID != $me,Use Account Nickname - $getuserID,$null): { nick $getuserID }
n669=.$pnln $iif(!$idf,User Account Login,Log out From $getuserID) $+ : {
n670=  if (!$idf) { nickserv identify $$decision(qeg¿incorrigo syx $pipe user account login¿Enter account name:) $$decision(qpg¿incorrigo syx $pipe user account login¿Enter account password:) }
n671=  else { nickserv logout }
n672=}
n673=.$pnln $iif($idf && !$idfr,Register $me to $getuserID Account,$null) $+ : nickserv group $getuserID
n674=.$pnln $iif(!$idf && !$idfr,Add $me to an Existing Account,$null) $+ : nickserv group $$decision(ebgoq¿incorrigo syx $pipe group nickname¿Enter your account name:) $$decision(pbgoq¿incorrigo syx $pipe group nickname¿Enter account password:)
n675=.$pnln $iif(!$idf,Recover Registered Nickname,$null): {
n676=  var %nicknamed = $$decision(qbego¿incorrigo syx $pipe nickname recovery¿Enter account nickname to recover:)
n677=  var %capsllwdd = $$decision(qbpgo¿incorrigo syx $pipe login to nickname¿Enter account password:)
n678=  nickserv RECOVER %nicknamed %capsllwd
n679=  nick %nicknamed
n680=}
n681=.-
n682=.User Account Options Explained: text-reader incorrigo-syx\docu-mental\account-login.tr Understanding User Account Options
n683=$pnln $iif(!$idf,$null,Nickserv Session): query nickserv help
n684=-
n685=Script Displa&y Settings
n686=.Check Menu Visibility
n687=..$iif($wzy(#) == $null,$style(1),$null) $+ Channel Half-Operator: noop $decision(go¿incorrigo syx $pipe half-op commands¿When you are an half operator $chr(91) $+ $percenti $+ $chr(93) several limited channel op functions become available)
n688=..$iif($wdy(#) == $null,$style(1),$null) $+ Channel Operator: noop $decision(go¿incorrigo syx $pipe channel op commands¿A channel operator [@] can perform all the commands that are needed to register / control a channel $next All the commands on that channel will appear alongside the rest of them)
n689=..$iif($idf == $true,$style(1),$null) $+ User Account Login: noop $decision(go¿incorrigo syx $pipe menu visibility¿When you log in to your account $+ $c services menus will appear $next If you don't have permission to use a particular command $+ $c it won't work $next However if you do have permissions $+ $c you don't need to be a channel operator in order to use them)
n690=..$iif($idfr == $true,$style(1),$null) $+ Using Registered Nickname: noop $decision(go¿incorrigo syx $pipe menu visibility¿If you are logged in to an account you can use any nickname that's available $next Registered nicknames are protected $+ $c and some features - like hostserv requests - require you to be using your registered nickname $+ $obk $+ s $+ $cbk)
n691=..$iif($sysop,$style(1),$null) $+ Network Engineer: noop $decision(tgo¿incorrigo syx $pipe menu visibility¿A successful IRC operator login will show all of the controls and some oper-only ones)
n692=.Light / Dark Mode
n693=..$iif($dark.mode == $false,$style(1),$null) $+ Light: golight
n694=..$iif($dark.mode == $true,$style(1),$null) $+ Dark: godark
n695=..$iif($dark.mode == auto,$style(1),$null) $+ Auto: goauto
n696=.Local Time Format
n697=..$timewy(1) Very Long Date && Time: { %ctcp.timeformat = 1 | echo -atc Info * Local Time: $gettime }
n698=..$timewy(2) Long Date && Time: { %ctcp.timeformat = 2 | echo -atc Info * Local Time: $gettime }
n699=..$timewy(3) Local Time Only: { %ctcp.timeformat = 3 | echo -atc Info * Local Time: $gettime }
n700=..$timewy(4) Brief Time && Date: { %ctcp.timeformat = 4 | echo -atc Info * Local Time: $gettime }
n701=..$timewy(5) Time of Day && Date: { %ctcp.timeformat = 5 | echo -atc Info * Local Time: $gettime }
n702=.Remote Assist
n703=..$iif(!%remote.assist,Show Remote Assist,$style(1) $+ Show Remote Assist): %remote.assist = $iif(!%remote.assist,$true,$false)
n704=..What is remote assist? : explain.ra channel
n705=.-
n706=.$smc Read Out Permission Changes: togglesmc
n707=.$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops

[bpopup]
n0=Incorrigo Sy&x
n1=$iif($server,$pnln --> $me,Connect to Network): {
n2=  if (!$server) { F3 }
n3=  else { checkme }
n4=}
n5=-
n6=$pnln Identify With Nickserv: {
n7=  if (!$idf) { id $$quik.d(pdoubled,incorrigo syx $pipe services identification¿Enter your password to log in with nickserv:) | halt }
n8=  else { rawbak.d words incorrigo syx $pipe services identification¿You are already identified $+ $c and don't need to log in | halt }
n9=}
n10=$pnln User Account && Registration Menu
n11=.New Account Registration: {
n12=  register $$decision(qpgb¿incorrigo syx $pipe new account¿Enter account password: $+ $crlf $crlf $+ [no one else will ever have access to this password]) $$decision(qegb¿incorrigo syx $pipe new account¿Enter your email address: $+ $crlf $crlf $+ [required for account verification])
n13=}
n14=.Re-send Confirmation Code Email: nickserv resend
n15=.Input Confirmation Code: nickserv confirm $$decision(qeg¿incorrigo syx $pipe registration code¿Enter nickserv confirmation code: $+ $crlf $crlf $+ [you should have got this in your email])
n16=$iif($idf,$iif(o !isin $usermode,$pnln Network Engineer,$null),$null): oper $$decision(etbg¿incorrigo syx $pipe network engineer¿Enter engineer ID:) $$decision(ptbg¿incorrigo syx $pipe network engineer¿Enter engineer code: $+ $crlf $crlf $+ [NB: Failed engineer login attempts are monitored])
n17=$pnln Away Manager: awaymgr
n18=$pnln $iif(!$idf,Identify with Nickserv,User Account Options)
n19=.$pnln Identify as $me $+ : {
n20=  if (r !isin $usermode) { id $$quik.d(pdoubled,incorrigo syx $pipe nickserv identify¿Enter account password for $me $+ :) }
n21=  else { rawbak.d words incorrigo syx $pipe identify nickname¿You are already identified as $me and don't need to log in }
n22=}
n23=.-
n24=.$pnln $iif($getuserID != $null && $getuserID != $me,Use Account Nickname - $getuserID,$null): { nick $getuserID }
n25=.$pnln $iif(!$idf,User Account Login,Log out From $getuserID) $+ : {
n26=  if (!$idf) { nickserv identify $$decision(qeg¿incorrigo syx $pipe user account login¿Enter account name:) $$decision(qpg¿incorrigo syx $pipe user account login¿Enter account password:) }
n27=  else { nickserv logout }
n28=}
n29=.$pnln $iif($idf && !$idfr,Register $me to $getuserID Account,$null) $+ : nickserv group $getuserID
n30=.$pnln $iif(!$idf && !$idfr,Add $me to an Existing Account,$null) $+ : nickserv group $$decision(ebgoq¿incorrigo syx $pipe group nickname¿Enter your account name:) $$decision(pbgoq¿incorrigo syx $pipe group nickname¿Enter account password:)
n31=.$pnln $iif(!$idf,Recover Registered Nickname,$null): nickserv RECOVER $$decision(qbego¿incorrigo syx $pipe nickname recovery¿Enter registered nickname to recover:) $$decision(qbpgo¿incorrigo syx $pipe login to nickname¿Enter account password:)
n32=.-
n33=.User Account Options Explained: text-reader incorrigo-syx\docu-mental\account-login.tr Understanding User Account Options
n34=$iif(!$idf,$null,(Re)gain Access to Channel)
n35=.Remove Matching Bans: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv unban %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n36=.Invitation Requirements: { %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker lock add +I ~a: $+ $me | chanserv invite %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker } }
n37=.Channel Key Setting [+k]
n38=..Get Current Key: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv getkey %cserv.wanker
n39=..Remove Key: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -k wanker | if ($me !ison 5cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n40=.Channel Limit Derestriction [+l]: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -l | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n41=.-
n42=.What is this?: explain If you are on a channel's access list $+ $c then you can use chanserv to regain access to the channel $+ $crlf $crlf $+ There are a number of reasons a channel operator can be unable to join. These options will give you a range of different ways you may need to use chanserv to get back inside
n43=$iif(!$idf,$null,Hostserv Menu)
n44=.Switch On: hostserv on
n45=.Switch Off: hostserv off
n46=.-
n47=.Server vHost Login: vhost $$decision(egbt¿incorrigo syx $pipe vHost login¿Enter vHost Operator Number:) $$decision(pgbt¿incorrigo syx $pipe vHost login¿Your password please:)
n48=.-
n49=.Request vHost: {
n50=  if (!$idfr) { return $$decision(hugob¿incorrigo syx $pipe hostserv error¿You get a vHost per-nickname that you have registered $+ $crlf $crlf $+ To request a vHost you need to be identified to nickserv as one of your registered nicknames) }
n51=  else { %main.hsr = $$quik.d(doubled,incorrigo syx $pipe make vhost request¿Enter a vhost / user@vhost request:) }
n52=  if ($left(%main.hsr,3) == lH-) {
n53=    hostserv request %main.hsr
n54=  }
n55=  else { hostserv request $lHngen $+ . $+ %main.hsr }
n56=}
n57=.Generate lH Number: lhnumber
n58=.-
n59=.About Hostserv / vHost: noop $decision(og¿incorrigo syx $pipe about vHost¿When you have a registered nickname $+ $c you can request a vHost from hostserv $+ $crlf $crlf $+ A vHost is a vanity hostname that lets your hostname / ip address be anything you want. When it is activated $+ $c it is automatically applied when you identify for that nickname $+ $crlf $crlf $+ You can have a different vHost for each nickname. You can register multiple nicknames under one account using the nickserv GROUP command)
n60=.What is lH number?: text-reader incorrigo-syx\docu-mental\understanding-vhost.tr Understanding vHost and lH numbers
n61=-
n62=$pnln Change User Info
n63=.Change Nickname: nick $$decision(evq¿incorrigo syx $pipe change username¿Enter new nickname:)
n64=.Change Ident (User Name): setident $$decision(evq¿incorrigo syx $pipe change username¿Enter new ident: $+ $crlf $crlf $+ [nickname!ident@host.vhost.or.ip])
n65=.Change 'Real Name': setname $$decision(evq¿incorrigo syx $pipe change username¿Enter new real name: $+ $crlf $crlf $+ [you are not required to use your real name])
n66=.-
n67=.Server vHost Login: vhost $$decision(egt¿incorrigo syx $pipe server vHost¿Enter vHost Login Name:) $$decision(pgt¿incorrigo syx $pipe server vHost¿Enter vHost Password:)
n68=$pnln Set User Modes
n69=.Bot Mode [B]
n70=..+B: mode $me +B
n71=..-B: mode $me -B
n72=..-
n73=..What is this?: explain Bot Mode [+B] is a flag that adds a tag to your outgoing messages / line in your /WHOIS response that identifies you as being a bot $+ $crlf $crlf $+ Bots are permitted on our network and this mode helps others identify / facilitate your bot's status
n74=.Bot Deaf Mode [d]
n75=..+d: mode $me +d
n76=..-d: mode $me -d
n77=..-
n78=..What is this?: explain Deaf mode [+d] will stop you from receiving any channel messages that don't start with the designated bot command character $+ $crlf $crlf $+ It is not recommended except if your client is a bot. Messages that will come through only start with either exclamation mark '!' or full stop '.'
n79=.Decline Private Messages [D]
n80=..+D: mode $me +D
n81=..-D: mode $me -D
n82=..-
n83=..What is this?: explain Private denied mode [+D] will decline all private messages from other users $+ $c telling them that you don't accept private messages $+ $crlf $crlf $+ With this mode set $+ $c only systems operators / network services are able to send you private messages $+ $c so you will still be able to use services and ask for help while still rejecting othersuch private messages
n84=.Profanity Censor [G]
n85=..+G: mode $me +G
n86=..-G: mode $me -G
n87=..-
n88=..What is this?: explain Profanity censor mode [+G] does the same thing as channel mode +G but with private messages $+ $crlf $crlf $+ If someone uses a word or phrase that is configured as profanity by the server $+ $c then the word / phrase will either be [censor]ed $+ $c or blocked completely
n89=.$iif($sysop,Hide IRC Operator Status $chr(91) $+ H $+ $chr(93),$null)
n90=..+H: mode $me +H
n91=..-H: mode $me -H
n92=..-
n93=..What is this?: explain This mode [+H] will hide your operator status from /WHOIS $+ $c /WHO $+ $c and other user lookups
n94=.Hide Online Time [I]
n95=..+I: mode $me +I
n96=..-I: mode $me -I
n97=..-
n98=..What is this?: explain Hide time mode [+I] will hide your online / idle time(s) from your /WHOIS and othersuch look-ups
n99=.Invisible Mode [i]
n100=..+i: mode $me +i
n101=..-i: mode $me -i
n102=..-
n103=..What is this?: explain Invisible mode [+i] will hide your presence from /WHO and /NAMES requests done by anyone who doesn't share any channels with you $+ $crlf $crlf $+ This is usually set by mIRC automatically when you have successfully connected. But this option gives you more control over it if that's what you want
n104=.IRC Operator [o]
n105=..$iif($sysop,-o,$style(2) $+ -o): mode $me -o
n106=..-
n107=..What is this?: explain IRC Operator status is represented by the user mode [+o] which can only be given from a successful oper login $+ $crlf $crlf $+ Simply having this mode means nothing. However $+ $c all operator privileges can be removed by setting user mode [-o]
n108=.Private User [p]
n109=..+p: mode $me +p
n110=..-p: mode $me -p
n111=..-
n112=..What is this?: explain Private mode [+p] hides information from other people $+ $c such as all the channels you are in from your /WHOIS response. It is supposed to prevent intrusive behaviour from other users
n113=.$iif($sysop,Unkickable Mode [q],$null)
n114=..+q: mode $me +q
n115=..-q: mode $me -q
n116=..-
n117=..What is this?: explain Unkickable mode [+q] protects you from being removed by channel operators $+ $crlf $crlf $+ This mode is for preventing normal users from removing you when an operator presence is needed in the channel $+ $crlf $crlf $+ You will be alerted by the server in a private message when an attempt to kick you has failed
n118=.Registered Nickname [r]
n119=..$style(2) $+ +r: mode $me +r
n120=..$style(2) $+ -r: mode $me -r
n121=..-
n122=..What is this?: explain Registered nickname [+r] can only be set / unset by services or the server that you are connected to $+ $crlf $crlf $+ It denotes that the nickname you are using is registered and you have successfully identified as the owner of it
n123=.Registered Messages Only [R]
n124=..+R: mode $me +R
n125=..-R: mode $me -R
n126=..-
n127=..What is this?: explain Registered Messages Only [+R] will only allow private messages that are sent from a registered user who is currently logged into an account $+ $crlf $crlf $+ Users who message you will be told that they must be logged in to an account to send you messages $+ $c and their message to you will not be delivered
n128=.$iif($sysop,Network Service [S],$null)
n129=..+S: mode $me +S
n130=..-S: mode $me -S
n131=..-
n132=..What is this?: explain Network Services mode [+S] protects service bots on the channels that they are currently on $+ $crlf $crlf $+ This mode can't normally be set by users but services admins with access to the UMODE command by operserv can use it to set this mode onto themselves
n133=.Server Notices [s]
n134=..+s <snomask>: mode $me +s $$decision(teg¿incorrigo syx $pipe snomask set¿Enter snomask parameters:)
n135=..-s: mode $me -s
n136=..-
n137=..Server Notices: text-reader incorrigo-syx\docu-mental\snomasks.tr Server Notice Masks [Snomasks]
n138=.No CTCP Requests [T]
n139=..+T: mode $me +T
n140=..-T: mode $me -T
n141=..-
n142=..What is this?: explain No CTCP Mode [+T] will prevent you from receiving CTCP requests sent to you by other users
n143=.Using a vHost [t]
n144=..+t: mode $me +t
n145=..-t: mode $me -t
n146=..-
n147=..What is this?: explain vHost mode [+t] is usually set by the server [/VHOST] or services [hostserv] to denote that you are currently using a vanity hostname [vHost] $+ $crlf $crlf $+ This is not to be confused by cloaked host mode [+x] which is given to users on connecting
n148=.$iif(o isincs $usermode,Show /WHOIS [W],$null)
n149=..+W: mode $me +W
n150=..-W: mode $me -W
n151=..-
n152=..What is this?: explain Show Whois [+W] is a mode that can be set by an IRC operator $+ $c which will notify you when another user looks you up via the /WHOIS command
n153=.Receive Wallops [w]
n154=..$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops
n155=..-
n156=..What is this?: explain Receive Wallops [+w] will show you when message are sent by a systems operator via the /WALLOPS command $+ $crlf $crlf $+ Only an operator can send wallops messages $+ $c but any user through this mode is allowed to receive them
n157=.Cloaked Host [x]
n158=..+x: mode $me +x
n159=..-x: mode $me -x
n160=..-
n161=..What is this?: explain Cloaked hostname mode [+x] gives you a 'cloaked' hostname $+ $crlf $crlf $+ A cloaked hostname will still uniquely identify you / any clones you have online $+ $c but can not be used to connect to you over the internet
n162=.Secure Messages Only [Z]
n163=..+Z: mode $me +Z
n164=..-Z: mode $me -Z
n165=..-
n166=..What is this?: explain Secure Messages Only [+Z] will only allow private messages from users who are connected securely using TLS $+ $crlf $crlf $+ Any users who only have plaintext connections which are not secure $+ $c will receive an error and their message to you will not be delivered $+ $crlf $crlf $+ All users connected via web browser client are connected securely so this will not be an issue for them-
n167=$pnln Join Channel: join $$decision(eg¿incorrigo syx $pipe join channel¿Enter channel name to join: $+ $crlf $crlf $+ [You can add a password by adding another word e.g. #channelname letmein $+ ])
n168=$pnln Find Channels: list $decision(eg¿incorrigo syx $pipe channels¿Throw in a word or leave blank to list all:)
n169=$iif(!$idf,$null,Check Memo List): {
n170=  query memoserv
n171=  clear memoserv
n172=  ms help all
n173=  .timer -m 1 700 msg memoserv LIST
n174=}
n175=-
n176=$pnln Check Online Time: {
n177=  echo -astc Mode * Online: This connection has been active for $getconnectid
n178=}
n179=System Menu
n180=.Light / Dark Mode
n181=..$iif($dark.mode == $false,$style(1),$null) $+ Light Mode: golight
n182=..$iif($dark.mode == $true,$style(1),$null) $+ Dark Mode: godark
n183=..$iif($dark.mode == auto,$style(1),$null) $+ Auto: goauto
n184=.Check Menu Visibility
n185=..$style(2) $+ Channel Half Operator: noop
n186=..$style(2) $+ Channel Operator: noop
n187=..$iif($idf == $true,$style(1),$null) $+ User Account Login: noop $decision(go¿incorrigo syx $pipe menu visibility¿Extensive menus that give you access to our network services $+ $crlf $crlf $+ Services that are available include: nickserv $+ $c chanserv $+ $c memoserv $+ $c hostserv $+ $c and botserv $+ $crlf $crlf $+ You can access new account registration from the [Identify / User Account] menu in the menubar $+ $c status $+ $c and in the channel window)
n188=..$iif($idfr == $true,$style(1),$null) $+ Using Registered Nickname: noop $decision(go¿incorrigo syx $pipe menu visibility¿When you are logged into an account you can still use any available nickname. Multiple nicknames can be added to your account by using the options in the user account menu in status / channel / menubar $+ $crlf $crlf $+ A registered nickname is protected and requires you to login in order to use them. User mode +r is services acknowledgement you are identified for the nickname you are using $+ $crlf $crlf $+ Other menus can behave differently if a registered nickname is required as well as an account login $+ $c but most of the functionality will be visible by a successful account login)
n189=..$iif($sysop,$style(1),$null) $+ Network Engineer: noop $decision(tgo¿incorrigo syx $pipe menu visibility¿In status / channel / top menu bar there will be an option called Network Engineer $+ $crlf $crlf $+ In those places $+ $c you will find the Network Engineer menu $+ $c which contains extensive IRC operator [+ services] commands $+ $crlf $crlf $+ NB: You may not have the correct permissions to use all of the commands that become available)
n190=.-
n191=.Local Time Format
n192=..$timewy(1) Very Long Date && Time: { %ctcp.timeformat = 1 | echo -atc Info * Local Time: $gettime }
n193=..$timewy(2) Long Date && Time: { %ctcp.timeformat = 2 | echo -atc Info * Local Time: $gettime }
n194=..$timewy(3) Local Time Only: { %ctcp.timeformat = 3 | echo -atc Info * Local Time: $gettime }
n195=..$timewy(4) Brief Time && Date: { %ctcp.timeformat = 4 | echo -atc Info * Local Time: $gettime }
n196=..$timewy(5) Time of Day && Date: { %ctcp.timeformat = 5 | echo -atc Info * Local Time: $gettime }
n197=.$smc Read Out Permission Changes: togglesmc
n198=.$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops
n199=.-
n200=.Delete All Settings - Factory Reset: {
n201=  var %do.it $$decision(yvbgw¿incorrigo syx $pipe factory reset!¿IMPORTANT: A factory reset will remove all your settings and start again. Files will not be deleted but your settings will all be permanently erased $+ $crlf $crlf $+ This is the final decision. Do you wish to continue?)
n202=  if (%do.it == $yes) {
n203=    noop $decision(og¿incorrigo syx $pipe factory reset¿Factory reset is complete. mIRC will now restart)
n204=    unset %*
n205=    exit -nr
n206=  }
n207=}

[mpopup]
n0=$iif($server,$pnln --> $me,Connect to Network): {
n1=  if (!$server) { server irc.incorrigo.io }
n2=  else { checkme }
n3=}
n4=-
n5=$pnln Join a Channel: join $$decision(eg¿incorrigo syx $pipe join channel¿Enter channel name to join:)
n6=.$pnln Find Channels: {
n7=  var %criterion $$decision(yvg¿incorrigo syx $pipe find channels¿Do you wish to enter a keyword?)
n8=  if (%criterion == $yes) {
n9=    var %criterioin $decision(geq¿incorrigo syx $pipe channel list search¿Enter keyword(s) to refine your channel list:)
n10=  }
n11=  list %criterioin
n12=}
n13=-
n14=$pnln Away Manager: awaymgr
n15=$iif($idf,$iif(o !isin $usermode,$pnln Network Engineer,$null),$null): oper $$decision(etbg¿incorrigo syx $pipe network engineer¿Enter engineer ID:) $$decision(ptbg¿incorrigo syx $pipe network operator¿Enter engineer code: $+ $crlf $crlf $+ [NB: Failed engineer login attempts are monitored])
n16=$iif($idf,$pnln Query Network Services,$null)
n17=.Nickserv Session: query nickserv help
n18=.Chanserv Session: query chanserv help
n19=.Hostserv Session: query hostserv help
n20=.Memoserv Session: query memoserv help
n21=.Botserv Session: query botserv help
n22=.$iif(!$idf || o !isincs $usermode,$null,Operserv Session): query operserv help
n23=$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops
n24=.-
n25=$pnln Server Help Menu
n26=.Main Menu: helpop
n27=.Help Directory: helpop directory
n28=.-
n29=.Good Modes
n30=..Good Modes Information: helpop goodmodes
n31=..-
n32=..Mode Profiles: helpop modeprofiles
n33=..-
n34=..Small Side Channel: helpop modeprofile.office
n35=.."Main" Channel: helpop modeprofile.bigtime
n36=..Technical Support: helpop modeprofile.techsupport
n37=.User Modes: helpop umodes
n38=.Channel Modes: helpop chmodes
n39=.-
n40=.User Commands: helpop usercmds
n41=.Operator Commands: helpop opercmds
n42=.Server Only Commands: helpop svscmds
n43=.-
n44=.About Incorrigo Syx: helpop about
n45=-
n46=$pnln Change Your Info
n47=.Change Nickname: nick $$decision(evq¿incorrigo syx $pipe change username¿Enter new nickname:)
n48=.Change Ident (User Name): setident $$decision(evq¿incorrigo syx $pipe change username¿Enter new ident: $+ $crlf $crlf $+ [nickname!ident@host.vhost.or.ip])
n49=.Change 'Real Name': setname $$decision(evq¿incorrigo syx $pipe change username¿Enter new real name: $+ $crlf $crlf $+ [you are not required to use your real name])
n50=.$iif($sysop,IP / Hostname,$null): sethost $$decision(evt¿incorrigo syx $pipe manual vHost¿Enter your new host.name.or.ip: $+ $crlf $crlf $+ [this will not stop bans containing your real info from working])
n51=.-
n52=.Server vHost Login: vhost $$decision(egt¿incorrigo syx $pipe server vHost¿Enter vHost Login Name:) $$decision(pgt¿incorrigo syx $pipe server vHost¿Enter vHost Password:)
n53=$pnln Set User Modes
n54=.Bot Mode [B]
n55=..+B: mode $me +B
n56=..-B: mode $me -B
n57=..-
n58=..What is this?: explain Bot Mode [+B] is a flag that adds a tag to your outgoing messages / line in your /WHOIS response that identifies you as being a bot $+ $crlf $crlf $+ Bots are permitted on our network and this mode helps others identify / facilitate your bot's status
n59=.Bot Deaf Mode [d]
n60=..+d: mode $me +d
n61=..-d: mode $me -d
n62=..-
n63=..What is this?: explain Deaf mode [+d] will stop you from receiving any channel messages that don't start with the designated bot command character $+ $crlf $crlf $+ It is not recommended except if your client is a bot. Messages that will come through only start with either exclamation mark '!' or full stop '.'
n64=.Decline Private Messages [D]
n65=..+D: mode $me +D
n66=..-D: mode $me -D
n67=..-
n68=..What is this?: explain Private denied mode [+D] will decline all private messages from other users $+ $c telling them that you don't accept private messages $+ $crlf $crlf $+ With this mode set $+ $c only systems operators / network services are able to send you private messages $+ $c so you will still be able to use services and ask for help while still rejecting othersuch private messages
n69=.Profanity Censor [G]
n70=..+G: mode $me +G
n71=..-G: mode $me -G
n72=..-
n73=..What is this?: explain Profanity censor mode [+G] does the same thing as channel mode +G but with private messages $+ $crlf $crlf $+ If someone uses a word or phrase that is configured as profanity by the server $+ $c then the word / phrase will either be [censor]ed $+ $c or blocked completely
n74=.$iif($sysop,Hide IRC Operator Status $chr(91) $+ H $+ $chr(93),$null)
n75=..+H: mode $me +H
n76=..-H: mode $me -H
n77=..-
n78=..What is this?: explain This mode [+H] will hide your operator status from /WHOIS $+ $c /WHO $+ $c and other user lookups
n79=.Hide Online Time [I]
n80=..+I: mode $me +I
n81=..-I: mode $me -I
n82=..-
n83=..What is this?: explain Hide time mode [+I] will hide your online / idle time(s) from your /WHOIS and othersuch look-ups
n84=.Invisible Mode [i]
n85=..+i: mode $me +i
n86=..-i: mode $me -i
n87=..-
n88=..What is this?: explain Invisible mode [+i] will hide your presence from /WHO and /NAMES requests done by anyone who doesn't share any channels with you $+ $crlf $crlf $+ This is usually set by mIRC automatically when you have successfully connected. But this option gives you more control over it if that's what you want
n89=.IRC Operator [o]
n90=..$iif($sysop,-o,$style(2) $+ -o): mode $me -o
n91=..-
n92=..What is this?: explain IRC Operator status is represented by the user mode [+o] which can only be given from a successful oper login $+ $crlf $crlf $+ Simply having this mode means nothing. However $+ $c all operator privileges can be removed by setting user mode [-o]
n93=.Private User [p]
n94=..+p: mode $me +p
n95=..-p: mode $me -p
n96=..-
n97=..What is this?: explain Private mode [+p] hides information from other people $+ $c such as all the channels you are in from your /WHOIS response. It is supposed to prevent intrusive behaviour from other users
n98=.$iif($sysop,Unkickable Mode [q],$null)
n99=..+q: mode $me +q
n100=..-q: mode $me -q
n101=..-
n102=..What is this?: explain Unkickable mode [+q] protects you from being removed by channel operators $+ $crlf $crlf $+ This mode is for preventing normal users from removing you when an operator presence is needed in the channel $+ $crlf $crlf $+ You will be alerted by the server in a private message when an attempt to kick you has failed
n103=.Registered Nickname [r]
n104=..$style(2) $+ +r: mode $me +r
n105=..$style(2) $+ -r: mode $me -r
n106=..-
n107=..What is this?: explain Registered nickname [+r] can only be set / unset by services or the server that you are connected to $+ $crlf $crlf $+ It denotes that the nickname you are using is registered and you have successfully identified as the owner of it
n108=.Registered Messages Only [R]
n109=..+R: mode $me +R
n110=..-R: mode $me -R
n111=..-
n112=..What is this?: explain Registered Messages Only [+R] will only allow private messages that are sent from a registered user who is currently logged into an account $+ $crlf $crlf $+ Users who message you will be told that they must be logged in to an account to send you messages $+ $c and their message to you will not be delivered
n113=.$iif($sysop,Network Service [S],$null)
n114=..+S: mode $me +S
n115=..-S: mode $me -S
n116=..-
n117=..What is this?: explain Network Services mode [+S] protects service bots on the channels that they are currently on $+ $crlf $crlf $+ This mode can't normally be set by users but services admins with access to the UMODE command by operserv can use it to set this mode onto themselves
n118=.Server Notices [s]
n119=..+s <snomask>: mode $me +s $$decision(teg¿incorrigo syx $pipe snomask set¿Enter snomask parameters:)
n120=..-s: mode $me -s
n121=..-
n122=..Server Notices: text-reader incorrigo-syx\docu-mental\snomasks.tr Server Notice Masks [Snomasks]
n123=.No CTCP Requests [T]
n124=..+T: mode $me +T
n125=..-T: mode $me -T
n126=..-
n127=..What is this?: explain No CTCP Mode [+T] will prevent you from receiving CTCP requests sent to you by other users
n128=.Using a vHost [t]
n129=..+t: mode $me +t
n130=..-t: mode $me -t
n131=..-
n132=..What is this?: explain vHost mode [+t] is usually set by the server [/VHOST] or services [hostserv] to denote that you are currently using a vanity hostname [vHost] $+ $crlf $crlf $+ This is not to be confused by cloaked host mode [+x] which is given to users on connecting
n133=.$iif(o isincs $usermode,Show /WHOIS [W],$null)
n134=..+W: mode $me +W
n135=..-W: mode $me -W
n136=..-
n137=..What is this?: explain Show Whois [+W] is a mode that can be set by an IRC operator $+ $c which will notify you when another user looks you up via the /WHOIS command
n138=.Receive Wallops [w]
n139=..$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops
n140=..-
n141=..What is this?: explain Receive Wallops [+w] will show you when message are sent by a systems operator via the /WALLOPS command $+ $crlf $crlf $+ Only an operator can send wallops messages $+ $c but any user through this mode is allowed to receive them
n142=.Cloaked Host [x]
n143=..+x: mode $me +x
n144=..-x: mode $me -x
n145=..-
n146=..What is this?: explain Cloaked hostname mode [+x] gives you a 'cloaked' hostname $+ $crlf $crlf $+ A cloaked hostname will still uniquely identify you / any clones you have online $+ $c but can not be used to connect to you over the internet
n147=.Secure Messages Only [Z]
n148=..+Z: mode $me +Z
n149=..-Z: mode $me -Z
n150=..-
n151=..What is this?: explain Secure Messages Only [+Z] will only allow private messages from users who are connected securely using TLS $+ $crlf $crlf $+ Any users who only have plaintext connections which are not secure $+ $c will receive an error and their message to you will not be delivered $+ $crlf $crlf $+ All users connected via web browser client are connected securely so this will not be an issue for them
n152=$iif(o isincs $usermode,Network Engineer,$null)
n153=.Operator Chat
n154=..Global Ops: globops $$decision(egt¿incorrigo syx $pipe /globops message¿Enter Global Message:)
n155=..Local Ops: locops $$decision(egt¿incorrigo syx $pipe /locops message¿Enter Server Ops Message:)
n156=..-
n157=..Services GLOBAL: global global $$decision(egt¿incorrigo syx $pipe services announcement¿Enter global announcement:)
n158=..-
n159=.. $+ $server Announce: msg $chr(36) $+ $server $$decision(egt¿incorrigo syx $pipe server announcement¿Enter Message for Server - All Users:)
n160=..Entire Network Announce: msg $chr(36) $+ * $$decision(egt¿incorrigo syx $pipe entire network - calling all users¿Enter Message for Network - All Users:)
n161=..-
n162=.. $+ $server Notice All: notice $chr(36) $+ $server $$decision(egt¿incorrigo syx $pipe server - all users¿Enter Message for Server - All Users:)
n163=..Notice All Network: notice $chr(36) $+ * $$decision(egt¿incorrigo syx $pipe network - all users¿Enter Message for Network - All Users:)
n164=..-
n165=..Wallops Message: wallops $$decision(egt¿incorrigo syx $pipe wallops message¿Enter message to send over wallops: $next [ordinary users can use mode +w])
n166=.-
n167=.Operserv FORBID
n168=..Add Nickname: os forbid add nick + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter FORBID duration:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter nickname to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter nickname forbidden message:)
n169=..Add Channel: os forbid add chan + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter FORBID duration:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter channel to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter channel forbidden message:)
n170=..Add Email: os forbid add email + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter FORBID duration:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter email address to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Why is this email address being forbidden?)
n171=..-
n172=..Delete Nickname: os forbid del nick $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n173=..Delete Channel: os forbid del chan $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n174=..Delete Email: os forbid del email $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n175=..-
n176=..List Nicknames: os forbid list nick
n177=..List Channels: os forbid list chan
n178=..List Emails: os forbid list email
n179=.Services IGNORE
n180=..Add Nick / Mask: {
n181=  var %os.ignore.dur = $$decision(eg¿incorrigo syx $pipe services ignore¿Enter duration of services ignore:)
n182=  var %pervert = $decision(egb¿incorrigo syx $pipe services ignore¿Enter nick or mask: $next [Mask: nick!user@ho.st.na.me])
n183=  os ignore add %os.ignore.dur %pervert $$decision(eg¿incorrigo syx $pipe services ignore¿Why are you adding a services ignore agsint %pervert $+ ?)
n184=}
n185=..Delete Nick / Mask: {
n186=  os ignore del $$decision(eg¿incorrigo syx $pipe services ignore¿Enter nick or mask: $next [Mask: nick!user@ho.st.na.me])
n187=}
n188=..-
n189=..View Services Ignore List: os ignore list
n190=..What is this list?: {
n191=  noop $$decision(iog¿incorrigo syx $pipe services ignore list¿The services ignore list contains nicknames or masks of people who are not permitted to interact with network services $next If you match an entry on this list services will completely ignore you and you will not be able to use them $next If you are experiencing a services ignore, you can still log in to your account )
n192=}
n193=..-
n194=..Clear Services Ignore List: {
n195=  var %clear.signore = $$decision(wyvgb¿incorrigo syx $pipe clear ignore list¿This will clear the entire services ignore list $next Do you wish to proceed?)
n196=  if (%clear.signore == $yes) {
n197=    os ignore clear
n198=  }
n199=}
n200=.Network N-Line List
n201=..Add N-Line: {
n202=  os snline add + $+ $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter n-line duration:) $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter name mask:) $+ : $+ $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter n-line reason:)
n203=}
n204=..Remove N-Line: {
n205=  os snline del $$decision(qeg¿incorrigo syx $pipe delete n-line¿Enter N-Line list number or mask:)
n206=}
n207=..-
n208=..View Services N-Line List: os snline view
n209=..What is this list?: {
n210=  noop $decision(iog¿incorrigo syx $pipe services n-line list¿The services N-Line list is for banning a certain "Real Names" $obk $+ or gecos $+ $cbk from being used $next Setting or trying to connect with a banned name will automatically close your connection until you change it to a different one)
n211=}
n212=..-
n213=..Clear N-Line List: {
n214=  var %pervert $$decision(wyvgb¿incorrigo syx $pipe clear n-line list¿This will clear the services n-line list $next Are you sure?)
n215=  if (%pervert == $yes) {
n216=    os snline clear
n217=  }
n218=}
n219=.Q-Line List
n220=..Add Q-Line: {
n221=  os sqline add + $+ $$decision(qeg¿incorrigo syx $pipe add Q-line¿Enter Q-line duration:) $$decision(qeg¿incorrigo syx $pipe add Q-line¿Enter nick/channel mask to ban:) $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter nick/chan refused message:)
n222=}
n223=..Delete Q-Line: os sqline del $$decision(qeg¿incorrigo syx $pipe delete Q-line¿Enter Q-Line list number or mask:)
n224=..-
n225=..View Services Q-Line List: os sqline view
n226=..What is this list?: {
n227=  explain A Q-line is a nickname or channel that is prohibited $next If the entry starts with a $rhash then operserv will treat it as a channel name $next If a user tries to use a nick / channel that matches an entry on this list $+ $c your reason will be given in the form of an error message
n228=}
n229=..-
n230=..Clear Q-Line List: {
n231=  var %pervert $$decision(wyvgb¿incorrigo syx $pipe clear Q-line list¿This will clear the services Q-line list $next Are you sure?)
n232=  if (%pervert == $yes) {
n233=    os sqline clear
n234=  }
n235=}
n236=.Operator KICK: os kick $$decision(eg¿incorrigo syx $pipe services kick¿Enter channel name:) $$decision(eg¿incorrigo syx $pipe services kick¿Enter nickname:)
n237=.Operserv KILL: os kill $$decision(qeg¿incorrigo syx $pipe services kill¿Enter user to kill:) $$decision(qeg¿incorrigo syx $pipe services kill¿Why are you disconnecting this person?)
n238=.$iif($aopper.rmenu(on),$style(1) $+,$null $+) Self-AOP
n239=..$iif($aopper.rmenu(self),$style(1) $+,$null $+) Oper-Override (self): aopper.set self
n240=..$iif($aopper.rmenu(csvc),$style(1) $+,$null $+) Chanserv: {
n241=  if ($decision(tygv¿incorrigo syx $pipe chanserv self-aop¿This setting will only work on registered channels. Proceed?) == $yes) {
n242=    aopper.set csvc
n243=  }
n244=}
n245=..$iif($aopper.rmenu(scmd),$style(1) $+,$null $+) Samode Command: aopper.set scmd
n246=..$iif($aopper.rmenu(svcs),$style(1) $+,$null $+) Operserv Mode: aopper.set svcs
n247=..-
n248=..$iif($aopper.rmenu(off),$style(1) $+,$null $+) Switch Off: aopper.set off
n249=..Set Level $chr(91) $+ $aopper.what $+ $chr(93)
n250=...$iif($aopper.what == +v,$style(1),$null) $+ Voice: aopper.what v
n251=...$iif($aopper.what == +h,$style(1),$null) $+ Half-Op: aopper.what h
n252=...$iif($aopper.what == +o,$style(1),$null) $+ Operator: aopper.what o
n253=...$iif($aopper.what == +a,$style(1),$null) $+ Admin: aopper.what a
n254=..-
n255=..What is Self-AOP?: aopper.details
n256=$pnln $iif(!$idf,Identify with Nickserv,User Account Options)
n257=.$pnln Identify as $me $+ : {
n258=  if (r !isin $usermode) { id $$quik.d(pdoubled,incorrigo syx $pipe nickserv identify¿Enter account password for $me $+ :) }
n259=  else { rawbak.d words incorrigo syx $pipe identify nickname¿You are already identified as $me and don't need to log in }
n260=}
n261=.$iif(!$idf,Create New Account,$null): {
n262=  register $$decision(qpgb¿incorrigo syx $pipe new account¿Enter account password: $+ $crlf $crlf $+ [no one else will ever have access to this password]) $$decision(qegb¿incorrigo syx $pipe new account¿Enter your email address: $+ $crlf $crlf $+ [required for account verification])
n263=}
n264=.-
n265=.$pnln $iif($getuserID != $null && $getuserID != $me,Use Account Nickname - $getuserID,$null): { nick $getuserID }
n266=.$pnln $iif(!$idf,User Account Login,Log out From $getuserID) $+ : {
n267=  if (!$idf) { nickserv identify $$decision(qeg¿incorrigo syx $pipe user account login¿Enter account name:) $$decision(qpg¿incorrigo syx $pipe user account login¿Enter account password:) }
n268=  else { nickserv logout }
n269=}
n270=.$pnln $iif($idf && !$idfr,Register $me to $getuserID Account,$null) $+ : nickserv group $getuserID
n271=.$pnln $iif(!$idf && !$idfr,Add $me to an Existing Account,$null) $+ : nickserv group $$decision(ebgoq¿incorrigo syx $pipe group nickname¿Enter your account name:) $$decision(pbgoq¿incorrigo syx $pipe group nickname¿Enter account password:)
n272=.$pnln $iif(!$idf,Recover Registered Nickname,$null): nickserv RECOVER $$decision(qbego¿incorrigo syx $pipe nickname recovery¿Enter registered nickname to recover:) $$decision(qbpgo¿incorrigo syx $pipe login to nickname¿Enter account password:)
n273=.-
n274=.User Account Options Explained: text-reader incorrigo-syx\docu-mental\account-login.tr Understanding User Account Options
n275=$$iif(!$idfr,$null,Hostserv Menu)
n276=.Switch On: hostserv on
n277=.Switch Off: hostserv off
n278=.-
n279=.Request vHost: {
n280=  if (!$idfr) { return $$decision(hugob¿incorrigo syx $pipe hostserv error¿You get a vHost per-nickname that you have registered $+ $crlf $crlf $+ To request a vHost you need to be identified to nickserv as one of your registered nicknames) }
n281=  else { %main.hsr = $$quik.d(doubled,incorrigo syx $pipe make vhost request¿Enter a vhost / user@vhost request:) }
n282=  if ($left(%main.hsr,3) == lH-) {
n283=    hostserv request %main.hsr
n284=  }
n285=  else { hostserv request $lHngen $+ . $+ %main.hsr }
n286=}
n287=.Generate lH Number: lhnumber
n288=.-
n289=.About Hostserv / vHost: noop $decision(og¿incorrigo syx $pipe about vHost¿When you have a registered nickname $+ $c you can request a vHost from hostserv $+ $crlf $crlf $+ A vHost is a vanity hostname that lets your hostname / ip address be anything you want. When it is activated $+ $c it is automatically applied when you identify for that nickname $+ $crlf $crlf $+ You can have a different vHost for each nickname. You can register multiple nicknames under one account using the nickserv GROUP command)
n290=.What is lH number?: text-reader incorrigo-syx\docu-mental\understanding-vhost.tr Understanding vHost and lH numbers
n291=$iif(!$idf,$null,(Re)gain Channel Access)
n292=.Remove Matching Bans: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv unban %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n293=.Invitation Requirements: { %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker lock add +I ~a: $+ $me | chanserv invite %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker } }
n294=.Channel Key Setting [+k]
n295=..Get Current Key: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv getkey %cserv.wanker
n296=..Remove Key: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -k wanker | if ($me !ison 5cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n297=.Channel Limit Derestriction [+l]: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -l | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n298=.-
n299=.What is this?: explain 'Regain Channel Access' is for channel owner / operator who has ended up being unable to join their own channel $+ $crlf $crlf $+ Obviously this couldn't be used to regain access to just any channel $+ $c you would need permission from chanserv first
n300=-
n301=Script Display Setting&s
n302=.Local Time Format
n303=..$timewy(1) Very Long Date && Time: { %ctcp.timeformat = 1 | echo -atc Info * Local Time: $gettime }
n304=..$timewy(2) Long Date && Time: { %ctcp.timeformat = 2 | echo -atc Info * Local Time: $gettime }
n305=..$timewy(3) Local Time Only: { %ctcp.timeformat = 3 | echo -atc Info * Local Time: $gettime }
n306=..$timewy(4) Brief Time && Date: { %ctcp.timeformat = 4 | echo -atc Info * Local Time: $gettime }
n307=..$timewy(5) Time of Day && Date: { %ctcp.timeformat = 5 | echo -atc Info * Local Time: $gettime }
n308=.Check Menu Visibility
n309=..$style(2) $+ Channel Half Operator: noop
n310=..$style(2) $+ Channel Operator: noop
n311=..$iif($idf == $true,$style(1),$null) $+ User Account Login: noop $decision(go¿incorrigo syx $pipe menu visibility¿When you log in to your account $+ $c services menus will appear $+ $crlf $crlf $+ If you don't have permission to use a particular command $+ $c it won't work $+ $crlf $crlf $+ However if you do have permissions $+ $c you don't need to be a channel operator in order to use them)
n312=..$iif($idfr == $true,$style(1),$null) $+ Using Registered Nickname: noop $decision(go¿incorrigo syx $pipe menu visibility¿You will stay logged into your account if you change your nickname $+ $crlf $crlf $+ Using one of your registered nicknames is not so different from being logged in)
n313=..$iif($sysop,$style(1),$null) $+ Network Engineer: noop $decision(tgo¿incorrigo syx $pipe menu visibility¿A successful IRC operator login will show all of the controls and some oper-only ones)
n314=.Light / Dark Mode
n315=..$iif($dark.mode == $false,$style(1),$null) $+ Light Mode: golight
n316=..$iif($dark.mode == $true,$style(1),$null) $+ Dark Mode: godark
n317=..$iif($dark.mode == auto,$style(1),$null) $+ Auto: goauto
n318=.Remote Assist
n319=..$iif(!%remote.assist,Show Remote Assist,$style(1) $+ Show Remote Assist): %remote.assist = $iif(!%remote.assist,$true,$false)
n320=..What is remote assist? : explain.ra status

[qpopup]
n0=--> $$1: whois $$1 $$1
n1=-
n2=Nickserv Account Info: .nickserv info $$1
n3=$iif($ignore($address($$1, 2)),$style(1) $+ Active Ignores For,Ignore) $$1
n4=.Ignore $$1: .ignore $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  ...
n5=.-
n6=.Temporary Ignore
n7=..For 30 Seconds: .ignore -u30 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 30 seconds
n8=..For 60 Seconds: .ignore -u60 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 60 seconds
n9=..For 2 minutes: .ignore -u120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 2 minutes
n10=..For 4 minutes: .ignore -u240 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 4 minutes
n11=..For 8 minutes: .ignore -u480 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 8 minutes
n12=..For 16 minutes: .ignore -u960 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 16 minutes
n13=..For 32 minutes: .ignore -u1920 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 32 minutes
n14=..For an hour: .ignore -u3840 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 hour
n15=..For a day: .ignore -u92160 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 day 
n16=..For a week: .ignore -u645120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 week 
n17=.Ignore Private Things
n18=..All Text / Requests: .ignore -pcntidhy $$1 2 | echo -atc Info2 * Ignore: Ignoring $$1 Private messages & requests
n19=..-
n20=..For 30 Seconds: .ignore -pcntidhyu30 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 30 seconds
n21=..For 60 Seconds: .ignore -pcntidhyu60 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 60 seconds
n22=..For 2 minutes: .ignore -pcntidhyu120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 2 minutes
n23=..For 4 minutes: .ignore -pcntidhyu240 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 4 minutes
n24=..For 8 minutes: .ignore -pcntidhyu480 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 8 minutes
n25=..For 16 minutes: .ignore -pcntidhyu960 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 16 minutes
n26=..For 32 minutes: .ignore -pcntidhyu1920 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 32 minutes
n27=..For an hour: ignore -pcntidhyu3840 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 hour
n28=..For a day: ignore -pcntidhyu92160 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 day 
n29=..For a week: ignore -pcntidhyu645120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 week 
n30=.-
n31=.Stop Ignoring $$1: .ignore -r $$1 2 | echo -atc Info2 * Ignore: No longer ignoring  $+ $$1 $+ 
n32=-
n33=Set Private User Modes
n34=.Private User [p]
n35=..+p: mode $me +p
n36=..-p: mode $me -p
n37=..-
n38=..What is this?: explain Setting mode [+p] will hide all channels you are in from your --> whois response
n39=.Censor Profanity [G]
n40=..+G: mode $me +G
n41=..-G: mode $me -G
n42=..-
n43=..What is this?: explain User mode [G] will replace vulgar words or profanity from the network's profanity list
n44=.Private Messages by Registered Users Only [R]
n45=..+R: mode $me +R
n46=..-R: mode $me -R
n47=..-
n48=..What is this?: explain Setting more [R] will receive private messages from people logged into a user account only
n49=.No CTCP Requests [T]
n50=..+T: mode $me +T
n51=..-T: mode $me -T
n52=..-
n53=..What is this?: explain When more [T] is in place, all CTCP requests are denied. But this means you won't be able to send them either
n54=.Secure Clients Only [Z]
n55=..+Z: mode $me +Z
n56=..-Z: mode $me -Z
n57=..-
n58=..What is this?: explain User mode [Z] means you won't receive messages from plaintext [not securely connected] users
n59=-
n60=CTCP(X) Request
n61=.Ping: echo -tac CTCP * Requestions $$1 $+ 's ping [network latency] ... | .ctcp $$1 PING
n62=.Version: echo -tac CTCP * Requesting $$1 $+ 's version ... | .ctcp $$1 VERSION
n63=.Time: echo -tac CTCP * Requesting $$1 $+ 's local time ... | .ctcp $$1 TIME
n64=.Finger: echo -tac CTCP * Requesting $$1 $+ 's finger ... | .ctcp $$1 FINGER
n65=.-
n66=.Friendly Name: ctcp-x $$1 NAME
n67=.Ident / Email: ctcp-x $$1 EMAIL
n68=.IRC Client: ctcp-x $$1 VERSION
n69=.Script: ctcp-x $$1 SCRIPT
n70=.Local Time: ctcp-x $$1 TIME
n71=.Idle Time: ctcp-x $$1 IDLE
n72=.Website: ctcp-x $$1 URL
n73=.-
n74=.Custom Request: .ctcp $$1 $$decision(eugo¿incorrigo syx $pipe ctcp request¿Enter CTCP request:) | echo -tac CTCP * Sent $$1 client request ...
n75=.What is CTCP?: noop $decision(iugo¿incorrigo syx $pipe ctcp requests¿CTCP stands for "client to client protocol" $+ $crlf $crlf $+ It is a way that a client [app you are using] asks for information from another user's client that is not messaging related)
n76=DCC Actions
n77=.Send File: dcc send $$1
n78=.Direct Chat: dcc chat $$1
n79=.DCC Allow
n80=..Add: dccallow + $+ $$1
n81=..Delete: dccallow - $+ $$1
n82=..-
n83=..What is DCC Allow?: noop $$decision(iog¿incorrigo syx $pipe dcc allow¿Some file types are blocked from being sent by the server $+ $c because they could be malicious software $+ $crlf $crlf $+ To allow someone to send you a blocked file $+ $c you must add them to your DCC allow list. $+ $crlf $crkf $+ Once you have added someone $+ $c they will need to send whatever was blocked once again $+ $c if it was previously blocked
n84=.Trusted User
n85=..Trust $$1: dcc-entrust $$1
n86=..Trust $address($$1, 4): dcc-entrust $address($$1, 4)
n87=..Trust $address($$1, 2): dcc-entrust $address($$1, 2)
n88=..-
n89=..-
n90=..Detrust $$1: dcc-detrust $$1
n91=..Detrust $address($$1, 4): dcc-detrust $address($$1, 4)
n92=..Detrust $address($$1, 2): dcc-detrust $address($$1, 2)
n93=..What is trust?: noop $$decision(oi¿incorrigo syx $pipe dcc trust list¿When you add someone to your DCC trust list $+ $c you will automatically accept their files and chat requests $+ $crlf $crlf $+ You can add someone by their vHost / cloaked hostname and it will still work $+ $crlf $crlf $+ Your trust list is part of mIRC and will still apply between IRC sessions))
n94=.-
n95=.What are these?: text-reader incorrigo-syx\docu-mental\about-dcc.tr Direct Client to Client-
n96=$iif($window($1).type == query,Close This Conversation,$null): {
n97=  if ($decision(ygq¿incorrigo syx $pipe private conversation¿Tell them you've closed?) == $yes) {
n98=    say ACTION has closed the conversation window
n99=  }
n100=  close -cm $$1
n101=}

[lpopup]
n0=--> $$1: whois $$1 $1
n1=User Account Info: nickserv info $$1
n2=Whisper: notice $$1 $$decision(eg¿incorrigo syx $pipe whisper¿Private message to send $$1 $+ :)
n3=Private Conversation: query $$1
n4=-
n5=Notify List
n6=.Add $$1: .notify $$1 | echo -atc Notify * Notify: Added  $+ $$1 $+  to your notify list
n7=.Remove $$1: .notify -r $$1 | echo -atc Notify * Notify: Removed  $+ $$1 $+  from your notify list
n8=$iif(%remote.assist,Remote Assist,$null)
n9=.Give Permission: .auser 50 $address($$1, 2) | echo -atc Info2 * Assist: $$1 [ $+ $address($$1, 2) $+ ] is now allowed to assist
n10=.Remove Permission: .ruser 50 $address($$1, 2) | echo -atc Info2 * Assist: $$1 [ $+ $address($$1, 2) $+ ] is no longer allowed to assist
n11=.-
n12=.Remote Assist Readme: explain.ra nicklist
n13=$iif($ignore($address($$1, 2)),$style(1) $+ Active Ignores for,Ignore) $$1
n14=.Ignore $$1: .ignore $$1 2 | echo -atc Info2 * Ignore: Everything that comes from $address($$1, 2) [ $+ $1 $+ ] is now ignored
n15=.Partial Ignore
n16=..Private Messages and Requests: .ignore -pidhy $$1 2 | echo -atc Info2 * Ignore: Private Messages and Requests from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] are now being ignored
n17=..Invitations to Join Channels: .ignore -i $$1 2 | echo -atc Info2 * Ignore: Invitations to Join Channels from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] are now being ignored
n18=..Strip Message Formatting Codes: .ignore -k $$1 2 | echo -atc Info2 * Ignore: Colour / Text Formatting Codes from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will be stripped
n19=..Matched Highlight List Triggers: .ignore -sh $$1 2 | echo -atc Info2 * Ignore: Matching entries on your highlight list from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will no longer be triggered
n20=..Highlights and Pop-up As Well: .ignore -shy $$1 2 | echo -atc Info2 * Ignore: Pop-ups as well as highlights from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will no longer be triggered
n21=..File / Direct Chat [DCC] Requests: .ignore -d $$1 2 | echo -atc Info2 * Ignore: Direct connection file / chat requests from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will now be disregarded
n22=..CTCP Requests: .ignore -t $$1 2 | echo -atc Info2 * Ignore: CTCP Requests from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will no longer trigger replies
n23=..Notices / Formatting Codes: .ignore -nkh $$1 2 | echo -atc Info2 * Ignore: Notice messages / Text formatting from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will now be stripped
n24=..All Except Private Messages: .ignore -cnt $$1 2 | echo -atc Info2 * Ignore: All channel / CTCP / notice messages - except private messages from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will no longer be displayed
n25=..-
n26=..What is this?: .timer -m 1 150 noop $decision(og¿incorrigo syx $pipe ignore switches¿Partial ignore gives you the option to include someone in your session but at the same time relieve yourself of unwanted private messages / requests etc. $next Direct file transfers / chat requests will _share your real IP address / host name_! if you accept. You can use this menu to block such requests so you can avoid inadvertently choosing that $next NB: Choosing one of these settings will replace any other [even if you are ignoring $$1 completely] that is currently set)
n27=.Temporarily Ignore
n28=..For 30 Seconds: .ignore -u30 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 30 seconds
n29=..For 60 Seconds: .ignore -u60 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 60 seconds
n30=..For 2 minutes: .ignore -u120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 2 minutes
n31=..For 4 minutes: .ignore -u240 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 4 minutes
n32=..For 8 minutes: .ignore -u480 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 8 minutes
n33=..For 16 minutes: .ignore -u960 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 16 minutes
n34=..For 32 minutes: .ignore -u1920 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 32 minutes
n35=.Silence $$1
n36=..Add Silence: .silence $address($$1, 2)
n37=..Unsilence: .silence - $+ $address($$1, 2)
n38=..-
n39=..What is silence?: noop $decision(quoy¿incorrigo syx $pipe silence for session¿Silence is a special type of ignore that blocks someone at the server level. An ignore continues for as long as you want, but a silence only lasts until you disconnect from the server $next Because it's easy to change your nickname $+ $c silence is added for the user's address instead)
n40=.-
n41=.Stop Ignoring $$1: .ignore -r $$1 2 | echo -atc Info2 * Ignore: All ignored activities and requests from  $+ $$1 $+   $+ $chr(91) $+  $+ $address($$1, 2) $+  $+ $chr(93) $+  have been removed from your ignore list
n42=-
n43=CTCP(X) Request
n44=.Ping: echo -tac CTCP * Requestions $$1 $+ 's ping [network latency] ... | .ctcp $$1 PING
n45=.Version: echo -tac CTCP * Requesting $$1 $+ 's version ... | .ctcp $$1 VERSION
n46=.Time: echo -tac CTCP * Requesting $$1 $+ 's local time ... | .ctcp $$1 TIME
n47=.Finger: echo -tac CTCP * Requesting $$1 $+ 's finger ... | .ctcp $$1 FINGER
n48=.-
n49=.Friendly Name: ctcp-x $$1 NAME
n50=.Ident / Email: ctcp-x $$1 EMAIL
n51=.IRC Client: ctcp-x $$1 VERSION
n52=.Script: ctcp-x $$1 SCRIPT
n53=.Local Time: ctcp-x $$1 TIME
n54=.Idle Time: ctcp-x $$1 IDLE
n55=.Website: ctcp-x $$1 URL
n56=.-
n57=.Custom Request: .ctcp $$1 $$decision(eugo¿incorrigo syx $pipe ctcp request¿Enter CTCP request:) | echo -tac CTCP * Sent $$1 client request ...
n58=.What is CTCP?: noop $decision(iugo¿incorrigo syx $pipe ctcp requests¿CTCP stands for "client to client protocol" $next It is a way that a client [app you are using] asks for information from another user's client that is not messaging related)
n59=.-
n60=.Nickname Colours: text-reader incorrigo-syx\docu-mental\nick-colours.tr Nickname Colours Explained [Default Colour Profile]
n61=DCC Actions
n62=.Send File: dcc send $$1
n63=.Direct Chat: dcc chat $$1
n64=.DCC Allow
n65=..Add: dccallow + $+ $$1
n66=..Delete: dccallow - $+ $$1
n67=..-
n68=..What is DCC Allow?: noop $$decision(iog¿incorrigo syx $pipe dcc allow¿Some files are an obvious security risk to you and they will be blocked $next To send such files $+ $c the recipient must add the sender to their DCCALLOW list $next If a file has been blocked before the DCCALLOW $+ $c it will need to be sent again)
n69=.Trusted User
n70=..Trust $$1: dcc-entrust $$1
n71=..Trust $address($$1, 4): dcc-entrust $address($$1, 4)
n72=..Trust $address($$1, 2): dcc-entrust $address($$1, 2)
n73=..-
n74=..-
n75=..Detrust $$1: dcc-detrust $$1
n76=..Detrust $address($$1, 4): dcc-detrust $address($$1, 4)
n77=..Detrust $address($$1, 2): dcc-detrust $address($$1, 2)
n78=..What is trust?: noop $$decision(oi¿incorrigo syx $pipe dcc trust list¿Adding someone to your DCC trust list means you are completely alright with them and will accept anything that they send your way $next If anyone matches an entry in this list $+ $c their files and chats will be automatically accepted and start sending to you)
n79=.-
n80=.What are these?: text-reader incorrigo-syx\docu-mental\about-dcc.tr Direct Client to Client
n81=-
n82=$iif(o isin $usermode,Network Engineer,$null)
n83=.SA Commands
n84=..SAJOIN $$1 $+ : sajoin $$1 $$decision(teg¿incorrigo syx $pipe sajoin¿Enter channel name to send $$1 $+ :)
n85=..SAPART $$1 From #: if ($$decision(vty¿incorrigo syx $pipe sapart¿Are you sure you want $$1 to leave #) == $yes $+ ) { sapart $$1 # }
n86=.Change User Info
n87=..Change Ident: chgident $$1 $$decision(qeg¿incorrigo syx $pipe change username¿Enter new username:)
n88=..Change Hostname: chghost $$1 $lHngen $+ . $+ $$decision(qeg¿incorrigo syx $pipe change hostname¿Enter new hostname / visible address:)
n89=..Change 'Real Name': chgname $$1 $$decision(qeg¿incorrigo syx $pipe change gecos¿Enter new Friendly Name: $next [You are under no obligation to use your real name])
n90=.-
n91=.$idfc Services Operator
n92=...Server Only Commands
n93=....SVSJOIN: operserv svsjoin $$1 $$decision(egb¿incorrigo syx $pipe svsjoin¿What channel should $$1 join?)
n94=....SVSNICK: operserv svsnick $$1 $$decision(egb¿incorrigo syx $pipe svsjoin¿What nickname do you want $$1 to be?)
n95=....SVSPART: operserv svspart # $$decision(egb¿incorrigo syx $pipe svsjoin¿Why are you making $$1 leave # $+ ?)
n96=..Forbid Nickname $$1
n97=...10 minutes: operserv forbid add nick +10m $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $next [ $+ $$1 will be renamed to a guest nickname $+ ])
n98=...An hour: operserv forbid add nick +1h $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $next [ $+ $$1 will be renamed to a guest nickname $+ ])
n99=...A day: operserv forbid add nick +1d $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $next [ $+ $$1 will be renamed to a guest nickname $+ ])
n100=...A week: operserv forbid add nick +1w $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $next [ $+ $$1 will be renamed to a guest nickname $+ ])
n101=...A Month: operserv forbid add nick +28d $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $next [ $+ $$1 will be renamed to a guest nickname $+ ])
n102=...Permanently: forbid add nick +0 $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname permanently forbidden? $next [ $+ $$1 will be renamed to a guest nickname $+ ])
n103=..Oper Info
n104=...Add Operator Info: operserv info add $$1 $$decision(qeg¿incorrigo syx $pipe oper info line¿Enter oper notes line:)
n105=...Delete Info Line: operserv info del $$1 $$decision(Type the info that needs to be removed for some reason:)
n106=...-
n107=...What is this?: explain Extra information can be added by services operators that will show up on the /NICKSERV INFO command $next Only services operators can see this information who have the right operserv privileges
n108=..-
n109=..Services Kick: operserv kick # $$1 $$decision(egb¿incorrigo syx $pipe kill $$1 $+ ¿Enter kick reason / message:)
n110=..Set User Modes: operserv umode $$1 $$decision(egb¿incorrigo syx $pipe svsjoin¿Enter user mode to set on $$1 $next $chr(91) $+ you should use + / - $+ $chr(93))
n111=..Kill: operserv kill $$1 $$decision(egb¿incorrigo syx $pipe kill $$1 $+ ¿Why is $$1 $+ 's connection being closed?)
n112=$iif($wzy(#) != $null,$null,Give / Take Permissions)
n113=.$wdy(#) $+ Owner [~]
n114=..+ Owner: mode # +q $$1
n115=..- Owner: mode # -q $$1
n116=.$wdy(#) $+ Chan. Admin [&&]
n117=..+ Admin: mode # +a $$1
n118=..- Admin: mode # -a $$1
n119=.$wdy(#) $+ Chan. Operator [@]
n120=..+ Operator: mode # +o $$1
n121=..- Operator: mode # -o $$1
n122=.$wdy(#) $+ Half-Op $chr(91) $+ $eval(%,0) $+ $chr(93)
n123=..+ Half-Op: mode # +h $$1
n124=..- Half-Op: mode # -h $$1
n125=.Voice [+]
n126=..+ Voice: mode # +v $$1
n127=..- Voice: mode # -v $$1
n128=.-
n129=.$wdy(#) $+ Remove All Permissions: mode # -qaohv $$1 $1 $1 $1 $1
n130=.-
n131=.Permissions Explained: text-reader incorrigo-syx\docu-mental\statusmodes.tr Different Channel Permission Levels
n132=$iif($wzy(#) != $null,$null,Kick && Ban)
n133=.Quiet $$1: mode # +b ~q: $+ $address($$1, 2)
n134=.Unquiet $$1: mode # -b ~q: $+ $address($$1, 2)
n135=..-
n136=.Kick: kick # $$1 [unspecified]
n137=.Kick (why): kick # $$1 $$decision(vquge¿incorrigo syx $pipe kick $$1¿Enter kick reason:)
n138=.-
n139=.Ban: mode # +b $address($$1, 2)
n140=.Kick and Ban: {
n141=  .timer -m 1 500 kick # $$1 $$decision(vquge¿incorrigo syx $pipe kick $$1¿Why are you banning $$1 $+ ?)
n142=  .timer -m 1 1 mode # +b $address($$1,2)
n143=}
n144=.Temporary Ban: {
n145=  var %tban.duration $decision(vquge¿incorrigo syx $pipe temporary ban $$1¿How long $obk $+ minutes $+ $cbk do you wish to ban $$1 $+ ?)
n146=  var %tban.reason $$decision(vquge¿incorrigo syx $pipe kick $$1¿Why are you temporarily banning $$1 $+ ?)
n147=  .timer -m 1 500 kick # $$1 %tban.reason
n148=  .timer -m 1 1 mode # +b ~t: $+ %tban.duration $+ : $+ $address($$1,2)
n149=}
n150=.Unban: mode # -b $address($$1, 2)
n151=.-
n152=.Except Hostname: mode # +e $address($$1, 2)
n153=.Remove Exception: mode # -e $address($$1, 2)
n154=$iif($sysop,Kill && Network Ban Menu,$null)
n155=.Kill $$1: kill $$1 $$decision(tegb¿incorrigo syx $pipe kill $$1 $+ ¿Why are you banning $$1 $+ ?)
n156=.-
n157=.Set G Line
n158=..Temporary: {
n159=  var %gline.td $$decision(tegb¿incorrigo syx $pipe set g-line¿Enter duration parameter:)
n160=  var %gline.rs $$decision(tegb¿incorrigo syx $pipe set g-line¿Why are you banning $$1 $+ ?)
n161=  gline $$1 %gline.td banned: %gline.rs
n162=}
n163=..Permanent: {
n164=  var %gline.rs $$decision(tegb¿incorrigo syx $pipe set g-line¿Why are you banning $$1 $+ ?)
n165=  gline $$1 0 banned: %gline.rs
n166=}
n167=..-
n168=..Remove G Line: gline - $+ $$1
n169=.Set Z Line
n170=..Temporary: {
n171=  var %gzline.td $$decision(tegb¿incorrigo syx $pipe set g-zline¿Enter duration parameter:)
n172=  var %gzline.rs $$decision(tegb¿incorrigo syx $pipe set g-zline¿Why are you banning $$1 $+ ? $next [reason will not be shown on (re)connect attempt])
n173=  gzline $$1 %gzline.td banned: %gzline.rs
n174=}
n175=..Permanent: {
n176=  var %gzline.rs $$decision(tegb¿incorrigo syx $pipe set g-zline¿Why are you banning $$1 $+ ? $next [reason will not be shown on (re)connect attempt])
n177=  gzline $$1 0 banned: %gzline.rs
n178=}
n179=..-
n180=..Remove Global Z-Line: gzline - $+ $$1
n181=.Create Exception
n182=..Temporary: {
n183=  var %eline.td $$decision(tegb¿incorrigo syx $pipe set g-line¿How long should this exception remain in place?)
n184=  var %eline.rs $$decision(tegb¿incorrigo syx $pipe set g-line¿What reason is  $$1 $+ ?)
n185=  eline $$1 kGzZs %eline.td exception: %eline.rs
n186=}
n187=..Permanent: {
n188=  var %eline.rs $$decision(tegb¿incorrigo syx $pipe set exception¿Enter exception remarks for $$1 $+ ?)
n189=  eline $$1 kGzZs 0 exception: %eline.rs
n190=}
n191=..-
n192=..Extended Exceptions
n193=...Add User Account: eline ~a: $+ $$1 kGs 0 exception: account is exempt from network bans
n194=...Del User Acount: eline -~a: $+ $$1
n195=..-
n196=..Remove Exceptions: eline - $+ $$1
n197=.-
n198=.Important Information: text-reader incorrigo-syx\docu-mental\x-lines.tr Network Engineer's Notes About Kill and X-Lines
n199=$iif($wzy(#) != $null,$null,Extended Ban / Except)
n200=.Target $chr(91) $+ $extc.mode($$1) $+ $chr(93) Toggle: extc.toggle
n201=.-
n202=.Extended Ban
n203=..Quiet User: extc.setquiet # $$1
n204=..Forward to Channel: extc.forwardtochannel # $$1
n205=..No Nick Change: extc.setnonick # $$1
n206=..Block /join: extc.setnojoin # $$1
n207=..-
n208=..Remove Extended Bans: extc.unban # $$1
n209=.Extended Exemptions
n210=..Moderated Mode: extc.exempt.m # $$1
n211=..External Messages: extc.exempt.n # $$1
n212=..Colour && Control Codes: extc.exempt.c # $$1
n213=..Channel Notices: extc.exempt.p # $$1
n214=..-
n215=..Remove Exemptions: extc.dexempt # $$1
n216=.Target Types: noop $$decision(iuog¿incorrigo syx $pipe toggle ban target¿There are two different types of ban target ... $+ $crlf ~account: $+ $$1 $+ $crlf ... or $address($$1, 2) $next One targets the account of $$1 ... which is only useful if the user is logged into an account. $crlf $crlf $+ The other targets their address, which will apply no matter what $+ $c but need to be banned again when their IP / host address changes)
n217=-
n218=$iif(!$idf,$null,Access List)
n219=.Don't Kick on Join: access # add $$1 nokick
n220=.Add Voice [+]: access # add $$1 autovoice
n221=.Add Half-Op [%]: access # add $$1 halfopme
n222=.Add Operator [@]: access # add $$1 autoop
n223=.Add Channel Admin [&&]: access # add $$1 autoprotect
n224=.Add Owner [~]: access # add $$1 autoowner
n225=.Maximum Level: access # add $$1 10000
n226=.-
n227=.Remove $$1 From Access List: access # del $$1
n228=$iif(!$idf,$null,Chanserv Controls)
n229=.Channel Permissions
n230=..UP: chanserv up # $$1
n231=..DOWN: chanserv down # $$1
n232=..-
n233=..OWNER:
n234=...Make Owner: chanserv owner # $$1
n235=...Take Owner: chanserv deowner # $$1
n236=..PROTECT
n237=...Channel Admin: chanserv protect # $$1
n238=...Remove Admin: chanserv deprotect # $$1
n239=..OP
n240=...Channel Operator: chanserv op # $$1
n241=...Remove Ops: chanserv deop # $$1
n242=..HALFOP
n243=...Half-Op: chanserv halfop # $$1
n244=...De-Half Op: chanserv dehalfop # $$1
n245=..VOICE
n246=...Voice: chanserv voice # $$1
n247=...Devoice: chanserv devoice # $$1
n248=.Kick && Ban
n249=..Permanent Ban: chanserv ban # +0 $$1 $$decision(qeg¿incorrigo syx $pipe services ban¿Why are you permanently banning $$1 $+ ?)
n250=..Temporary Ban: chanserv ban # + $+ $$decision(egq¿incorrigo syx $pipe services ban¿How long are you banning $$1 $+ ? $next e.g. 20m / 12h / 3d etc:) $$1 $$decision(egq¿incorrigo syx $pipe services ban¿Why are you banning $$1 ?)
n251=..-
n252=..Remove All Matching Bans: chanserv unban # $$1
n253=.AKick $$1
n254=..AKick $$1: {
n255=  set -e %akick.reason $$decision(qegb¿incorrigo syx $pipe auto-kick¿Enter reason for a-kick:)
n256=  chanserv akick # add $$1
n257=}
n258=..Delete AKick for $$1: chanserv akick # del $$1
n259=.About Services Control: noop $decision(iog¿incorrigo syx $pipe chanserv user controls¿You can control a user that's on your channel if you're logged into an account with access $next You do not have to be a channel operator to use your chanserv powers)
