[cpopup]
n0=$wwy(#) $+ Channel Settings - # $+ : ls
n1=-
n2=$pnln Join / Leave / Invite
n3=.$iif($wwy(#), $+ $pnln Return to This Channel,Hop [Leave / Rejoin]): $iif($wwk(#), hop, join #)
n4=.$wwy(#) $+ Invite Someone Here: invite $$quik.d(doubled,incorrigo syx $pipe send invitation¿Enter nickname to invite to # $+ :) #
n5=.$iif($wwy(#) == $style(2),Close This Window,Leave This Channel): {
n6=  if ($wwy(#) == $style(2)) { part # | halt }
n7=  %part.o = $decision(gvbn¿incorrigo syx $pipe leave # $+ ¿Do you want to leave a parting message while you leave?)
n8=  if (%part.o == $yes) { part # $decision(qeg¿incorrigo syx $pipe leave # $+ ¿Enter parting message for # $+ :) }
n9=  if (%part.o == $no) { part # } 
n10=  else { halt }
n11=}
n12=.Join Another Channel: join $$decision(eg¿incorrigo syx $pipe join channel¿Enter channel name: $next [if you type another word - it will be used as a password])
n13=.-
n14=.Find Other Channels: {
n15=  var %criterion $$decision(yvg¿incorrigo syx $pipe find channels¿Do you wish to enter a keyword?)
n16=  if (%criterion == $yes) {
n17=    var %criterioin $decision(geq¿incorrigo syx $pipe channel list search¿Enter keyword(s) to refine your channel list:)
n18=  }
n19=  list %criterioin
n20=}
n21=$pnln $wwy(#) $+ Channel Notice
n22=.Send Message: notice # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter channel notice message:)
n23=.-
n24=.$wzy(#) $+ Voice: notice + $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: voice +up])
n25=.$wzy(#) $+ Half Op: notice $percenti $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: half-op +up])
n26=.$wdy(#) $+ Channel Operator: notice @ $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: ch. operator +up])
n27=.$wdy(#) $+ Channel Admin: notice $ampersand $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: ch. admin +up])
n28=.$wdy(#) $+ Owner: notice ~ $+ # $$decision(ge¿incorrigo syx $pipe channel notice¿Enter notice message:    [level: owner])
n29=$pnln Away Manager: awaymgr
n30=$pnln Change Your Nickname: nick $$decision(qebg¿incorrigo syx $pipe change nickname¿Enter new nickname:)
n31=-
n32=Send Local Time: msg # local time: $gettime
n33=Direct Channel URL
n34=.$chr(91) $+ ircs $+ $chr(58) $+ //irc.incorrigo.io/ $+ $right($chan,-1) $+ $chr(93): msg # IRCS Link: ircs://irc.incorrigo.io/ $+ $right($chan, -1)
n35=.$chr(91) $+ https  $+ $chr(58) $+ //incorrigo.io/irc?ch= $+ $right($chan,-1) $+ $chr(93): msg # Social Media Safe Link: https://incorrigo.io/irc?ch= $+ $right($chan, -1)
n36=.$chr(91) $+ https  $+ $chr(58) $+ //incorrigo.io/web?ch= $+ $right($chan,-1) $+ $chr(93): msg # Browser Client Link: https://incorrigo.io/web?ch= $+ $right($chan, -1)
n37=$iif($nln && $me ison #,Channel History Playback,$nul)): history # $$decision(qeg¿incorrigo syx $pipe history playback¿How many lines to play back?)
n38=$iif($nln && $me ison #,Reply to a Message,$nul)): r #
n39=-
n40=Ban / Except / Invite Lists
n41=.$iif($wzy(#) == $$style(2),$null,Ban List)
n42=..Add Ban: mode # +b $$quik.d(doubled, incorrigo syx $pipe ban entry¿Enter user/mask to add to ban list: $next nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n43=..Remove Ban: mode # -b $$quik.d(doubled, incorrigo syx $pipe ban entry¿Enter user/mask to add to ban list: $next nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n44=..-
n45=..Clear All Bans: clear.bans #
n46=..-
n47=..About Ban List: noop $decision(ugo¿incorrigo syx $pipe channel ban list¿You can add an entry onto the ban list using mode +b $next When you match something on the ban list $+ $c you will not be allowed to join the channel $next If you are already on the channel it doesn't remove you $+ $c but some restrictions will be placed until you are either kicked / leave of your own accord)
n48=.$iif($wzy(#) == $style(2),$null,Invite List)
n49=..Add Invite: mode # +I $$quik.d(doubled, incorrigo syx $pipe invite entry¿Enter user/mask to add to invite list: $next nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n50=..Remove Invite: mode # -I $$quik.d(doubled, incorrigo syx $pipe invite entry¿Enter user/mask to remove from invite list: $next nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n51=..-
n52=..Clear All Invites: clear.invites #
n53=..-
n54=..About Invite List: explain An entry on the channel's invite list is added using mode +I $next The invite list allows people to join without being manually invited $+ $c when the channel is invite only [+i] $next Being on the invite list does not let you in if you are banned $+ $c but strangely the /invite command does
n55=.$iif($wzy(#) == $style(2),$null,Exception List)
n56=..Add Exception: mode # +e $$quik.d(doubled, incorrigo syx $pipe exception entry¿Enter user/mask to add to exception list: $next nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n57=..Remove Exception: mode # -e $$quik.d(doubled, incorrigo syx $pipe exception entry¿Enter user/mask to remove from exception list: $next nick!user@host.name.or.ip $crlf $+ ~account:regdnickname)
n58=..-
n59=..Clear All Exceptions: clear.exceptions #
n60=..-
n61=..About Exceptions: explain If someone matches an exception $+ $c it will override any bans that they also may match. This does nothing if the channel is invite only.
n62=.-
n63=.$wwy(#) $+ View Ban List: mode # +b
n64=.$wwy(#) $+ View Invite List: mode # +I
n65=.$wwy(#) $+ View Exception List: mode # +e
n66=.-
n67=.Help About Channel Lists: text-reader incorrigo-syx\docu-mental\list-modes.tr Ban, Except, Invite lists
n68=$iif($wzy(#) != $null,$null,Extended Ban Creator): extbanner #
n69=$iif($sysop,Network Engineer Menu,$null)
n70=.Operator Chat
n71=..Global Ops: globops $$decision(egt¿incorrigo syx $pipe /globops message¿Enter Global Message:)
n72=..Local Ops: locops $$decision(egt¿incorrigo syx $pipe /locops message¿Enter Server Ops Message:)
n73=..-
n74=..Services GLOBAL: global global $$decision(egt¿incorrigo syx $pipe services announcement¿Enter global announcement:)
n75=..-
n76=.. $+ $server Announce: msg $chr(36) $+ $server $$decision(egt¿incorrigo syx $pipe server announcement¿Enter Message for Server - All Users:)
n77=..Entire Network Announce: msg $chr(36) $+ * $$decision(egt¿incorrigo syx $pipe entire network - calling all users¿Enter Message for Network - All Users:)
n78=..-
n79=.. $+ $server Notice All: notice $chr(36) $+ $server $$decision(egt¿incorrigo syx $pipe server - all users¿Enter Message for Server - All Users:)
n80=..Notice All Network: notice $chr(36) $+ * $$decision(egt¿incorrigo syx $pipe network - all users¿Enter Message for Network - All Users:)
n81=..-
n82=..Wallops Message: wallops $$decision(egt¿incorrigo syx $pipe wallops message¿Enter message to send over wallops: $next [ordinary users can use mode +w])
n83=.-
n84=.Override Modes
n85=..Channel Owner: mode # +q $me
n86=..Channel Admin: mode # +a $me
n87=..Channel Operator: mode # +o $me
n88=..Half Operator: mode # +h $me
n89=..Voice: mode # +v $me
n90=..Set Channel Modes: mode # $$decision(eg¿incorrigo syx $pipe channel mode change¿Enter channel mode change: $next [you can +set and -unset modes])
n91=.Operserv FORBID
n92=..Add Nickname: os forbid add nick + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿How long to forbid?) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter nickname to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter nickname forbidden message:)
n93=..Add Channel: os forbid add chan + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿How long to forbid?) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter channel to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter channel forbidden message:)
n94=..Add Email: os forbid add email + $+ $$decision(etgb¿incorrigo syx $pipe foreboding¿How long to forbid?) $$decision(etgb¿incorrigo syx $pipe foreboding¿Enter email address to forbid. Wildcards are accepted:) $$decision(etgb¿incorrigo syx $pipe foreboding¿Why is this email address being forbidden?)
n95=..-
n96=..Delete Nickname: os forbid del nick $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n97=..Delete Channel: os forbid del chan $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n98=..Delete Email: os forbid del email $$decision(etgb¿incorrigo syx $pipe foreboding¿Which entry to unforbid?)
n99=.-
n100=..List Nicknames: os forbid list nick
n101=..List Channels: os forbid list chan
n102=..List Emails: os forbid list email
n103=.Services Operator
n104=..Services IGNORE
n105=...Add Nick / Mask: {
n106=  var %os.ignore.dur = $$decision(eg¿incorrigo syx $pipe services ignore¿Enter duration of services ignore:)
n107=  var %pervert = $decision(egb¿incorrigo syx $pipe services ignore¿Enter nick or mask: $next [Mask: nick!user@ho.st.na.me])
n108=  os ignore add %os.ignore.dur %pervert $$decision(eg¿incorrigo syx $pipe services ignore¿Why are you adding a services ignore agsint %pervert $+ ?)
n109=}
n110=...Delete Nick / Mask: {
n111=  os ignore del $$decision(eg¿incorrigo syx $pipe services ignore¿Enter nick or mask: $next [Mask: nick!user@ho.st.na.me])
n112=}
n113=...-
n114=...View Services Ignore List: os ignore list
n115=...What is this list?: {
n116=  noop $$decision(iog¿incorrigo syx $pipe services ignore list¿The services ignore list contains nicknames or masks of people who are not permitted to interact with network services $next If you match an entry on this list services will completely ignore you and you will not be able to use them)
n117=}
n118=...-
n119=...Clear Services Ignore List: {
n120=  var %clear.signore = $$decision(wyvgb¿incorrigo syx $pipe clear ignore list¿This will clear the entire services ignore list $next Do you wish to proceed?)
n121=  if (%clear.signore == $yes) {
n122=    os ignore clear
n123=  }
n124=}
n125=..Services N-Line List
n126=...Add N-Line: {
n127=  os snline add + $+ $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter n-line duration:) $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter name mask:) $+ : $+ $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter n-line reason:)
n128=}
n129=...Remove N-Line: {
n130=  os snline del $$decision(qeg¿incorrigo syx $pipe delete n-line¿Enter N-Line list number or mask:)
n131=}
n132=...-
n133=...View Services N-Line List: os snline view
n134=...What is this list?: {
n135=  noop $decision(iog¿incorrigo syx $pipe services n-line list¿The services N-Line list is for banning a certain "Real Names" $obk $+ or gecos $+ $cbk from being used $next Setting or trying to connect with a banned name will automatically close your connection until you change it to a different one)
n136=}
n137=...-
n138=...Clear N-Line List: {
n139=  var %pervert $$decision(wyvgb¿incorrigo syx $pipe clear n-line list¿This will clear the services n-line list $next Are you sure?)
n140=  if (%pervert == $yes) {
n141=    os snline clear
n142=  }
n143=}
n144=..Services Q-Line List
n145=...Add Q-Line: {
n146=  os sqline add + $+ $$decision(qeg¿incorrigo syx $pipe add Q-line¿Enter Q-line duration:) $$decision(qeg¿incorrigo syx $pipe add Q-line¿Enter nick/channel mask to ban:) $$decision(qeg¿incorrigo syx $pipe add n-line¿Enter nick/chan refused message:)
n147=}
n148=...Delete Q-Line: os sqline del $$decision(qeg¿incorrigo syx $pipe delete Q-line¿Enter N-Line list number or mask:)
n149=...-
n150=...View Services Q-Line List: os sqline view
n151=...What is this list?: {
n152=  explain A Q-line is a nickname or channel that is prohibited $next If the entry starts with a $rhash then operserv will treat it as a channel name $next If a user tries to use a nick / channel that matches an entry on this list $+ $c your reason will be given in the form of an error message
n153=}
n154=...-
n155=...Clear Q-Line List: {
n156=  var %pervert $$decision(wyvgb¿incorrigo syx $pipe clear Q-line list¿This will clear the services Q-line list $next Are you sure?)
n157=  if (%pervert == $yes) {
n158=    os sqline clear
n159=  }
n160=}
n161=..Operator KICK: os kick $$decision(eg¿incorrigo syx $pipe services kick¿Enter channel name:) $$decision(eg¿incorrigo syx $pipe services kick¿Enter nickname:)
n162=..Operserv KILL: os kill $$decision(qeg¿incorrigo syx $pipe services kill¿Enter user to kill:) $$decision(qeg¿incorrigo syx $pipe services kill¿Why are you disconnecting this person?)
n163=.-
n164=.Server Admin Commands
n165=..Force Join a Channel: SAJOIN $me $$decision(gte¿incorrigo syx $pipe force join¿Which channel to join?)
n166=..-
n167=.. $+ $iif($wwk(#) == $true,SAJOIN Someone Here,SAJOIN Yourself Inside): $iif($wwk(#) == $true,SAJOIN $$decision(etg¿incorrigo syx $pipe sajoin user¿Enter nickname to bring here:) #,sajoin $me #)
n168=..SAPART Someone From Here: sapart $$decision(etg¿incorrigo syx $pipe force part¿Enter person to leave channel:) #
n169=..SAMODE Set Channel Mode: samode # $$decision(etg¿incorrigo syx $pipe server mode change¿Enter mode change for channel: $next [Mode change will be done by server])
n170=..-
n171=..Server Admin Commands Explained: text-reader incorrigo-syx\docu-mental\sa-cmds.tr S.A. Commands Explained
n172=.Server Only Commands
n173=..Svsjoin Yourself to a Channel: operserv svsjoin $me $$decision(gte¿incorrigo syx $pipe svsjoin a channel¿Which channel to join?)
n174=..Svsjoin Someone Here: operserv svsjoin $$decision(gte¿incorrigo syx $pipe svsjoin user¿Enter nickname to svsjoin here:) #
n175=..Svsnick A User: operserv svsnick $$decision(gte¿incorrigo syx $pipe force nickname change¿Enter nickname to change:) $$decision(gte¿incorrigo syx $pipe force nickname change¿Enter new nickname:)
n176=..Svspart Someone From #: operserv svspart $$decision(gte¿incorrigo syx $pipe svspart douche¿Enter user to SVSPART from here:) #
n177=.$iif($aopper.rmenu(on),$style(1) $+,$null $+) Self-AOP
n178=..$iif($aopper.rmenu(self),$style(1) $+,$null $+) Oper-Override (self): aopper.set self
n179=..$iif($aopper.rmenu(csvc),$style(1) $+,$null $+) Chanserv: {
n180=  if ($decision(tygv¿incorrigo syx $pipe chanserv self-aop¿This setting will only work on registered channels. Proceed?) == $yes) {
n181=    aopper.set csvc
n182=  }
n183=}
n184=..$iif($aopper.rmenu(scmd),$style(1) $+,$null $+) Samode Command: aopper.set scmd
n185=..$iif($aopper.rmenu(svcs),$style(1) $+,$null $+) Operserv Mode: aopper.set svcs
n186=..-
n187=..$iif($aopper.rmenu(off),$style(1) $+,$null $+) Switch Off: aopper.set off
n188=..-
n189=..What is Self-AOP?: aopper.details
n190=$iif($wzy(#) != $null,$null,Change Topic): topic # $$decision(qeg¿incorrigo syx $pipe set new topic¿Enter new channel topic:)
n191=$iif($wzy(#) != $null,$null,Set Channel Modes)
n192=.Understanding Channel Settings: text-reader incorrigo-syx\docu-mental\channel-modes.tr Understanding Channel Settings and How They Work
n193=.-
n194=.Manual Mode Entry: mode # $$decision(egb¿incorrigo syx $pipe mode change¿Enter mode change parameters:)
n195=.-
n196=.$wdy(#) $+ Block Colour Codes [c]
n197=..+c: mode # +c
n198=..-c: mode # -c
n199=.$wzy(#) $+ No Channel CTCP Messages [C]
n200=..+C: mode # +C
n201=..-C: mode # -C
n202=..-
n203=..What is this?: { explain CTCP requests are for client responses i.e. what client [& version], local time, etc. $next Sending it to the channel gets a response from everyone all at once $next Setting this mode will stop people from doing this to the whole channel }
n204=.$wdy(#) $+ Lurker Mode [D]
n205=..+D: mode # +D
n206=..-D: mode # -D
n207=..-
n208=..What is this?: explain Delayed Join [+D] will hide someone from ordinary users until they send a first message or become a channel operator. It looks like they joined at the same time $next When opped, it looks like they all joined. When de-opped, it looks like they all left if they haven't said anything yet $+ $crlf $+ $crlf $+ It will allow you to lurk if you don't say anything
n209=.$wdy(#) $+ Flood Protection Profile [F]
n210=..+F <profile>: mode # +F $$decision(egb¿incorrigo syx $pipe input request¿Enter server flood protect profile name:)
n211=..-F: mode # -F
n212=.$wdy(#) $+ Flood Protection Control [f]
n213=..+f <exact controls>: mode # +f $$decision(egb¿incorrigo syx $pipe input request¿Enter specific flood protection settings:)
n214=..-f: mode # -f
n215=.$wdy(#) $+ Profanity Censor [G]
n216=..+G: mode # +G
n217=..-G: mode # -G
n218=..-
n219=..What is this?: explain Setting this mode [+G] will block / censor various bad words and profanity from channel messages
n220=.$wdy(#) $+ Channel History [H]
n221=..+H: mode # +H $$decision(egb¿incorrigo syx $pipe input request¿Chat history playback parameter is of the format lines:time $next Example - 750:5d is max 750 lines within a time frame of five days $next Enter chat history parameter:)
n222=..-H: mode # -H
n223=.$wzy(#) $+ Invite Only [i]
n224=..+i: mode # +i
n225=..-i: mode # -i
n226=..-
n227=..More Information: explain This setting will make # invite only. Only people who are invited may join $next - You can let someone in as a one-off using the /INVITE command $crlf $+ - Any number of people can come if they are on the channel's invite list
n228=.$wdy(#) $+ Calm Down Kick [j]
n229=..+j: mode # +j $$decision(egb¿incorrigo syx $pipe input request¿How many seconds of delay when kicked? $next [a number from 1-20])
n230=..-j: mode # -j
n231=..-
n232=..What is this?: explain Kick-Join Delay [+j 1-20] stops someone from re-joining the channel until 1-20 seconds have passed since they have been kicked
n233=.$wzy(#) $+ Channel Password [k]
n234=..+k <password>: mode # +k $$quik.d(pdoubled,incorrigo syx $eval($chr(124), 0) set channel key¿Enter channel key: $next NB: Everyone inside the channel will be able to see the channel key!)
n235=..-k: mode # -k
n236=.$wzy(#) $+ Disable /KNOCK [K]
n237=..+K: mode # +K
n238=..-K: mode # -K
n239=...-
n240=...What is this?: explain If someone has an invite only channel $+ $c and they don't really care, then no one on will be able to /KNOCK on your channel $next When someone knocks on a channel it asks channel operators for an invitation. Mode +K will remove this function from the channel
n241=.$wdy(#) $+ Link Channel [L]
n242=..+L <channel>: mode # +L $$decision(egb¿incorrigo syx $pipe input request¿Enter channel name to send people who fail to join to:)
n243=..-L: mode # -L
n244=..-
n245=..What is this?: explain A linked channel [+L #channelname] is the channel someone is redirected to if they fail to join your channel [e.g. if the channel is full, or they have the wrong password etc.]
n246=.$wzy(#) $+ Limit Number of Users [l]
n247=..+l <max users>: mode # +l $$decision(qeg¿incorrigo syx $pipe chnnel limit¿Enter maximum number of users:)
n248=..-l: mode # -l
n249=.$wzy(#) $+ Moderated [m]
n250=..+m: mode # +m
n251=..-m: mode # -m
n252=..-
n253=..What is this?: explain Moderated [+m] means that users need to be specifically given voice [+v] to send any message in the channel
n254=.$wzy(#) $+ Moderate Unregistered [M]
n255=..+M: mode # +M
n256=..-M: mode # -M
n257=..-
n258=..What is this?: explain Moderated Unregistered [+M] users that are unregistered / not logged into an account will need to be given voice [+v] to speak
n259=.$wdy(#) $+ No Nickname Changes [N]
n260=..+N: mode # +N
n261=..-N: mode # -N
n262=.$wzy(#) $+ No External Messages [n]
n263=..+n: mode # +n
n264=..-n: mode # -n
n265=.$iif($sysop,Systems Operator Lockout [O],$null)
n266=..+O: mode # +O
n267=..-O: mode # -O
n268=..-
n269=..What is this?: explain When this mode is in effect, only an IRC Operator is able to join the channel $next Not all operators have permission to set / unset this mode. There is a separate permission specifically to allow access to a +O channel
n270=.$wdy(#) $+ Channel is Permanent [P]
n271=..+P: mode # +P
n272=..-P: mode # -P
n273=..-
n274=..What is this?: explain Permanent channels [+P] are not destroyed when everyone leaves, even in the search results of /LIST
n275=.$wzy(#) $+ Channel is Private [p]
n276=..+p: mode # +p
n277=..-p: mode # -p
n278=..-
n279=..What is this?: explain Private [+p] channels will not appear in /LIST searches. It will also be hidden from another user's /WHOIS information. Unless you are currently on that channel yourself
n280=.$wdy(#) $+ Disable /KICK [Q]
n281=..+Q: mode # +Q
n282=..-Q: mode # -Q
n283=..-
n284=..What is This?: explain Channel mode Q disables the kick command from being used. Normal users will be unable to kick others out of the channel, for any reason, at any permission level $next This mode is normally used to make kicks only possible by people with chanserv access using the KICK command $next Services bots and network operators are still able to kick users with /KICK, whether or not they have channel operator permissions
n285=.$wzy(#) $+ Registered Users Only [R]
n286=..+R: mode # +R
n287=..-R: mode # -R
n288=. $+ $style(2) $+ Channel is Registered [r]
n289=..+r: mode # +r
n290=..-r: mode # -r
n291=.$wzy(#) $+ Channel is Secret [s]
n292=..+s: mode # +s
n293=..-s: mode # -s
n294=..-
n295=..What is this?: explain Secret [+s] channels are the same as private [p] but the server will act like the channel doesn't exist in searches like /TOPIC /NAMES /LIST etc ...
n296=.$wdy(#) $+ Strip Colour Codes [S]
n297=..+S: mode # +S
n298=..-S: mode # -S
n299=.$wdy(#) $+ No Channel Notices [T]
n300=..+T: mode # +T
n301=..-T: mode # -T
n302=.$wzy(#) $+ Only Ops Set Topic [t]
n303=..+t: mode # +t
n304=..-t: mode # -t
n305=.$wdy(#) $+ Disable /INVITE [V]
n306=..+V: mode # +V
n307=..-V: mode # -V
n308=.$wdy(#) $+ Secure Connections Only [z]
n309=..+z: mode # +z
n310=..-z: mode # -z
n311=..-
n312=..What is this?: explain Secure only channel mode [+z] will only let users with secure [TLS] connections enter the channel $next Incorrigo Syx uses Strict Transport Security (STS) which will not let mIRC connect if a secure connection cannot be made $+ $c and you would have to go out of your way to do so otherwise $next If # is +z that someone would not be allowed to join because their connection to the network is not secure $crlf $crlf $+ All web and mIRC connections are secure
n313=-
n314=Chanserv Info: chanserv info #
n315=$iif($idf,Open Chanserv Query,$null): query chanserv help
n316=$iif(!$idf,$null,Chanserv Menu)
n317=.$wdy(#) $+ $iif($wdy(#) == $style(2),Registration [Requires Channel Operator],Register / Drop #)
n318=..REGISTER This Channel: chanserv register # $$decision(ebg¿incorrigo syx $pipe channel register description¿Please enter a description for the channel services register:)
n319=..DROP [Unregister] This Channel: $iif($$decision(vgby¿incorrigo syx $pipe unregister channel¿This will permanently delete the channel and all settings from the network services register. Do you wish to continue?) == $yes, chanserv drop # #,noop $$decision(iugob¿incorrigo syx $pipe registered channel¿Channel # was not deleted))
n320=.-
n321=.Permissions
n322=..UP: chanserv up #
n323=..DOWN: chanserv down #
n324=..-
n325=..Owner [~]
n326=...[+q]: chanserv owner #
n327=...[-q]: chanserv deowner #
n328=..Channel Admin [&&]
n329=...[+a]: chanserv protect #
n330=...[-a]: chanserv deprotect #
n331=..Channel Operator [@]
n332=...[+o]: chanserv op #
n333=...[-o]: chanserv deop #
n334=..Half-Operator [%]
n335=...[+h]: chanserv halfop #
n336=...[-h]: chanserv dehalfop #
n337=..Voice [+]
n338=...[+v]: chanserv voice #
n339=...[-v]: chanserv devoice #
n340=..-
n341=..About Registered Channel Status Modes: text-reader incorrigo-syx\docu-mental\chanserv-modes.tr Status Modes w/Chanserv Commands
n342=.Set Channel Options
n343=..Auto Op
n344=...ON: cs set autoop # on
n345=...OFF: cs set autoop # off
n346=...-
n347=...What is this?: explain When someone joins who is on the channel's /ACCESS list, they will automatically be made channel operator - or whatever status they are given by the access list
n348=..Ban Type
n349=...0 [*!user@host.or.ip]: cs set bantype # 0
n350=...1 [*!*user@host.or.ip]: cs set bantype # 1
n351=...2 [*!*@host.or.ip]: cs set bantype # 2
n352=...3 [*!*user@*.domain.ip]: cs set bantype # 3
n353=...-
n354=...What is this?: explain The BANTYPE setting tells chanserv the parts of someone's address to use when it is banning them for any reason $next If you have not changed this setting on a channel yet, the default setting is [2]
n355=..Channel Register Description: cs set description # $$decision(ebg¿incorrigo syx $pipe channel register description¿Enter new description for # $+ :)
n356=..Channel Email Address: cs set email # $$decision(ebg¿incorrigo syx $pipe channel email¿Enter an e-mail address to associate with # $+ :)
n357=..Keep Modes
n358=...ON: cs set keepmodes # on
n359=...OFF: cs set keepmodes # off
n360=...-
n361=...What is this?: explain KEEPMODES will remember the channel modes if it goes empty, and set them again when it is no longer empty
n362=..Keep / Lock Topic
n363=...Keep Topic ON: cs set keeptopic # on
n364=...Keep Topic OFF: cs set keeptopic # off
n365=...LOCK Topic: cs topic # lock
n366=...Remove LOCK: cs topic # unlock
n367=...-
n368=...What is this?: explain KEEPTOPIC will remember the topic if the channel goes empty, and set it again when it is no longer empty $next Topic LOCK will stop it from being changed by anyone that isn't on the channel's /ACCESS list
n369=..Peace
n370=...ON: cs set peace # on
n371=...OFF: cs set peace # off
n372=...-
n373=...What is this?: explain PEACE will prevent people from being kicked or de-opped by services, if they are on the access list
n374=..Private
n375=...ON: cs set private # on
n376=...OFF: cs set private # off
n377=...-
n378=...What is this?: explain When PRIVATE is set, # will not appear in any results of the chanserv LIST command
n379=..Restricted
n380=...ON: cs set restricted # on
n381=...OFF: cs set restricted # off
n382=...-
n383=...What is this?: explain RESTRICTED CHANNEL MODE $next In a restricted channel, everyone who joins must be on the /ACCESS list $next Even if they are only set as NOKICK and nothing else $next Anyone who is not on the access list will be automatically kicked and banned by services $next Anyone on the access list can use /CHANSERV UNBAN # to regain entry
n384=..Secure
n385=...ON: cs set secure # on
n386=...OFF: cs set secure # off
n387=...-
n388=...What is this?: explain SECURE will not give users with permissions on the /ACCESS list their status mode / chanserv commands until they have successfully logged into their account after / during connect
n389=..Secure Founder
n390=...ON: cs set securefounder # on
n391=...OFF: cs set securefounder # off
n392=...-
n393=...What is this?: explain SECUREFOUNDER will make sure only the REAL channel founder is allowed to DROP [unregister] the channel $+ $c change the channel founder and its successor $+ $c and not anyone with special permissions using QOP or are set to founder level on the # $+ 's /ACCESS list
n394=..Secure Ops
n395=...ON: cs set secureops # on
n396=...OFF: cs set secureops # off
n397=...-
n398=...What is this?: explain SECUREOPS will not allow someone to become a channel operator if they are not in the channel's /ACCESS list
n399=..Sign Kick
n400=...[Default Voice - 3]: chanserv levels # set SIGNKICK 3
n401=...[Default Half-Op - 4]: chanserv levels # set SIGNKICK 4
n402=...[Default Op - 5]: chanserv levels # set SIGNKICK 5
n403=...[Default Protect - 10]: chanserv levels # set SIGNKICK 10
n404=...[Default Owner - 9999]: chanserv levels # set SIGNKICK 9999
n405=...FOUNDER Only: chanserv levels # set SIGNKICK FOUNDER
n406=...-
n407=...Use Your Own Numeric: cs set signkick # $$decision(eg¿incorrigo syx $pipe signkick level¿Enter sign kick level: $next [must be a value between 1-10000])
n408=...-
n409=...ON [any level]: chanserv set signkick # on
n410=...OFF: chanserv set signkick # off
n411=...-
n412=...What is this?: explain SIGNKICK sets the user level in the channel's /ACCESS list where someone using the KICK command will have their name added to the KICK reason $next Anyone at an higher level than the SIGNKICK setting will NOT have their nickname added to the KICK reason used by chanserv
n413=..Successor
n414=...Set Channel Successor: cs set successor # $$decision(ebg¿incorrigo syx $pipe set channel successor¿Enter user account nickname of # successor:)
n415=...-
n416=...What is this?: explain The SUCCESSOR of a channel is the last hope of it surviving $+ $c if the channel's FOUNDER has their account dropped [unregistered], or if their account expires while the channel is still registered to them $next In either of these events $+ $c the successor will automatically become the channel founder and # will live on!
n417=..Channel URL: cs set url # $$decision(gbe¿incorrigo syx $pipe set url for # $+ ¿Enter URL to associate with # $+ :)
n418=.Channel Entry Message
n419=..Add Line: chanserv entrymsg # add $$decision(eubg¿incorrigo syx $pipe channel entry message¿Enter channel entry message to add:)
n420=..Remove Line: chanserv entrymsg # del $$decision(eubg¿incorrigo syx $pipe channel entry message¿Enter line number to remove:)
n421=..View All Lines: chanserv entrymsg # list
n422=..-
n423=..Clear All Entry Message: chanserv entrymsg # clear
n424=.$iif(!$sysop, $null, -)
n425=.$iif(!$sysop, $null, Operator Informaton #)
n426=..Add Operator Notes: operserv info add # $$decision(etgb¿incorrigo syx $pipe add oper info¿Enter operator info note:)
n427=..Delete Note: operserv info del # $$decision(etgb¿incorrigo syx $pipe add oper info¿Type / paste the entry you wish to remove:)
n428=..Clear Operator Notes: operserv info clear #
n429=..-
n430=..What is Operator Info?: noop $$decision(tgo¿incorrigo syx $pipe what this is¿When you use the chanserv INFO command $+ $c there is additional info only available to services operators $next You can use operserv INFO to add or remove lines of oper-only info about a nickname or channel)
n431=.$iif(!$sysop, $null, Suspend #)
n432=..Suspend This Channel: cs suspend # $$decision(teg¿incorrigo syx $pipe suspend channel¿How long should the channel be suspended? $+ $crlf $crlf [e.g. 28d for 28 days, 0 for indefinite]) $$decision(teg¿incorrigo syx $pipe suspend channel¿Enter channel suspended reason:)
n433=..Unsuspend Now: cs unsuspend #
n434=
n435=.Lock Modes on #
n436=..Add a Mode Lock: chanserv mode # lock add $$decision(qgbe¿incorrigo syx $pipe lock modes¿Enter mode [and any parameter] to lock:)
n437=..Remove a Mode Lock: chanserv mode # lock del $$decision(qgbe¿incorrigo syx $pipe lock modes¿Enter mode to unlock:)
n438=..Set Mode Lock: chanserv mode # lock set $$decision(qgbe¿incorrigo syx $pipe lock modes¿Enter mode lock to set: $next [these modes will replace ALL that are currently locked])
n439=..-
n440=..What is Mode Lock?: noop $$decision(igo¿incorrigo syx $pipe about mode lock¿When a mode is locked $+ $c nobody can unset / change it $+ $c even if they are a channel operator $next You must have chanserv permissions on # to lock or unlock modes $next Bans %+ $c invites $+ $c and exceptions can also be locked as well as regular modes $next Locked modes will persist if the channel goes empty / is created again)
n441=.$iif(!$idf,$null,Remove Access Restrictions)
n442=..Unban Yourself: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv unban %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n443=..Services Invite: { var %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker lock add +I ~a: $+ $me | chanserv invite %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker } }
n444=..-
n445=..Channel Key [+k]: { var %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv getkey %cserv.wanker }
n446=..Remove Key [-k]: { var %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -k wanker | if ($me !ison 5cserv.wanker) { .timer -m 1 250 join %cserv.wanker } }
n447=..-
n448=..Remove User Limit [+l]: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -l | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n449=..-
n450=..What is this?: explain '(Re)gain Channel Access' is for channel owner / operator who has ended up being unable to join their own channel $next Obviously this couldn't be used to regain access to just any channel $+ $c you would need permission from chanserv first $next If you are a network operator $+ $c then this will work whether you have permissions on the channel's access list or you don't
n451=.$iif(!$sysop, $null, Channel Kill): os chankill # + $+ $$decision(teg¿incorrigo syx $pipe channel a-kill¿How long should everyone's AKILL last? $next [e.g. 28d for 29 days, 0 for indefinite]) $$decision(teg¿incorrigo syx $pipe channel a-kill¿Enter reason message for everyone's a-kill:) $$decision(tgb¿incorrigo syx $pipe channel a-kill¿CAUTION: This will ban every user in # from the network. $next Do you wish to continue with channel a-kill?)
n452=$iif(!$idf,$null, Access List)
n453=.# Access List: access # list
n454=.-
n455=.Grant Access [No Kick]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $next [mask format: nick!user@host.name.or.ip]) nokick
n456=.Add Voice [+]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $next [mask format: nick!user@host.name.or.ip]) autovoice
n457=.Add Half-Op [%]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $next [mask format: nick!user@host.name.or.ip]) halfopme
n458=.Add Operator [@]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $next [mask format: nick!user@host.name.or.ip]) op
n459=.Add Channel Admin [&&]: access # add $$quik.d(doubled,incorrigo syx $pipe access list¿Enter nickname or mask for access entry: $next [mask format: nick!user@host.name.or.ip]) autoprotect
n460=.Add Owner [~]: {
n461=  var %plank = $$decision(eg¿incorrigo syx $pipe access list¿Enter account/nick name or mask for access entry: $next [mask format: nick!user@host.name.or.ip])
n462=  var %plimp = $decision(wyvbg¿incorrigo syx $pipe grant access¿You are about to give the following user/mask: $next %plank $next Channel owner status. Do you wish to proceed?)
n463=  if (%plimp == $yes) {
n464=    access # add %plank ownerme
n465=  }
n466=}
n467=.-
n468=.Remove Entry From Access List: access # del $$quik.d(doubled,incorrigo syx $pipe access list¿Enter [registered] nickname or mask to remove from access list: $next [mask format: nick!user@host.name.or.ip])
n469=.Numeric Access Entry: access # add $$quik.d(doubled,incorrigo syx $pipe access numeric¿Enter [registered] nickname or mask to add access entry: $next [mask format: nick!user@host.name.or.ip]) $$decision(eg¿incorrigo syx $pipe level numeric¿Enter an access level between [1 - 10000])
n470=.-
n471=.Change Access Levels
n472=..About Access Levels: chanserv help levels desc
n473=..-
n474=..LEVELS Reset: if ($$decision(wgb¿incorrigo syx $pipe levels reset¿This will completely reset all levels. Proceed?)) { chanserv levels # reset }
n475=..Disable a Level: chanserv levels # disable $$decision(eg¿incorrigo syx $pipe levels disable¿Enter access type to be disabled: $next [Find out level's name by looking up the levels list]))
n476=..Set a Level to Founder Only: chanserv levels # set founder $$decision(eg¿incorrigo syx $pipe founder level¿Enter level to become founder only: $next [Find out what a level is called by looking at the list])
n477=..View # Levels: chanserv levels # list
n478=..-
n479=..ACCESS_CHANGE: chanserv levels # set ACCESS_CHANGE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for ACCESS_CHANGE: $next [Between 1 and 10000])
n480=..ACCESS LIST: chanserv levels # set ACCESS_LIST $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for ACCESS_LIST: $next [Between 1 and 10000])
n481=..NOKICK (for Restricted Channel): chanserv levels # set NOKICK $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for NOKICK: $next [Between 1 and 10000])
n482=..!FANTASIA (Bot): chanserv levels # set FANTASIA $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for FANTASIA: $next [Between 1 and 10000])
n483=..GREET: chanserv levels # set GREET $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for GREET: $next [Between 1 and 10000])
n484=..AUTOVOICE: chanserv levels # set AUTOVOICE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOVOICE: $next [Between 1 and 10000])
n485=..VOICEME: chanserv levels # set VOICEME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for VOICEME: $next [Between 1 and 10000])
n486=..VOICE: chanserv levels # set VOICE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for VOICE: $next [Between 1 and 10000])
n487=..INFO: chanserv levels # set INFO $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for INFO: $next [Between 1 and 10000])
n488=..SAY (Channel Bot): chanserv levels # set SAY $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for SAY: $next [Between 1 and 10000])
n489=..AUTOHALFOP: chanserv levels # set AUTOHALFOP $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOHALFOP: $next [Between 1 and 10000])
n490=..HALFOPME: chanserv levels # set HALFOPME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for HALFOPME: $next [Between 1 and 10000])
n491=..HALFOP: chanserv levels # set HALFOP $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for HALFOP: $next [Between 1 and 10000])
n492=..KICK: chanserv levels # set KICK $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for KICK: $next [Between 1 and 10000])
n493=..SIGNKICK: chanserv levels # set SIGNKICK $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for SIGNKICK: $next [Between 1 and 10000])
n494=..BAN: chanserv levels # set BAN $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for BAN: $next [Between 1 and 10000])
n495=..TOPIC: chanserv levels # set TOPIC $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for TOPIC: $next [Between 1 and 10000])
n496=..MODE: chanserv levels # set MODE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for MODE: $next [Between 1 and 10000])
n497=..GETKEY: chanserv levels # set GETKEY $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for GETKEY: $next [Between 1 and 10000])
n498=..INVITE: chanserv levels # set INVITE $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for INVITE: $next [Between 1 and 10000])
n499=..UNBAN: chanserv levels # set UNBAN $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for UNBAN: $next [Between 1 and 10000])
n500=..AUTOOP: chanserv levels # set AUTOOP $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOOP: $next [Between 1 and 10000])
n501=..OPME: chanserv levels # set OPME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for OPME: $next [Between 1 and 10000])
n502=..OP: chanserv levels # set OP $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for OP: $next [Between 1 and 10000])
n503=..AUTOPROTECT: chanserv levels # set AUTOPROTECT $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOPROTECT: $next [Between 1 and 10000])
n504=..AKICK: chanserv levels # set AKICK $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AKICK: $next [Between 1 and 10000])
n505=..BADWORDS (Bot): chanserv levels # set BADWORDS $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for BADWORDS: $next [Between 1 and 10000])
n506=..$style(2) $+ ASSIGN (Bot) [Founder Only]: noop
n507=..MEMO: chanserv levels # set MEMO $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for MEMO: $next [Between 1 and 10000])
n508=..PROTECTME: chanserv levels # set PROTECTME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for PROTECTME: $next [Between 1 and 10000])
n509=..PROTECT: chanserv levels # set PROTECT $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for PROTECT: $next [Between 1 and 10000])
n510=..SET: chanserv levels # set SET $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for SET: $next [Between 1 and 10000])
n511=..AUTOOWNER: chanserv levels # set AUTOOWNER $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for AUTOOWNER: $next [Between 1 and 10000])
n512=..OWNERME: chanserv levels # set OWNERME $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for OWNERME $next [Between 1 and 10000])
n513=..$style(2) $+ OWNER Command [Founder Only]: noop
n514=..FOUNDER: chanserv levels # set FOUNDER $$decision(egv¿incorrigo syx $pipe access list levels¿Set level for FOUNDER: $next [Between 1 and 10000])
n515=$iif(!$idf,$null,Auto Kick Menu)
n516=.Add Auto-Kick: chanserv akick # add $$decision(eg¿incorrigo syx $pipe auto kick list¿Enter account / nickname or mask: $next [Mask: nick!user@host.or.ip]) $$decision(egi¿incorrigo syx $pipe auto kick list¿Enter reason for auto kick:)
n517=.Remove Auto-Kick: chanserv akick # del $$decision(qeg¿incorrigo syx $pipe remove auto kick¿Entry to remove from # AKICK list: $next [It's easier to put the number from the akick list])
n518=.View List: chanserv akick # list
n519=.-
n520=.What is auto-kick?: explain Auto-Kick is a list of people who will be kicked and banned by services as soon as they are detected in the channel $next An akick can either be a registered account holder or an address with wildcards permitted $next To remove an akick easily just enter the number of the entry from the akick list
n521=-
n522=$iif(!$idf,$null,Memoserv Lists)
n523=.Send a Memo: memoserv send $$decision(qeg¿incorrigo syx $pipe send memo¿Enter registered nickname or channel:) $$decision(qeg¿incorrigo syx $pipe send memo¿Enter the content of your message:))
n524=.-
n525=.# Inbox: {
n526=  query memoserv
n527=  clear memoserv
n528=  memoserv help all
n529=  .timer -m 1 600 msg memoserv LIST #
n530=}
n531=.$me Inbox: {
n532=  query memoserv
n533=  clear memoserv
n534=  memoserv help all
n535=  .timer -m 1 600 msg memoserv LIST
n536=}
n537=.-
n538=.Memoserv Menu: query memoserv help
n539=.-
n540=.What is memoserv?: explain Memoserv provides a message inbox for your account / regustered channel - it allows messages to be sent and kept for you by services, whether you are online or not
n541=$iif(!$idfr,$null,vHost Settings)
n542=.On: hostserv on
n543=.Off: hostserv off
n544=.-
n545=.Request a vHost: hostserv request $lHngen $+ . $+ $$decision(qeg¿incorrigo syx $pipe request vHost¿Enter vHost to request:)
n546=.-
n547=.What is hostserv?: explain Hostserv is the vanity hostname (vHost) service $next You use it to request a vHost, which will be approved by an operator $next Once approved, your address will be changed automatically when you log into your registered nickname / user account
n548=$iif(!$idf,$null,Botserv / Channel Bot)
n549=.Say Something: botserv say # $$decision(eg¿incorrigo syx $pipe bot - say [message]¿Enter message for bot to channel:)
n550=.Do Something: botserv act # $$decision(eg¿incorrigo syx $pipe bot - do [action]¿Enter /me action for bot to channel:)
n551=.-
n552=.Botserv Info - #: botserv info #
n553=.Start a Botserv Session: {
n554=  query botserv info #
n555=  .timer -m 1 400 query botserv help
n556=}
n557=.-
n558=.View List of Bots: botserv botlist
n559=.Bot Assignment
n560=..Assign Bot: { botserv botlist | botserv assign # $$decision(eg¿incorrigo syx $pipe assign bot¿Enter nickname from bot list to assign here:) }
n561=..Remove Assigned Bot: botserv unassign #
n562=.-
n563=.Badwords List
n564=..Add [Word Beginning]: botserv badwords # add $$decision(qeg¿incorrigo syx $pipe add badwords¿Enter 'word beginning' badword:) START
n565=..Add [Word Ending]: botserv badwords # add $$decision(qeg¿incorrigo syx $pipe add badwords¿Enter 'word beginning' badword:) END
n566=..Add [Single Word]: botserv badwords # add $$decision(qeg¿incorrigo syx $pipe add badwords¿Enter 'word beginning' badword:) SINGLE
n567=..-
n568=..Delete Entry: botserv badwords # del $$decision(qeg¿incorrigo syx $pipe badwords list¿Enter word / list number to remove:)
n569=..Clear Badwords List: {
n570=  var %pervert = $$decision(wyvgb¿incorrigo syx $pipe clear badwords¿You are about to clear the badwords list for # $next Do you wish to proceed?)
n571=  if (%pervert == $yes) {
n572=    botserv badwords # clear
n573=  }
n574=}
n575=..-
n576=..# Badwords List: botserv badwords # list
n577=.Change Bot Settings
n578=..Ban Expire Time
n579=...Set Timer: botserv set banexpire # $$decision(egb¿incorrigo syx $pipe botserv ban time¿Enter ban expire timer for # $+ : $next [Use time notation like 28m or 1d])
n580=...Bot Ban Info: noop $$decision(igo¿incorrigo syx $pipe channel bot bans¿If you have a services bot on your channel then you can customise how and why users will be disciplined for breaking the bot's rules that are set $next In the bot's 'kick' settings there is an option to ban a user when they have been kicked X amount of times. This is when the ban with your duration of choice will be set by your bot)
n581=..Don't Kick Ops
n582=...ON: botserv set dontkickops # on
n583=...OFF: botserv set dontkickops # off
n584=...-
n585=...What is this?: explain When in 'Don't Kick Ops' mode $+ $c the channel bot will not kick someone who would normally trigger a kick ... if they are a channel operator of any kind
n586=..Don't Kick Voices
n587=...ON: botserv set dontkickvoices # on
n588=...OFF: botserv set dontkickvoices # off
n589=...-
n590=...What is this?: explain This setting is the same as 'Don't Kick Ops' but it applies to users who currently have voice when they would otherwise be kicked
n591=..Fantasy Commands
n592=...ON: botserv set fantasy # on
n593=...OFF: botserv set fantasy # off
n594=...-
n595=...What is this?: explain Fantasy setting emulates a real bot by accepting commands that begin with ! or . $next Type !help in the channel when this setting is enabled to see a full list of commands that the channel bot will accept $next Only users on the channel access list will be able to use these commands
n596=..Greet Messages
n597=...ON: botserv set greet # on
n598=...OFF: botserv set greet # off
n599=...-
n600=...What is this?: explain The GREET setting will make the bot say a joining user's greeting message set by nickserv $next For more information: /nickserv help set greet
n601=.Kick Settings
n602=..Kick for AMSG
n603=...ON: botserv kick amsg # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many times will result in a ban?)
n604=...OFF: botserv kick amsg # off
n605=...-
n606=...What is this?: explain The AMSG kicker will kick users who are detected saying the same message to multiple channels at the same time
n607=..Badwords Kick
n608=...ON: botserv kick badwords # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many badword kicks will result in a ban?)
n609=...OFF: botserv kick badwords # off
n610=...-
n611=...What is this?: explain This function will kick users who use the badwords that you can also configure using this menu in the channel $next Even if you use the same bot for another channel $+ $c each channel has its own badwords list for you to configure $next As with the other kick settings - you can control how many times someone is kicked before it also results in a ban
n612=..Kick for Bolds
n613=...ON: botserv kick bolds # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for bolds result in a ban?)
n614=...OFF: botserv kick bolds # off
n615=...-
n616=...What is this?: explain This setting will kick users who use bold formatting codes in their messages $next You can configure how many times someone is kicked for using bolds until it results in a ban
n617=..CAPS Kick
n618=...ON
n619=....25%: botserv kick caps # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for caps will result in a ban?) 15 25
n620=....50%: botserv kick caps # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for caps will result in a ban?) 20 50
n621=....75%: botserv kick caps # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for caps will result in a ban?) 25 75
n622=...OFF: botserv kick caps # off
n623=...-
n624=...What is this?: explain The caps kick setting will remove users who send their messages to the channel using capital letters. The severity of the caps messages is measured as a percentage of the user's entire message $next Many people consider messages which are written in caps akin to shouting and find them offensive
n625=..Colours Kick
n626=...ON: botserv kick colors # ON $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for colours will result in a ban?)
n627=...OFF: botserv kick colors # OFF
n628=...-
n629=...What is thi?: explain This kicker will remove users who use colour codes in their messages. This will normalise the messages that are sent to the channel without there being some obnoxious colouring to the messages that are caused by using colour codes
n630=..Flooding Kick
n631=...ON: botserv kick flood # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for flooding will result in a ban?) $$decision(beg¿incorrigo syx $pipe bot kick config¿Enter how many lines in X seconds that will count as flooding: $next [example: 8 5 will be 8 messages in 5 seconds)
n632=...OFF: botserv kick flood # off
n633=...-
n634=...What is this?: explain The flood kicker does not affect other anti flood features such as channel mode +f. $next This kicker will kick a user from the channel if they send X messages in Y seconds (set by you) ... and if they are kicked for this Z number of times they are banned - also set by you
n635=..Italics Kick
n636=...ON: botserv kick italics # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for italic formatting will result in a ban?)
n637=...OFF: botserv kick italics # off
n638=..Underlines Kick
n639=...ON: botserv kick underlines # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for underline formatting will result in a ban?)
n640=...OFF: botserv kick underlines # off
n641=..Repeating Messages Kick
n642=...ON: botserv kick repeat # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for repetitive messages will result in a ban?) $$decision(beg¿incorrigo syx $pipe bot kick config¿How many times does a message have to repeat itself to cause a kick?)
n643=...OFF: botserv kick repeat # off
n644=..Reversing Messages Kick
n645=...ON: botserv kick reverses # on $$decision(beg¿incorrigo syx $pipe bot kick config¿How many kicks for reversing messages will result in a ban?)
n646=...OFF: botserv kick reverses # off
n647=.-
n648=.Network Bots Policy: text-reader incorrigo-syx\docu-mental\bot-services.tr Channel Bot Policy + Services
n649=$pnln $iif(!$idf,Identify / Account Login,User Account Menu)
n650=.$pnln Identify as $me $+ : {
n651=  if (r !isin $usermode) { id $$quik.d(pdoubled,incorrigo syx $pipe nickserv identify¿Enter account password for $me $+ :) }
n652=  else { rawbak.d words incorrigo syx $pipe identify nickname¿You are already identified as $me and don't need to log in }
n653=}
n654=.-
n655=.$pnln Recover a Different Nickname: {
n656=  set -e %main.rnick $$decision(qbeg¿incorrigo syx $pipe nickname recovery¿Enter registered nickname to recover:)
n657=  set -e %main.rlpwd $$decision(qbpg¿incorrigo syx $pipe login to nickname¿Enter account password:)
n658=  nickserv RECOVER %main.rnick %main.rlpwd
n659=  .timer 1 1 nick %main.rnick
n660=  .timer 1 2 { unset %main.rnick | unset %main.rlpwd }
n661=}
n662=.$pnln $iif($!idf,Create New Account,$null): {
n663=  register $$decision(qpgb¿incorrigo syx $pipe new account¿Enter account password: $next [no one else will ever have access to this password]) $$decision(qegb¿incorrigo syx $pipe new account¿Enter your email address: $next [required for account verification])
n664=}
n665=.$pnln $iif($getuserID != $null && $getuserID != $me,Use Account Nickname - $getuserID,$null): { nick $getuserID }
n666=.$pnln $iif(!$idf,User Account Login,Log out From $getuserID) $+ : {
n667=  if (!$idf) { nickserv identify $$decision(qeg¿incorrigo syx $pipe user account login¿Enter account name:) $$decision(qpg¿incorrigo syx $pipe user account login¿Enter account password:) }
n668=  else { nickserv logout }
n669=}
n670=.$pnln $iif($idf && !$idfr,Register $me to $getuserID Account,$null) $+ : nickserv group $getuserID
n671=.$pnln $iif(!$idf && !$idfr,Add $me to an Existing Account,$null) $+ : nickserv group $$decision(ebgoq¿incorrigo syx $pipe group nickname¿Enter your account name:) $$decision(pbgoq¿incorrigo syx $pipe group nickname¿Enter account password:)
n672=.$pnln $iif(!$idf,Recover Registered Nickname,$null): {
n673=  var %nicknamed = $$decision(qbego¿incorrigo syx $pipe nickname recovery¿Enter account nickname to recover:)
n674=  var %capsllwdd = $$decision(qbpgo¿incorrigo syx $pipe login to nickname¿Enter account password:)
n675=  nickserv RECOVER %nicknamed %capsllwd
n676=  nick %nicknamed
n677=}
n678=.-
n679=.User Account Options Explained: text-reader incorrigo-syx\docu-mental\account-login.tr Understanding User Account Options
n680=$pnln $iif(!$idf,$null,Nickserv Session): query nickserv help
n681=-
n682=Network Messages Options
n683=.Check Menu Visibility
n684=..$iif($wzy(#) == $null,$style(1),$null) $+ Channel Half-Operator: noop $decision(go¿incorrigo syx $pipe half-op commands¿When you are an half operator $chr(91) $+ $percenti $+ $chr(93) several limited channel op functions become available)
n685=..$iif($wdy(#) == $null,$style(1),$null) $+ Channel Operator: noop $decision(go¿incorrigo syx $pipe channel op commands¿A channel operator [@] can perform all the commands that are needed to register / control a channel $next All the commands on that channel will appear alongside the rest of them)
n686=..$iif($idf == $true,$style(1),$null) $+ User Account Login: noop $decision(go¿incorrigo syx $pipe menu visibility¿When you log in to your account $+ $c services menus will appear $next If you don't have permission to use a particular command $+ $c it won't work $next However if you do have permissions $+ $c you don't need to be a channel operator in order to use them)
n687=..$iif($idfr == $true,$style(1),$null) $+ Using Registered Nickname: noop $decision(go¿incorrigo syx $pipe menu visibility¿If you are logged in to an account you can use any nickname that's available $next Registered nicknames are protected $+ $c and some features - like hostserv requests - require you to be using your registered nickname $+ $obk $+ s $+ $cbk)
n688=..$iif($sysop,$style(1),$null) $+ Network Engineer: noop $decision(tgo¿incorrigo syx $pipe menu visibility¿A successful IRC operator login will show all of the controls and some oper-only ones)
n689=.-
n690=.$smc Read Out Permission Changes: togglesmc
n691=.$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops
n692=.Local Time Format
n693=..$timewy(1) Very Long Date && Time: { %ctcp.timeformat = 1 | echo -atc Info * Local Time: $gettime }
n694=..$timewy(2) Long Date && Time: { %ctcp.timeformat = 2 | echo -atc Info * Local Time: $gettime }
n695=..$timewy(3) Local Time Only: { %ctcp.timeformat = 3 | echo -atc Info * Local Time: $gettime }
n696=..$timewy(4) Brief Time && Date: { %ctcp.timeformat = 4 | echo -atc Info * Local Time: $gettime }
n697=..$timewy(5) Time of Day && Date: { %ctcp.timeformat = 5 | echo -atc Info * Local Time: $gettime }

[bpopup]
n0=Incorrigo Sy&x
n1=$iif($server,$pnln --> $me,Connect to Network): {
n2=  if (!$server) { F3 }
n3=  else { checkme }
n4=}
n5=-
n6=$pnln Identify With Nickserv: {
n7=  if (!$idf) { id $$quik.d(pdoubled,incorrigo syx $pipe services identification¿Enter your password to log in with nickserv:) | halt }
n8=  else { rawbak.d words incorrigo syx $pipe services identification¿You are already identified $+ $c and don't need to log in | halt }
n9=}
n10=$pnln User Account && Registration Menu
n11=.New Account Registration: {
n12=  register $$decision(qpgb¿incorrigo syx $pipe new account¿Enter account password: $+ $crlf $crlf $+ [no one else will ever have access to this password]) $$decision(qegb¿incorrigo syx $pipe new account¿Enter your email address: $+ $crlf $crlf $+ [required for account verification])
n13=}
n14=.Re-send Confirmation Code Email: nickserv resend
n15=.Input Confirmation Code: nickserv confirm $$decision(qeg¿incorrigo syx $pipe registration code¿Enter nickserv confirmation code: $+ $crlf $crlf $+ [you should have got this in your email])
n16=$iif($idf,$iif(o !isin $usermode,$pnln Network Engineer,$null),$null): oper $$decision(etbg¿incorrigo syx $pipe network engineer¿Enter engineer ID:) $$decision(ptbg¿incorrigo syx $pipe network engineer¿Enter engineer code: $+ $crlf $crlf $+ [NB: Failed engineer login attempts are monitored])
n17=$pnln Away Manager: awaymgr
n18=$pnln $iif(!$idf,Identify with Nickserv,User Account Options)
n19=.$pnln Identify as $me $+ : {
n20=  if (r !isin $usermode) { id $$quik.d(pdoubled,incorrigo syx $pipe nickserv identify¿Enter account password for $me $+ :) }
n21=  else { rawbak.d words incorrigo syx $pipe identify nickname¿You are already identified as $me and don't need to log in }
n22=}
n23=.-
n24=.$pnln $iif($getuserID != $null && $getuserID != $me,Use Account Nickname - $getuserID,$null): { nick $getuserID }
n25=.$pnln $iif(!$idf,User Account Login,Log out From $getuserID) $+ : {
n26=  if (!$idf) { nickserv identify $$decision(qeg¿incorrigo syx $pipe user account login¿Enter account name:) $$decision(qpg¿incorrigo syx $pipe user account login¿Enter account password:) }
n27=  else { nickserv logout }
n28=}
n29=.$pnln $iif($idf && !$idfr,Register $me to $getuserID Account,$null) $+ : nickserv group $getuserID
n30=.$pnln $iif(!$idf && !$idfr,Add $me to an Existing Account,$null) $+ : nickserv group $$decision(ebgoq¿incorrigo syx $pipe group nickname¿Enter your account name:) $$decision(pbgoq¿incorrigo syx $pipe group nickname¿Enter account password:)
n31=.$pnln $iif(!$idf,Recover Registered Nickname,$null): nickserv RECOVER $$decision(qbego¿incorrigo syx $pipe nickname recovery¿Enter registered nickname to recover:) $$decision(qbpgo¿incorrigo syx $pipe login to nickname¿Enter account password:)
n32=.-
n33=.User Account Options Explained: text-reader incorrigo-syx\docu-mental\account-login.tr Understanding User Account Options
n34=$iif(!$idf,$null,(Re)gain Access to Channel)
n35=.Remove Matching Bans: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv unban %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n36=.Invitation Requirements: { %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker lock add +I ~a: $+ $me | chanserv invite %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker } }
n37=.Channel Key Setting [+k]
n38=..Get Current Key: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv getkey %cserv.wanker
n39=..Remove Key: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -k wanker | if ($me !ison 5cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n40=.Channel Limit Derestriction [+l]: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -l | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n41=.-
n42=.What is this?: explain If you are on a channel's access list $+ $c then you can use chanserv to regain access to the channel $+ $crlf $crlf $+ There are a number of reasons a channel operator can be unable to join. These options will give you a range of different ways you may need to use chanserv to get back inside
n43=$iif(!$idf,$null,Hostserv Menu)
n44=.Switch On: hostserv on
n45=.Switch Off: hostserv off
n46=.-
n47=.Server vHost Login: vhost $$decision(egbt¿incorrigo syx $pipe vHost login¿Enter vHost Operator Number:) $$decision(pgbt¿incorrigo syx $pipe vHost login¿Your password please:)
n48=.-
n49=.Request vHost: {
n50=  if (!$idfr) { return $$decision(hugob¿incorrigo syx $pipe hostserv error¿You get a vHost per-nickname that you have registered $+ $crlf $crlf $+ To request a vHost you need to be identified to nickserv as one of your registered nicknames) }
n51=  else { %main.hsr = $$quik.d(doubled,incorrigo syx $pipe make vhost request¿Enter a vhost / user@vhost request:) }
n52=  if ($left(%main.hsr,3) == lH-) {
n53=    hostserv request %main.hsr
n54=  }
n55=  else { hostserv request $lHngen $+ . $+ %main.hsr }
n56=}
n57=.Generate lH Number: lhnumber
n58=.-
n59=.About Hostserv / vHost: noop $decision(og¿incorrigo syx $pipe about vHost¿When you have a registered nickname $+ $c you can request a vHost from hostserv $+ $crlf $crlf $+ A vHost is a vanity hostname that lets your hostname / ip address be anything you want. When it is activated $+ $c it is automatically applied when you identify for that nickname $+ $crlf $crlf $+ You can have a different vHost for each nickname. You can register multiple nicknames under one account using the nickserv GROUP command)
n60=.What is lH number?: text-reader incorrigo-syx\docu-mental\understanding-vhost.tr Understanding vHost and lH numbers
n61=-
n62=$pnln Change User Info
n63=.Change Nickname: nick $$decision(evq¿incorrigo syx $pipe change username¿Enter new nickname:)
n64=.Change Ident (User Name): setident $$decision(evq¿incorrigo syx $pipe change username¿Enter new ident: $+ $crlf $crlf $+ [nickname!ident@host.vhost.or.ip])
n65=.Change 'Real Name': setname $$decision(evq¿incorrigo syx $pipe change username¿Enter new real name: $+ $crlf $crlf $+ [you are not required to use your real name])
n66=.-
n67=.Server vHost Login: vhost $$decision(egt¿incorrigo syx $pipe server vHost¿Enter vHost Login Name:) $$decision(pgt¿incorrigo syx $pipe server vHost¿Enter vHost Password:)
n68=$pnln Set User Modes
n69=.Bot Mode [B]
n70=..+B: mode $me +B
n71=..-B: mode $me -B
n72=..-
n73=..What is this?: explain Bot Mode [+B] is a flag that adds a tag to your outgoing messages / line in your /WHOIS response that identifies you as being a bot $+ $crlf $crlf $+ Bots are permitted on our network and this mode helps others identify / facilitate your bot's status
n74=.Bot Deaf Mode [d]
n75=..+d: mode $me +d
n76=..-d: mode $me -d
n77=..-
n78=..What is this?: explain Deaf mode [+d] will stop you from receiving any channel messages that don't start with the designated bot command character $+ $crlf $crlf $+ It is not recommended except if your client is a bot. Messages that will come through only start with either exclamation mark '!' or full stop '.'
n79=.Decline Private Messages [D]
n80=..+D: mode $me +D
n81=..-D: mode $me -D
n82=..-
n83=..What is this?: explain Private denied mode [+D] will decline all private messages from other users $+ $c telling them that you don't accept private messages $+ $crlf $crlf $+ With this mode set $+ $c only systems operators / network services are able to send you private messages $+ $c so you will still be able to use services and ask for help while still rejecting othersuch private messages
n84=.Profanity Censor [G]
n85=..+G: mode $me +G
n86=..-G: mode $me -G
n87=..-
n88=..What is this?: explain Profanity censor mode [+G] does the same thing as channel mode +G but with private messages $+ $crlf $crlf $+ If someone uses a word or phrase that is configured as profanity by the server $+ $c then the word / phrase will either be [censor]ed $+ $c or blocked completely
n89=.$iif($sysop,Hide IRC Operator Status $chr(91) $+ H $+ $chr(93),$null)
n90=..+H: mode $me +H
n91=..-H: mode $me -H
n92=..-
n93=..What is this?: explain This mode [+H] will hide your operator status from /WHOIS $+ $c /WHO $+ $c and other user lookups
n94=.Hide Online Time [I]
n95=..+I: mode $me +I
n96=..-I: mode $me -I
n97=..-
n98=..What is this?: explain Hide time mode [+I] will hide your online / idle time(s) from your /WHOIS and othersuch look-ups
n99=.Invisible Mode [i]
n100=..+i: mode $me +i
n101=..-i: mode $me -i
n102=..-
n103=..What is this?: explain Invisible mode [+i] will hide your presence from /WHO and /NAMES requests done by anyone who doesn't share any channels with you $+ $crlf $crlf $+ This is usually set by mIRC automatically when you have successfully connected. But this option gives you more control over it if that's what you want
n104=.IRC Operator [o]
n105=..$iif($sysop,-o,$style(2) $+ -o): mode $me -o
n106=..-
n107=..What is this?: explain IRC Operator status is represented by the user mode [+o] which can only be given from a successful oper login $+ $crlf $crlf $+ Simply having this mode means nothing. However $+ $c all operator privileges can be removed by setting user mode [-o]
n108=.Private User [p]
n109=..+p: mode $me +p
n110=..-p: mode $me -p
n111=..-
n112=..What is this?: explain Private mode [+p] hides information from other people $+ $c such as all the channels you are in from your /WHOIS response. It is supposed to prevent intrusive behaviour from other users
n113=.$iif($sysop,Unkickable Mode [q],$null)
n114=..+q: mode $me +q
n115=..-q: mode $me -q
n116=..-
n117=..What is this?: explain Unkickable mode [+q] protects you from being removed by channel operators $+ $crlf $crlf $+ This mode is for preventing normal users from removing you when an operator presence is needed in the channel $+ $crlf $crlf $+ You will be alerted by the server in a private message when an attempt to kick you has failed
n118=.Registered Nickname [r]
n119=..$style(2) $+ +r: mode $me +r
n120=..$style(2) $+ -r: mode $me -r
n121=..-
n122=..What is this?: explain Registered nickname [+r] can only be set / unset by services or the server that you are connected to $+ $crlf $crlf $+ It denotes that the nickname you are using is registered and you have successfully identified as the owner of it
n123=.Registered Messages Only [R]
n124=..+R: mode $me +R
n125=..-R: mode $me -R
n126=..-
n127=..What is this?: explain Registered Messages Only [+R] will only allow private messages that are sent from a registered user who is currently logged into an account $+ $crlf $crlf $+ Users who message you will be told that they must be logged in to an account to send you messages $+ $c and their message to you will not be delivered
n128=.$iif($sysop,Network Service [S],$null)
n129=..+S: mode $me +S
n130=..-S: mode $me -S
n131=..-
n132=..What is this?: explain Network Services mode [+S] protects service bots on the channels that they are currently on $+ $crlf $crlf $+ This mode can't normally be set by users but services admins with access to the UMODE command by operserv can use it to set this mode onto themselves
n133=.Server Notices [s]
n134=..+s <snomask>: mode $me +s $$decision(teg¿incorrigo syx $pipe snomask set¿Enter snomask parameters:)
n135=..-s: mode $me -s
n136=..-
n137=..Server Notices: text-reader incorrigo-syx\docu-mental\snomasks.tr Server Notice Masks [Snomasks]
n138=.No CTCP Requests [T]
n139=..+T: mode $me +T
n140=..-T: mode $me -T
n141=..-
n142=..What is this?: explain No CTCP Mode [+T] will prevent you from receiving CTCP requests sent to you by other users
n143=.Using a vHost [t]
n144=..+t: mode $me +t
n145=..-t: mode $me -t
n146=..-
n147=..What is this?: explain vHost mode [+t] is usually set by the server [/VHOST] or services [hostserv] to denote that you are currently using a vanity hostname [vHost] $+ $crlf $crlf $+ This is not to be confused by cloaked host mode [+x] which is given to users on connecting
n148=.$iif(o isincs $usermode,Show /WHOIS [W],$null)
n149=..+W: mode $me +W
n150=..-W: mode $me -W
n151=..-
n152=..What is this?: explain Show Whois [+W] is a mode that can be set by an IRC operator $+ $c which will notify you when another user looks you up via the /WHOIS command
n153=.Receive Wallops [w]
n154=..$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops
n155=..-
n156=..What is this?: explain Receive Wallops [+w] will show you when message are sent by a systems operator via the /WALLOPS command $+ $crlf $crlf $+ Only an operator can send wallops messages $+ $c but any user through this mode is allowed to receive them
n157=.Cloaked Host [x]
n158=..+x: mode $me +x
n159=..-x: mode $me -x
n160=..-
n161=..What is this?: explain Cloaked hostname mode [+x] gives you a 'cloaked' hostname $+ $crlf $crlf $+ A cloaked hostname will still uniquely identify you / any clones you have online $+ $c but can not be used to connect to you over the internet
n162=.Secure Messages Only [Z]
n163=..+Z: mode $me +Z
n164=..-Z: mode $me -Z
n165=..-
n166=..What is this?: explain Secure Messages Only [+Z] will only allow private messages from users who are connected securely using TLS $+ $crlf $crlf $+ Any users who only have plaintext connections which are not secure $+ $c will receive an error and their message to you will not be delivered $+ $crlf $crlf $+ All users connected via web browser client are connected securely so this will not be an issue for them-
n167=$pnln Join Channel: join $$decision(eg¿incorrigo syx $pipe join channel¿Enter channel name to join: $+ $crlf $crlf $+ [You can add a password by adding another word e.g. #channelname letmein $+ ])
n168=$pnln Find Channels: list $decision(eg¿incorrigo syx $pipe channels¿Throw in a word or leave blank to list all:)
n169=$iif(!$idf,$null,Check Memo List): {
n170=  query memoserv
n171=  clear memoserv
n172=  ms help all
n173=  .timer -m 1 700 msg memoserv LIST
n174=}
n175=-
n176=$pnln Check Online Time: {
n177=  echo -astc Mode * Online: This connection has been active for $getconnectid
n178=}
n179=System Menu
n180=.Check Menu Visibility
n181=..$style(2) $+ Channel Half Operator: noop
n182=..$style(2) $+ Channel Operator: noop
n183=..$iif($idf == $true,$style(1),$null) $+ User Account Login: noop $decision(go¿incorrigo syx $pipe menu visibility¿Extensive menus that give you access to our network services $+ $crlf $crlf $+ Services that are available include: nickserv $+ $c chanserv $+ $c memoserv $+ $c hostserv $+ $c and botserv $+ $crlf $crlf $+ You can access new account registration from the [Identify / User Account] menu in the menubar $+ $c status $+ $c and in the channel window)
n184=..$iif($idfr == $true,$style(1),$null) $+ Using Registered Nickname: noop $decision(go¿incorrigo syx $pipe menu visibility¿When you are logged into an account you can still use any available nickname. Multiple nicknames can be added to your account by using the options in the user account menu in status / channel / menubar $+ $crlf $crlf $+ A registered nickname is protected and requires you to login in order to use them. User mode +r is services acknowledgement you are identified for the nickname you are using $+ $crlf $crlf $+ Other menus can behave differently if a registered nickname is required as well as an account login $+ $c but most of the functionality will be visible by a successful account login)
n185=..$iif($sysop,$style(1),$null) $+ Network Engineer: noop $decision(tgo¿incorrigo syx $pipe menu visibility¿In status / channel / top menu bar there will be an option called Network Engineer $+ $crlf $crlf $+ In those places $+ $c you will find the Network Engineer menu $+ $c which contains extensive IRC operator [+ services] commands $+ $crlf $crlf $+ NB: You may not have the correct permissions to use all of the commands that become available)
n186=.-
n187=.Local Time Format
n188=..$timewy(1) Very Long Date && Time: { %ctcp.timeformat = 1 | echo -atc Info * Local Time: $gettime }
n189=..$timewy(2) Long Date && Time: { %ctcp.timeformat = 2 | echo -atc Info * Local Time: $gettime }
n190=..$timewy(3) Local Time Only: { %ctcp.timeformat = 3 | echo -atc Info * Local Time: $gettime }
n191=..$timewy(4) Brief Time && Date: { %ctcp.timeformat = 4 | echo -atc Info * Local Time: $gettime }
n192=..$timewy(5) Time of Day && Date: { %ctcp.timeformat = 5 | echo -atc Info * Local Time: $gettime }
n193=.$smc Read Out Permission Changes: togglesmc
n194=.$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops
n195=.-
n196=.Delete All Settings - Factory Reset: {
n197=  .enable #firstusereset
n198=  yazzilou
n199=  .disable #firstusereset
n200=}

[mpopup]
n0=$iif($server,$pnln --> $me,Connect to Network): {
n1=  if (!$server) { server irc.incorrigo.io }
n2=  else { checkme }
n3=}
n4=-
n5=$pnln Join a Channel: join $$decision(eg¿incorrigo syx $pipe join channel¿Enter channel name to join:)
n6=.$pnln Find Channels: {
n7=  var %criterion $$decision(yvg¿incorrigo syx $pipe find channels¿Do you wish to enter a keyword?)
n8=  if (%criterion == $yes) {
n9=    var %criterioin $decision(geq¿incorrigo syx $pipe channel list search¿Enter keyword(s) to refine your channel list:)
n10=  }
n11=  list %criterioin
n12=}
n13=-
n14=$pnln Away Manager: awaymgr
n15=$iif($idf,$iif(o !isin $usermode,$pnln Network Engineer,$null),$null): oper $$decision(etbg¿incorrigo syx $pipe network engineer¿Enter engineer ID:) $$decision(ptbg¿incorrigo syx $pipe network operator¿Enter engineer code: $+ $crlf $crlf $+ [NB: Failed engineer login attempts are monitored])
n16=$iif($idf,$pnln Query Network Services,$null)
n17=.Nickserv Session: query nickserv help
n18=.Chanserv Session: query chanserv help
n19=.Hostserv Session: query hostserv help
n20=.Memoserv Session: query memoserv help
n21=.Botserv Session: query botserv help
n22=.$iif(!$idf || o !isincs $usermode,$null,Operserv Session): query operserv help
n23=$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops
n24=.-
n25=$pnln Server Help Menu
n26=.Main Menu: helpop
n27=.Help Directory: helpop directory
n28=.-
n29=.Good Modes
n30=..Good Modes Information: helpop goodmodes
n31=..-
n32=..Mode Profiles: helpop modeprofiles
n33=..-
n34=..Small Side Channel: helpop modeprofile.office
n35=.."Main" Channel: helpop modeprofile.bigtime
n36=..Technical Support: helpop modeprofile.techsupport
n37=.User Modes: helpop umodes
n38=.Channel Modes: helpop chmodes
n39=.-
n40=.User Commands: helpop usercmds
n41=.Operator Commands: helpop opercmds
n42=.Server Only Commands: helpop svscmds
n43=.-
n44=.About Incorrigo Syx: helpop about
n45=-
n46=$pnln Change Your Info
n47=.Change Nickname: nick $$decision(evq¿incorrigo syx $pipe change username¿Enter new nickname:)
n48=.Change Ident (User Name): setident $$decision(evq¿incorrigo syx $pipe change username¿Enter new ident: $+ $crlf $crlf $+ [nickname!ident@host.vhost.or.ip])
n49=.Change 'Real Name': setname $$decision(evq¿incorrigo syx $pipe change username¿Enter new real name: $+ $crlf $crlf $+ [you are not required to use your real name])
n50=.$iif($sysop,IP / Hostname,$null): sethost $$decision(evt¿incorrigo syx $pipe manual vHost¿Enter your new host.name.or.ip: $+ $crlf $crlf $+ [this will not stop bans containing your real info from working])
n51=.-
n52=.Server vHost Login: vhost $$decision(egt¿incorrigo syx $pipe server vHost¿Enter vHost Login Name:) $$decision(pgt¿incorrigo syx $pipe server vHost¿Enter vHost Password:)
n53=$pnln Set User Modes
n54=.Bot Mode [B]
n55=..+B: mode $me +B
n56=..-B: mode $me -B
n57=..-
n58=..What is this?: explain Bot Mode [+B] is a flag that adds a tag to your outgoing messages / line in your /WHOIS response that identifies you as being a bot $+ $crlf $crlf $+ Bots are permitted on our network and this mode helps others identify / facilitate your bot's status
n59=.Bot Deaf Mode [d]
n60=..+d: mode $me +d
n61=..-d: mode $me -d
n62=..-
n63=..What is this?: explain Deaf mode [+d] will stop you from receiving any channel messages that don't start with the designated bot command character $+ $crlf $crlf $+ It is not recommended except if your client is a bot. Messages that will come through only start with either exclamation mark '!' or full stop '.'
n64=.Decline Private Messages [D]
n65=..+D: mode $me +D
n66=..-D: mode $me -D
n67=..-
n68=..What is this?: explain Private denied mode [+D] will decline all private messages from other users $+ $c telling them that you don't accept private messages $+ $crlf $crlf $+ With this mode set $+ $c only systems operators / network services are able to send you private messages $+ $c so you will still be able to use services and ask for help while still rejecting othersuch private messages
n69=.Profanity Censor [G]
n70=..+G: mode $me +G
n71=..-G: mode $me -G
n72=..-
n73=..What is this?: explain Profanity censor mode [+G] does the same thing as channel mode +G but with private messages $+ $crlf $crlf $+ If someone uses a word or phrase that is configured as profanity by the server $+ $c then the word / phrase will either be [censor]ed $+ $c or blocked completely
n74=.$iif($sysop,Hide IRC Operator Status $chr(91) $+ H $+ $chr(93),$null)
n75=..+H: mode $me +H
n76=..-H: mode $me -H
n77=..-
n78=..What is this?: explain This mode [+H] will hide your operator status from /WHOIS $+ $c /WHO $+ $c and other user lookups
n79=.Hide Online Time [I]
n80=..+I: mode $me +I
n81=..-I: mode $me -I
n82=..-
n83=..What is this?: explain Hide time mode [+I] will hide your online / idle time(s) from your /WHOIS and othersuch look-ups
n84=.Invisible Mode [i]
n85=..+i: mode $me +i
n86=..-i: mode $me -i
n87=..-
n88=..What is this?: explain Invisible mode [+i] will hide your presence from /WHO and /NAMES requests done by anyone who doesn't share any channels with you $+ $crlf $crlf $+ This is usually set by mIRC automatically when you have successfully connected. But this option gives you more control over it if that's what you want
n89=.IRC Operator [o]
n90=..$iif($sysop,-o,$style(2) $+ -o): mode $me -o
n91=..-
n92=..What is this?: explain IRC Operator status is represented by the user mode [+o] which can only be given from a successful oper login $+ $crlf $crlf $+ Simply having this mode means nothing. However $+ $c all operator privileges can be removed by setting user mode [-o]
n93=.Private User [p]
n94=..+p: mode $me +p
n95=..-p: mode $me -p
n96=..-
n97=..What is this?: explain Private mode [+p] hides information from other people $+ $c such as all the channels you are in from your /WHOIS response. It is supposed to prevent intrusive behaviour from other users
n98=.$iif($sysop,Unkickable Mode [q],$null)
n99=..+q: mode $me +q
n100=..-q: mode $me -q
n101=..-
n102=..What is this?: explain Unkickable mode [+q] protects you from being removed by channel operators $+ $crlf $crlf $+ This mode is for preventing normal users from removing you when an operator presence is needed in the channel $+ $crlf $crlf $+ You will be alerted by the server in a private message when an attempt to kick you has failed
n103=.Registered Nickname [r]
n104=..$style(2) $+ +r: mode $me +r
n105=..$style(2) $+ -r: mode $me -r
n106=..-
n107=..What is this?: explain Registered nickname [+r] can only be set / unset by services or the server that you are connected to $+ $crlf $crlf $+ It denotes that the nickname you are using is registered and you have successfully identified as the owner of it
n108=.Registered Messages Only [R]
n109=..+R: mode $me +R
n110=..-R: mode $me -R
n111=..-
n112=..What is this?: explain Registered Messages Only [+R] will only allow private messages that are sent from a registered user who is currently logged into an account $+ $crlf $crlf $+ Users who message you will be told that they must be logged in to an account to send you messages $+ $c and their message to you will not be delivered
n113=.$iif($sysop,Network Service [S],$null)
n114=..+S: mode $me +S
n115=..-S: mode $me -S
n116=..-
n117=..What is this?: explain Network Services mode [+S] protects service bots on the channels that they are currently on $+ $crlf $crlf $+ This mode can't normally be set by users but services admins with access to the UMODE command by operserv can use it to set this mode onto themselves
n118=.Server Notices [s]
n119=..+s <snomask>: mode $me +s $$decision(teg¿incorrigo syx $pipe snomask set¿Enter snomask parameters:)
n120=..-s: mode $me -s
n121=..-
n122=..Server Notices: text-reader incorrigo-syx\docu-mental\snomasks.tr Server Notice Masks [Snomasks]
n123=.No CTCP Requests [T]
n124=..+T: mode $me +T
n125=..-T: mode $me -T
n126=..-
n127=..What is this?: explain No CTCP Mode [+T] will prevent you from receiving CTCP requests sent to you by other users
n128=.Using a vHost [t]
n129=..+t: mode $me +t
n130=..-t: mode $me -t
n131=..-
n132=..What is this?: explain vHost mode [+t] is usually set by the server [/VHOST] or services [hostserv] to denote that you are currently using a vanity hostname [vHost] $+ $crlf $crlf $+ This is not to be confused by cloaked host mode [+x] which is given to users on connecting
n133=.$iif(o isincs $usermode,Show /WHOIS [W],$null)
n134=..+W: mode $me +W
n135=..-W: mode $me -W
n136=..-
n137=..What is this?: explain Show Whois [+W] is a mode that can be set by an IRC operator $+ $c which will notify you when another user looks you up via the /WHOIS command
n138=.Receive Wallops [w]
n139=..$pnln $iif(w isincs $usermode,$style(1),$null) $+ Receive Wallops: $iif(w isincs $usermode,mode $me -w,mode $me +w) | togglewallops
n140=..-
n141=..What is this?: explain Receive Wallops [+w] will show you when message are sent by a systems operator via the /WALLOPS command $+ $crlf $crlf $+ Only an operator can send wallops messages $+ $c but any user through this mode is allowed to receive them
n142=.Cloaked Host [x]
n143=..+x: mode $me +x
n144=..-x: mode $me -x
n145=..-
n146=..What is this?: explain Cloaked hostname mode [+x] gives you a 'cloaked' hostname $+ $crlf $crlf $+ A cloaked hostname will still uniquely identify you / any clones you have online $+ $c but can not be used to connect to you over the internet
n147=.Secure Messages Only [Z]
n148=..+Z: mode $me +Z
n149=..-Z: mode $me -Z
n150=..-
n151=..What is this?: explain Secure Messages Only [+Z] will only allow private messages from users who are connected securely using TLS $+ $crlf $crlf $+ Any users who only have plaintext connections which are not secure $+ $c will receive an error and their message to you will not be delivered $+ $crlf $crlf $+ All users connected via web browser client are connected securely so this will not be an issue for them
n152=$iif(o isincs $usermode,Network Engineer,$null)
n153=.Operator Chat
n154=..Local Ops [this server]: locops $$decision(eg¿incorrigo syx $pipe local operator chat¿Enter local ops message:)
n155=..All Operators [network]: globops $decision(eg¿inicorrigo syx $pipe global operator chat¿Enter global ops message:)
n156=.$iif($aopper.rmenu(on),$style(1) $+,$null $+) Self-AOP
n157=..$iif($aopper.rmenu(self),$style(1) $+,$null $+) Oper-Override (self): aopper.set self
n158=..$iif($aopper.rmenu(csvc),$style(1) $+,$null $+) Chanserv: {
n159=  if ($decision(tygv¿incorrigo syx $pipe chanserv self-aop¿This setting will only work on registered channels. Proceed?) == $yes) {
n160=    aopper.set csvc
n161=  }
n162=}
n163=..$iif($aopper.rmenu(scmd),$style(1) $+,$null $+) Samode Command: aopper.set scmd
n164=..$iif($aopper.rmenu(svcs),$style(1) $+,$null $+) Operserv Mode: aopper.set svcs
n165=..-
n166=..$iif($aopper.rmenu(off),$style(1) $+,$null $+) Switch Off: aopper.set off
n167=..-
n168=..What is Self-AOP?: aopper.details
n169=-
n170=$pnln $iif(!$idf,Identify with Nickserv,User Account Options)
n171=.$pnln Identify as $me $+ : {
n172=  if (r !isin $usermode) { id $$quik.d(pdoubled,incorrigo syx $pipe nickserv identify¿Enter account password for $me $+ :) }
n173=  else { rawbak.d words incorrigo syx $pipe identify nickname¿You are already identified as $me and don't need to log in }
n174=}
n175=.$iif(!$idf,Create New Account,$null): {
n176=  register $$decision(qpgb¿incorrigo syx $pipe new account¿Enter account password: $+ $crlf $crlf $+ [no one else will ever have access to this password]) $$decision(qegb¿incorrigo syx $pipe new account¿Enter your email address: $+ $crlf $crlf $+ [required for account verification])
n177=}
n178=.-
n179=.$pnln $iif($getuserID != $null && $getuserID != $me,Use Account Nickname - $getuserID,$null): { nick $getuserID }
n180=.$pnln $iif(!$idf,User Account Login,Log out From $getuserID) $+ : {
n181=  if (!$idf) { nickserv identify $$decision(qeg¿incorrigo syx $pipe user account login¿Enter account name:) $$decision(qpg¿incorrigo syx $pipe user account login¿Enter account password:) }
n182=  else { nickserv logout }
n183=}
n184=.$pnln $iif($idf && !$idfr,Register $me to $getuserID Account,$null) $+ : nickserv group $getuserID
n185=.$pnln $iif(!$idf && !$idfr,Add $me to an Existing Account,$null) $+ : nickserv group $$decision(ebgoq¿incorrigo syx $pipe group nickname¿Enter your account name:) $$decision(pbgoq¿incorrigo syx $pipe group nickname¿Enter account password:)
n186=.$pnln $iif(!$idf,Recover Registered Nickname,$null): nickserv RECOVER $$decision(qbego¿incorrigo syx $pipe nickname recovery¿Enter registered nickname to recover:) $$decision(qbpgo¿incorrigo syx $pipe login to nickname¿Enter account password:)
n187=.-
n188=.User Account Options Explained: text-reader incorrigo-syx\docu-mental\account-login.tr Understanding User Account Options
n189=$$iif(!$idfr,$null,Hostserv Menu)
n190=.Switch On: hostserv on
n191=.Switch Off: hostserv off
n192=.-
n193=.Request vHost: {
n194=  if (!$idfr) { return $$decision(hugob¿incorrigo syx $pipe hostserv error¿You get a vHost per-nickname that you have registered $+ $crlf $crlf $+ To request a vHost you need to be identified to nickserv as one of your registered nicknames) }
n195=  else { %main.hsr = $$quik.d(doubled,incorrigo syx $pipe make vhost request¿Enter a vhost / user@vhost request:) }
n196=  if ($left(%main.hsr,3) == lH-) {
n197=    hostserv request %main.hsr
n198=  }
n199=  else { hostserv request $lHngen $+ . $+ %main.hsr }
n200=}
n201=.Generate lH Number: lhnumber
n202=.-
n203=.About Hostserv / vHost: noop $decision(og¿incorrigo syx $pipe about vHost¿When you have a registered nickname $+ $c you can request a vHost from hostserv $+ $crlf $crlf $+ A vHost is a vanity hostname that lets your hostname / ip address be anything you want. When it is activated $+ $c it is automatically applied when you identify for that nickname $+ $crlf $crlf $+ You can have a different vHost for each nickname. You can register multiple nicknames under one account using the nickserv GROUP command)
n204=.What is lH number?: text-reader incorrigo-syx\docu-mental\understanding-vhost.tr Understanding vHost and lH numbers
n205=$iif(!$idf,$null,(Re)gain Channel Access)
n206=.Remove Matching Bans: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv unban %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n207=.Invitation Requirements: { %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker lock add +I ~a: $+ $me | chanserv invite %cserv.wanker | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker } }
n208=.Channel Key Setting [+k]
n209=..Get Current Key: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv getkey %cserv.wanker
n210=..Remove Key: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -k wanker | if ($me !ison 5cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n211=.Channel Limit Derestriction [+l]: %cserv.wanker = $$decision(eg¿incorrigo syx $pipe services assistance¿Enter channel name of target:) | chanserv mode %cserv.wanker set -l | if ($me !ison %cserv.wanker) { .timer -m 1 250 join %cserv.wanker }
n212=.-
n213=.What is this?: explain 'Regain Channel Access' is for channel owner / operator who has ended up being unable to join their own channel $+ $crlf $crlf $+ Obviously this couldn't be used to regain access to just any channel $+ $c you would need permission from chanserv first
n214=-
n215=Local Time Format
n216=.$timewy(1) Very Long Date && Time: { %ctcp.timeformat = 1 | echo -atc Info * Local Time: $gettime }
n217=.$timewy(2) Long Date && Time: { %ctcp.timeformat = 2 | echo -atc Info * Local Time: $gettime }
n218=.$timewy(3) Local Time Only: { %ctcp.timeformat = 3 | echo -atc Info * Local Time: $gettime }
n219=.$timewy(4) Brief Time && Date: { %ctcp.timeformat = 4 | echo -atc Info * Local Time: $gettime }
n220=.$timewy(5) Time of Day && Date: { %ctcp.timeformat = 5 | echo -atc Info * Local Time: $gettime }
n221=Check Menu Visibility
n222=.$style(2) $+ Channel Half Operator: noop
n223=.$style(2) $+ Channel Operator: noop
n224=.$iif($idf == $true,$style(1),$null) $+ User Account Login: noop $decision(go¿incorrigo syx $pipe menu visibility¿When you log in to your account $+ $c services menus will appear $+ $crlf $crlf $+ If you don't have permission to use a particular command $+ $c it won't work $+ $crlf $crlf $+ However if you do have permissions $+ $c you don't need to be a channel operator in order to use them)
n225=.$iif($idfr == $true,$style(1),$null) $+ Using Registered Nickname: noop $decision(go¿incorrigo syx $pipe menu visibility¿You will stay logged into your account if you change your nickname $+ $crlf $crlf $+ Using one of your registered nicknames is not so different from being logged in)
n226=.$iif($sysop,$style(1),$null) $+ Network Engineer: noop $decision(tgo¿incorrigo syx $pipe menu visibility¿A successful IRC operator login will show all of the controls and some oper-only ones)

[qpopup]
n0=--> $$1: whois $$1 $$1
n1=-
n2=Nickserv Account Info: .nickserv info $$1
n3=$iif($ignore($address($$1, 2)),$style(1) $+ Active Ignores For,Ignore) $$1
n4=.Ignore $$1: .ignore $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  ...
n5=.-
n6=.Temporary Ignore
n7=..For 30 Seconds: .ignore -u30 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 30 seconds
n8=..For 60 Seconds: .ignore -u60 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 60 seconds
n9=..For 2 minutes: .ignore -u120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 2 minutes
n10=..For 4 minutes: .ignore -u240 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 4 minutes
n11=..For 8 minutes: .ignore -u480 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 8 minutes
n12=..For 16 minutes: .ignore -u960 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 16 minutes
n13=..For 32 minutes: .ignore -u1920 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 32 minutes
n14=..For an hour: .ignore -u3840 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 hour
n15=..For a day: .ignore -u92160 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 day 
n16=..For a week: .ignore -u645120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 week 
n17=.Ignore Private Things
n18=..All Text / Requests: .ignore -pcntidhy $$1 2 | echo -atc Info2 * Ignore: Ignoring $$1 Private messages & requests
n19=..-
n20=..For 30 Seconds: .ignore -pcntidhyu30 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 30 seconds
n21=..For 60 Seconds: .ignore -pcntidhyu60 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 60 seconds
n22=..For 2 minutes: .ignore -pcntidhyu120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 2 minutes
n23=..For 4 minutes: .ignore -pcntidhyu240 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 4 minutes
n24=..For 8 minutes: .ignore -pcntidhyu480 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 8 minutes
n25=..For 16 minutes: .ignore -pcntidhyu960 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 16 minutes
n26=..For 32 minutes: .ignore -pcntidhyu1920 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 32 minutes
n27=..For an hour: ignore -pcntidhyu3840 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 hour
n28=..For a day: ignore -pcntidhyu92160 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 day 
n29=..For a week: ignore -pcntidhyu645120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 1 week 
n30=.-
n31=.Stop Ignoring $$1: .ignore -r $$1 2 | echo -atc Info2 * Ignore: No longer ignoring  $+ $$1 $+ 
n32=-
n33=Set Private User Modes
n34=.Private User [p]
n35=..+p: mode $me +p
n36=..-p: mode $me -p
n37=..-
n38=..What is this?: explain Setting mode [+p] will hide all channels you are in from your --> whois response
n39=.Censor Profanity [G]
n40=..+G: mode $me +G
n41=..-G: mode $me -G
n42=..-
n43=..What is this?: explain User mode [G] will replace vulgar words or profanity from the network's profanity list
n44=.Private Messages by Registered Users Only [R]
n45=..+R: mode $me +R
n46=..-R: mode $me -R
n47=..-
n48=..What is this?: explain Setting more [R] will receive private messages from people logged into a user account only
n49=.No CTCP Requests [T]
n50=..+T: mode $me +T
n51=..-T: mode $me -T
n52=..-
n53=..What is this?: explain When more [T] is in place, all CTCP requests are denied. But this means you won't be able to send them either
n54=.Secure Clients Only [Z]
n55=..+Z: mode $me +Z
n56=..-Z: mode $me -Z
n57=..-
n58=..What is this?: explain User mode [Z] means you won't receive messages from plaintext [not securely connected] users
n59=-
n60=CTCP(X) Request
n61=.Ping: echo -tac CTCP * Requestions $$1 $+ 's ping [network latency] ... | .ctcp $$1 PING
n62=.Version: echo -tac CTCP * Requesting $$1 $+ 's version ... | .ctcp $$1 VERSION
n63=.Time: echo -tac CTCP * Requesting $$1 $+ 's local time ... | .ctcp $$1 TIME
n64=.Finger: echo -tac CTCP * Requesting $$1 $+ 's finger ... | .ctcp $$1 FINGER
n65=.-
n66=.Friendly Name: ctcp-x $$1 NAME
n67=.Ident / Email: ctcp-x $$1 EMAIL
n68=.IRC Client: ctcp-x $$1 VERSION
n69=.Script: ctcp-x $$1 SCRIPT
n70=.Local Time: ctcp-x $$1 TIME
n71=.Idle Time: ctcp-x $$1 IDLE
n72=.Website: ctcp-x $$1 URL
n73=.-
n74=.Custom Request: .ctcp $$1 $$decision(eugo¿incorrigo syx $pipe ctcp request¿Enter CTCP request:) | echo -tac CTCP * Sent $$1 client request ...
n75=.What is CTCP?: noop $decision(iugo¿incorrigo syx $pipe ctcp requests¿CTCP stands for "client to client protocol" $+ $crlf $crlf $+ It is a way that a client [app you are using] asks for information from another user's client that is not messaging related)
n76=DCC Actions
n77=.Send File: dcc send $$1
n78=.Direct Chat: dcc chat $$1
n79=.DCC Allow
n80=..Add: dccallow + $+ $$1
n81=..Delete: dccallow - $+ $$1
n82=..-
n83=..What is DCC Allow?: noop $$decision(iog¿incorrigo syx $pipe dcc allow¿Some file types are blocked from being sent by the server $+ $c because they could be malicious software $+ $crlf $crlf $+ To allow someone to send you a blocked file $+ $c you must add them to your DCC allow list. $+ $crlf $crkf $+ Once you have added someone $+ $c they will need to send whatever was blocked once again $+ $c if it was previously blocked
n84=.Trusted User
n85=..Trust $$1: dcc-entrust $$1
n86=..Trust $address($$1, 4): dcc-entrust $address($$1, 4)
n87=..Trust $address($$1, 2): dcc-entrust $address($$1, 2)
n88=..-
n89=..-
n90=..Detrust $$1: dcc-detrust $$1
n91=..Detrust $address($$1, 4): dcc-detrust $address($$1, 4)
n92=..Detrust $address($$1, 2): dcc-detrust $address($$1, 2)
n93=..What is trust?: noop $$decision(oi¿incorrigo syx $pipe dcc trust list¿When you add someone to your DCC trust list $+ $c you will automatically accept their files and chat requests $+ $crlf $crlf $+ You can add someone by their vHost / cloaked hostname and it will still work $+ $crlf $crlf $+ Your trust list is part of mIRC and will still apply between IRC sessions))
n94=.-
n95=.What are these?: text-reader incorrigo-syx\docu-mental\about-dcc.tr Direct Client to Client-
n96=Close This Conversation: {
n97=  say auto message: i'm closing this conversation now. goodbye
n98=  close -cm $$1
n99=}

[lpopup]
n0=--> $$1: whois $$1 $1
n1=User Account Info: nickserv info $$1
n2=Whisper: notice $$1 $$decision(eg¿incorrigo syx $pipe whisper¿Private message to send $$1 $+ :)
n3=Private Conversation: query $$1
n4=-
n5=Notify List
n6=.Add $$1
n7=..Use Nickname: notify $$1
n8=..Use Address: notify $address($$1, 2)
n9=.Remove $$1
n10=..Remove Nickname: notify -r $$1
n11=..Use Address: notify -r $address($$1, 2)
n12=$iif($ignore($address($$1, 2)),$style(1) $+ Active Ignores for,Ignore) $$1
n13=.Ignore $$1: .ignore $$1 2 | echo -atc Info2 * Ignore: Everything that comes from $address($$1, 2) [ $+ $1 $+ ] is now ignored
n14=.Partial Ignore
n15=..Private Messages and Requests: .ignore -pidhy $$1 2 | echo -atc Info2 * Ignore: Private Messages and Requests from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] are now being ignored
n16=..Invitations to Join Channels: .ignore -i $$1 2 | echo -atc Info2 * Ignore: Invitations to Join Channels from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] are now being ignored
n17=..Strip Message Formatting Codes: .ignore -k $$1 2 | echo -atc Info2 * Ignore: Colour / Text Formatting Codes from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will be stripped
n18=..Matched Highlight List Triggers: .ignore -sh $$1 2 | echo -atc Info2 * Ignore: Matching entries on your highlight list from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will no longer be triggered
n19=..Highlights and Pop-up As Well: .ignore -shy $$1 2 | echo -atc Info2 * Ignore: Pop-ups as well as highlights from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will no longer be triggered
n20=..File / Direct Chat [DCC] Requests: .ignore -d $$1 2 | echo -atc Info2 * Ignore: Direct connection file / chat requests from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will now be disregarded
n21=..CTCP Requests: .ignore -t $$1 2 | echo -atc Info2 * Ignore: CTCP Requests from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will no longer trigger replies
n22=..Notices / Formatting Codes: .ignore -nkh $$1 2 | echo -atc Info2 * Ignore: Notice messages / Text formatting from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will now be stripped
n23=..All Except Private Messages: .ignore -cnt $$1 2 | echo -atc Info2 * Ignore: All channel / CTCP / notice messages - except private messages from $address($$1, 2)  $+ $chr(91) $+  $+ $1 $+ ] will no longer be displayed
n24=..-
n25=..What is this?: .timer -m 1 150 noop $decision(og¿incorrigo syx $pipe ignore switches¿Partial ignore gives you the option to include someone in your session but at the same time relieve yourself of unwanted private messages / requests etc. $next Direct file transfers / chat requests will _share your real IP address / host name_! if you accept. You can use this menu to block such requests so you can avoid inadvertently choosing that $next NB: Choosing one of these settings will replace any other [even if you are ignoring $$1 completely] that is currently set)
n26=.Temporarily Ignore
n27=..For 30 Seconds: .ignore -u30 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 30 seconds
n28=..For 60 Seconds: .ignore -u60 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 60 seconds
n29=..For 2 minutes: .ignore -u120 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 2 minutes
n30=..For 4 minutes: .ignore -u240 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 4 minutes
n31=..For 8 minutes: .ignore -u480 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 8 minutes
n32=..For 16 minutes: .ignore -u960 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 16 minutes
n33=..For 32 minutes: .ignore -u1920 $$1 2 | echo -atc Info2 * Ignore: Ignoring  $+ $$1 $+  for 32 minutes
n34=.Silence $$1
n35=..Add Silence: .silence $address($$1, 2)
n36=..Unsilence: .silence - $+ $address($$1, 2)
n37=..-
n38=..What is silence?: noop $decision(quoy¿incorrigo syx $pipe silence for session¿Silence is a special type of ignore that blocks someone at the server level. An ignore continues for as long as you want, but a silence only lasts until you disconnect from the server $next Because it's easy to change your nickname $+ $c silence is added for the user's address instead)
n39=.-
n40=.Stop Ignoring $$1: .ignore -r $$1 2 | echo -atc Info2 * Ignore: All ignored activities and requests from  $+ $$1 $+   $+ $chr(91) $+  $+ $address($$1, 2) $+  $+ $chr(93) $+  have been removed from your ignore list
n41=-
n42=CTCP(X) Request
n43=.Ping: echo -tac CTCP * Requestions $$1 $+ 's ping [network latency] ... | .ctcp $$1 PING
n44=.Version: echo -tac CTCP * Requesting $$1 $+ 's version ... | .ctcp $$1 VERSION
n45=.Time: echo -tac CTCP * Requesting $$1 $+ 's local time ... | .ctcp $$1 TIME
n46=.Finger: echo -tac CTCP * Requesting $$1 $+ 's finger ... | .ctcp $$1 FINGER
n47=.-
n48=.Friendly Name: ctcp-x $$1 NAME
n49=.Ident / Email: ctcp-x $$1 EMAIL
n50=.IRC Client: ctcp-x $$1 VERSION
n51=.Script: ctcp-x $$1 SCRIPT
n52=.Local Time: ctcp-x $$1 TIME
n53=.Idle Time: ctcp-x $$1 IDLE
n54=.Website: ctcp-x $$1 URL
n55=.-
n56=.Custom Request: .ctcp $$1 $$decision(eugo¿incorrigo syx $pipe ctcp request¿Enter CTCP request:) | echo -tac CTCP * Sent $$1 client request ...
n57=.What is CTCP?: noop $decision(iugo¿incorrigo syx $pipe ctcp requests¿CTCP stands for "client to client protocol" $next It is a way that a client [app you are using] asks for information from another user's client that is not messaging related)
n58=.-
n59=.Nickname Colours: text-reader incorrigo-syx\docu-mental\nick-colours.tr Nickname Colours Explained [Default Colour Profile]
n60=DCC Actions
n61=.Send File: dcc send $$1
n62=.Direct Chat: dcc chat $$1
n63=.DCC Allow
n64=..Add: dccallow + $+ $$1
n65=..Delete: dccallow - $+ $$1
n66=..-
n67=..What is DCC Allow?: noop $$decision(iog¿incorrigo syx $pipe dcc allow¿Some files are an obvious security risk to you and they will be blocked $next To send such files $+ $c the recipient must add the sender to their DCCALLOW list $next If a file has been blocked before the DCCALLOW $+ $c it will need to be sent again)
n68=.Trusted User
n69=..Trust $$1: dcc-entrust $$1
n70=..Trust $address($$1, 4): dcc-entrust $address($$1, 4)
n71=..Trust $address($$1, 2): dcc-entrust $address($$1, 2)
n72=..-
n73=..-
n74=..Detrust $$1: dcc-detrust $$1
n75=..Detrust $address($$1, 4): dcc-detrust $address($$1, 4)
n76=..Detrust $address($$1, 2): dcc-detrust $address($$1, 2)
n77=..What is trust?: noop $$decision(oi¿incorrigo syx $pipe dcc trust list¿Adding someone to your DCC trust list means you are completely alright with them and will accept anything that they send your way $next If anyone matches an entry in this list $+ $c their files and chats will be automatically accepted and start sending to you)
n78=.-
n79=.What are these?: text-reader incorrigo-syx\docu-mental\about-dcc.tr Direct Client to Client
n80=-
n81=$iif(o isin $usermode,Network Engineer,$null)
n82=.SA Commands
n83=..SAJOIN $$1 $+ : sajoin $$1 $$decision(teg¿incorrigo syx $pipe sajoin¿Enter channel name to send $$1 $+ :)
n84=..SAPART $$1 From #: if ($$decision(vty¿incorrigo syx $pipe sapart¿Are you sure you want $$1 to leave #) == $yes $+ ) { sapart $$1 # }
n85=.Change User Info
n86=..Change Ident: chgident $$1 $$decision(qeg¿incorrigo syx $pipe change username¿Enter new username:)
n87=..Change Hostname: chghost $$1 $lHngen $+ . $+ $$decision(qeg¿incorrigo syx $pipe change hostname¿Enter new hostname / visible address:)
n88=..Change 'Real Name': chgname $$1 $$decision(qeg¿incorrigo syx $pipe change gecos¿Enter new Friendly Name: $next [You are under no obligation to use your real name])
n89=.-
n90=.$idfc Services Operator
n91=...Server Only Commands
n92=....SVSJOIN: operserv svsjoin $$1 $$decision(egb¿incorrigo syx $pipe svsjoin¿What channel should $$1 join?)
n93=....SVSNICK: operserv svsnick $$1 $$decision(egb¿incorrigo syx $pipe svsjoin¿What nickname do you want $$1 to be?)
n94=....SVSPART: operserv svspart # $$decision(egb¿incorrigo syx $pipe svsjoin¿Why are you making $$1 leave # $+ ?)
n95=..Forbid Nickname $$1
n96=...10 minutes: operserv forbid add nick +10m $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $next [ $+ $$1 will be renamed to a guest nickname $+ ])
n97=...An hour: operserv forbid add nick +1h $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $next [ $+ $$1 will be renamed to a guest nickname $+ ])
n98=...A day: operserv forbid add nick +1d $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $next [ $+ $$1 will be renamed to a guest nickname $+ ])
n99=...A week: operserv forbid add nick +1w $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $next [ $+ $$1 will be renamed to a guest nickname $+ ])
n100=...A Month: operserv forbid add nick +28d $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname forbidden? $next [ $+ $$1 will be renamed to a guest nickname $+ ])
n101=...Permanently: forbid add nick +0 $$1 $$decision(egb¿incorrigo syx $pipe forbid $$1 $+ ¿Why are you making this nickname permanently forbidden? $next [ $+ $$1 will be renamed to a guest nickname $+ ])
n102=..Oper Info
n103=...Add Operator Info: operserv info add $$1 $$decision(qeg¿incorrigo syx $pipe oper info line¿Enter oper notes line:)
n104=...Delete Info Line: operserv info del $$1 $$decision(Type the info that needs to be removed for some reason:)
n105=...-
n106=...What is this?: explain Extra information can be added by services operators that will show up on the /NICKSERV INFO command $next Only services operators can see this information who have the right operserv privileges
n107=..-
n108=..Services Kick: operserv kick # $$1 $$decision(egb¿incorrigo syx $pipe kill $$1 $+ ¿Enter kick reason / message:)
n109=..Set User Modes: operserv umode $$1 $$decision(egb¿incorrigo syx $pipe svsjoin¿Enter user mode to set on $$1 $next $chr(91) $+ you should use + / - $+ $chr(93))
n110=..Kill: operserv kill $$1 $$decision(egb¿incorrigo syx $pipe kill $$1 $+ ¿Why is $$1 $+ 's connection being closed?)
n111=$iif($wzy(#) != $null,$null,Give / Take Permissions)
n112=.$wdy(#) $+ Owner [~]
n113=..+ Owner: mode # +q $$1
n114=..- Owner: mode # -q $$1
n115=.$wdy(#) $+ Chan. Admin [&&]
n116=..+ Admin: mode # +a $$1
n117=..- Admin: mode # -a $$1
n118=.$wdy(#) $+ Chan. Operator [@]
n119=..+ Operator: mode # +o $$1
n120=..- Operator: mode # -o $$1
n121=.$wdy(#) $+ Half-Op $chr(91) $+ $eval(%,0) $+ $chr(93)
n122=..+ Half-Op: mode # +h $$1
n123=..- Half-Op: mode # -h $$1
n124=.Voice [+]
n125=..+ Voice: mode # +v $$1
n126=..- Voice: mode # -v $$1
n127=.-
n128=.$wdy(#) $+ Remove All Permissions: mode # -qaohv $$1 $1 $1 $1 $1
n129=.-
n130=.Permissions Explained: text-reader incorrigo-syx\docu-mental\statusmodes.tr Different Channel Permission Levels
n131=$iif($wzy(#) != $null,$null,Kick && Ban)
n132=.Quiet $$1: mode # +b ~q: $+ $address($$1, 2)
n133=.Unquiet $$1: mode # -b ~q: $+ $address($$1, 2)
n134=..-
n135=.Kick: kick # $$1 [unspecified]
n136=.Kick (why): kick # $$1 $$decision(vquge¿incorrigo syx $pipe kick $$1¿Enter kick reason:)
n137=.-
n138=.Ban: mode # +b $address($$1, 2)
n139=.Kick and Ban: {
n140=  .timer -m 1 500 kick # $$1 $$decision(vquge¿incorrigo syx $pipe kick $$1¿Why are you banning $$1 $+ ?)
n141=  .timer -m 1 1 mode # +b $address($$1,2)
n142=}
n143=.Temporary Ban: {
n144=  var %tban.duration $decision(vquge¿incorrigo syx $pipe temporary ban $$1¿How long $obk $+ minutes $+ $cbk do you wish to ban $$1 $+ ?)
n145=  var %tban.reason $$decision(vquge¿incorrigo syx $pipe kick $$1¿Why are you temporarily banning $$1 $+ ?)
n146=  .timer -m 1 500 kick # $$1 %tban.reason
n147=  .timer -m 1 1 mode # +b ~t: $+ %tban.duration $+ : $+ $address($$1,2)
n148=}
n149=.Unban: mode # -b $address($$1, 2)
n150=.-
n151=.Except Hostname: mode # +e $address($$1, 2)
n152=.Remove Exception: mode # -e $address($$1, 2)
n153=$iif($sysop,Kill && Network Ban Menu,$null)
n154=.Kill $$1: kill $$1 $$decision(tegb¿incorrigo syx $pipe kill $$1 $+ ¿Why are you banning $$1 $+ ?)
n155=.-
n156=.Set G Line
n157=..Temporary: {
n158=  var %gline.td $$decision(tegb¿incorrigo syx $pipe set g-line¿Enter duration parameter:)
n159=  var %gline.rs $$decision(tegb¿incorrigo syx $pipe set g-line¿Why are you banning $$1 $+ ?)
n160=  gline $$1 %gline.td banned: %gline.rs
n161=}
n162=..Permanent: {
n163=  var %gline.rs $$decision(tegb¿incorrigo syx $pipe set g-line¿Why are you banning $$1 $+ ?)
n164=  gline $$1 0 banned: %gline.rs
n165=}
n166=..-
n167=..Remove G Line: gline - $+ $$1
n168=.Set Z Line
n169=..Temporary: {
n170=  var %gzline.td $$decision(tegb¿incorrigo syx $pipe set g-zline¿Enter duration parameter:)
n171=  var %gzline.rs $$decision(tegb¿incorrigo syx $pipe set g-zline¿Why are you banning $$1 $+ ? $next [reason will not be shown on (re)connect attempt])
n172=  gzline $$1 %gzline.td banned: %gzline.rs
n173=}
n174=..Permanent: {
n175=  var %gzline.rs $$decision(tegb¿incorrigo syx $pipe set g-zline¿Why are you banning $$1 $+ ? $next [reason will not be shown on (re)connect attempt])
n176=  gzline $$1 0 banned: %gzline.rs
n177=}
n178=..-
n179=..Remove Global Z-Line: gzline - $+ $$1
n180=.Create Exception
n181=..Temporary: {
n182=  var %eline.td $$decision(tegb¿incorrigo syx $pipe set g-line¿How long should this exception remain in place?)
n183=  var %eline.rs $$decision(tegb¿incorrigo syx $pipe set g-line¿What reason is  $$1 $+ ?)
n184=  eline $$1 kGzZs %eline.td exception: %eline.rs
n185=}
n186=..Permanent: {
n187=  var %eline.rs $$decision(tegb¿incorrigo syx $pipe set exception¿Enter exception remarks for $$1 $+ ?)
n188=  eline $$1 kGzZs 0 exception: %eline.rs
n189=}
n190=..-
n191=..Extended Exceptions
n192=...Add User Account: eline ~a: $+ $$1 kGs 0 exception: account is exempt from network bans
n193=...Del User Acount: eline -~a: $+ $$1
n194=..-
n195=..Remove Exceptions: eline - $+ $$1
n196=.-
n197=.Important Information: text-reader incorrigo-syx\docu-mental\x-lines.tr Network Engineer's Notes About Kill and X-Lines
n198=$iif($wzy(#) != $null,$null,Extended Ban / Except)
n199=.Target $chr(91) $+ $extc.mode($$1) $+ $chr(93) Toggle: extc.toggle
n200=.-
n201=.Extended Ban
n202=..Quiet User: extc.setquiet # $$1
n203=..Forward to Channel: extc.forwardtochannel # $$1
n204=..No Nick Change: extc.setnonick # $$1
n205=..Block /join: extc.setnojoin # $$1
n206=..-
n207=..Remove Extended Bans: extc.unban # $$1
n208=.Extended Exemptions
n209=..Moderated Mode: extc.exempt.m # $$1
n210=..External Messages: extc.exempt.n # $$1
n211=..Colour && Control Codes: extc.exempt.c # $$1
n212=..Channel Notices: extc.exempt.p # $$1
n213=..-
n214=..Remove Exemptions: extc.dexempt # $$1
n215=.Target Types: noop $$decision(iuog¿incorrigo syx $pipe toggle ban target¿There are two different types of ban target ... $+ $crlf ~account: $+ $$1 $+ $crlf ... or $address($$1, 2) $next One targets the account of $$1 ... which is only useful if the user is logged into an account. $crlf $crlf $+ The other targets their address, which will apply no matter what $+ $c but need to be banned again when their IP / host address changes)
n216=-
n217=$iif(!$idf,$null,Access List)
n218=.Don't Kick on Join: access # add $$1 nokick
n219=.Add Voice [+]: access # add $$1 autovoice
n220=.Add Half-Op [%]: access # add $$1 halfopme
n221=.Add Operator [@]: access # add $$1 autoop
n222=.Add Channel Admin [&&]: access # add $$1 autoprotect
n223=.Add Owner [~]: access # add $$1 autoowner
n224=.Maximum Level: access # add $$1 10000
n225=.-
n226=.Remove $$1 From Access List: access # del $$1
n227=$iif(!$idf,$null,Chanserv Controls)
n228=.Channel Permissions
n229=..UP: chanserv up # $$1
n230=..DOWN: chanserv down # $$1
n231=..-
n232=..OWNER:
n233=...Make Owner: chanserv owner # $$1
n234=...Take Owner: chanserv deowner # $$1
n235=..PROTECT
n236=...Channel Admin: chanserv protect # $$1
n237=...Remove Admin: chanserv deprotect # $$1
n238=..OP
n239=...Channel Operator: chanserv op # $$1
n240=...Remove Ops: chanserv deop # $$1
n241=..HALFOP
n242=...Half-Op: chanserv halfop # $$1
n243=...De-Half Op: chanserv dehalfop # $$1
n244=..VOICE
n245=...Voice: chanserv voice # $$1
n246=...Devoice: chanserv devoice # $$1
n247=.Kick && Ban
n248=..Permanent Ban: chanserv ban # +0 $$1 $$decision(qeg¿incorrigo syx $pipe services ban¿Why are you permanently banning $$1 $+ ?)
n249=..Temporary Ban: chanserv ban # + $+ $$decision(egq¿incorrigo syx $pipe services ban¿How long are you banning $$1 $+ ? $next e.g. 20m / 12h / 3d etc:) $$1 $$decision(egq¿incorrigo syx $pipe services ban¿Why are you banning $$1 ?)
n250=..-
n251=..Remove All Matching Bans: chanserv unban # $$1
n252=.AKick $$1
n253=..AKick $$1: {
n254=  set -e %akick.reason $$decision(qegb¿incorrigo syx $pipe auto-kick¿Enter reason for a-kick:)
n255=  chanserv akick # add $$1
n256=}
n257=..Delete AKick for $$1: chanserv akick # del $$1
n258=.About Services Control: noop $decision(iog¿incorrigo syx $pipe chanserv user controls¿You can control a user that's on your channel if you're logged into an account with access $next You do not have to be a channel operator to use your chanserv powers)
