;; INCORRIGO SYX SYSTEMS
;; ALIASES / COMMANDS

;; use - //msg # good $timeofdaynow !
timeofdaynow {
  set %timeofday day to you
  if ($time(t) == a) { set %timeofday morning }
  else if ($time(t) == p) {
    if ($time(HH) >= 17) { set %timeofday evening }
    else { set %timeofday afternoon }
  }
  return %timeofday
}

endofyear {
  var %newyear $ctime($calc($asctime(yyyy) + 1) $+ /01/01 00:00:00)
  return $duration($calc(%newyear - $ctime))
}

;; light / dark mode
golight {
  echo -atc Info2 * display: theme setting changed to light mode (original)
  %dark.mode = $false
}

godark {
  echo -atc Info2 * display: theme setting changed to dark mode (dark)
  %dark.mode = $true
}

goauto {
  echo -atc Info2 * display: theme set to auto update (windows setting)
  %dark.mode = auto
}
;; non-darkmode OS returns $false

dark.mode {
  if (%dark.mode == $null) {
    %dark.mode = auto
  }

  return %dark.mode
}

checkdark {
  ;; force dark mode (new incorrigo syx dark) theme
  if ($dark.mode == $true) {
    color -s Incorrigo-Syx-DARK
    halt
  }

  ;; force light mode (original) theme
  if ($dark.mode == $false) {
    color -s Incorrigo-Syx-LT
    halt
  }

  ;; auto change light/dark colour when windows does
  if ($dark.mode == auto) {
    color -s $iif($darkmode == $true, Incorrigo-Syx-DARK, Incorrigo-Syx-LT)
  }
}

lineshading {
  ronnik linesh $readini(mirc.ini, options, n0)
  if ($gettok($ironnik(linesh), 36, 44) == 1) {
    return $true
  }

  return $false
}

gettime {
  if (!%ctcp.timeformat || %ctcp.timeformat !isnum 1-5) {
    %ctcp.timeformat = 2
  }

  if (%ctcp.timeformat == 1) {
    return [ $+ $asctime(dddd) $+ $c $asctime(doo) of $asctime(mmmm) $asctime(yyyy) $+ ] [ $+ $asctime(HH:nnTT) - GMT $asctime(z) $+ ] [ $+ $asctime(dddd) $timeofdaynow $+ ] [ $+ $asctime(yyyy-mm-dd) $+ ]
  }

  if (%ctcp.timeformat == 2) {
    return [ $+ $asctime(dddd) $+ $c $asctime(doo) of $asctime(mmmm) $asctime(yyyy) $+ ] [ $+ $asctime(HH:nnTT) - GMT $asctime(z) $+ ]
  }

  if (%ctcp.timeformat == 3) {
    return $asctime(HH:nnTT) - GMT $asctime(z)
  }

  if (%ctcp.timeformat == 4) {
    return $asctime(HH:nnTT) $asctime(yyyy-mm-dd)
  }

  if (%ctcp.timeformat == 5) {
    return $asctime(dddd) $timeofdaynow $asctime(yyyy-mm-dd)
  }

  return Time format violation: %ctcp.timeformat
}

ronnik {
  set -e % [ $+ [ $server ] $+ . $+ [ $me ] $+ . $+ [ $$1 ] ] [ [ $2- ] ]
}

xronnik {
  unset % [ $+ [ $server ] $+ . $+ [ $me ] $+ . $+ [ $1 ] ]
}

ironnik {
  return % [ $+ [ $server ] $+ . $+ [ $me ] $+ . $+ [ $1 ] ]
}

timewy {
  if ($timeformat == $$1) {
    return $style(1) $+
  }

  else return $null $+
}

timetf {
  if ($timeformat == $$1) {
    return $true
  }

  else return $false
}

aopper {
  if ($group(aopper).status == on) {
    return $true
  }

  else return $false
}

aopper.svcs {
  if ($aopper) {
    if ($group(svcsaop).status == on) {
      return $true
    }

    else return $false
  }
}

aopper.scmd {
  if ($aopper) {
    if ($group(svcsaop).status == on) {
      return $true
    }

    else return $false
  }
}

aopper.csvc {
  if ($aopper) {
    if ($group(svcsaop).status == on) {
      return $true
    }

    else return $false
  }
}

aopper.self {
  if ($aopper) {
    if ($group(svcsaop).status == on) {
      return $true
    }

    else return $false
  }
}

aopper.details {
  noop $decision(ugoÂ¿incorrigo syx $pipe self-aop informationÂ¿Self-AOP is a function that gives you elevated permissions automatically when you join a channel $+ $crlf $crlf $+ $&
    This feature will only be displayed / trigger on-join if you are an IRC operator $+ $crlf $crlf $+ $&
    You can set from voice - owner. Giving yourself owner in other people's channels is not recommended $+ $crlf $crlf $+ $&
    The method it uses is self (override), chanserv (registered channels only), operserv mode command, or /SAMODE to the server. By default it is set to "off" so it doesn't do anything unexpected until you have changed the settings)
}

;; CODEFIELDS SWAY LAZILY
lhnumber {
  ;; network specific quirk
  echo -atc Own *** lH Numbers and lH hex numbers [more realistic]
  echo -atc Own * lH Numbers: $lHngen $lHngen $lHngen Hex: $lHxgen $lHxgen $lHxgen
  echo -atc Own * lH Numbers: $lHngen $lHngen $lHngen Hex: $lHxgen $lHxgen $lHxgen
  echo -atc Own * lH Numbers: $lHngen $lHngen $lHngen Hex: $lHxgen $lHxgen $lHxgen
}

thematrix {
  ;; debug window you can type commands into
  window -ae[0] @the.matrix
  .debug @the.matrix
  echo -tc Info @the.matrix Debug: All
}

spreadtheword {
  msg $$1 14,1incorrigo15,1syx - text based virtual world - a new nonpartisan IRC network: 13https://incorrigo.io 12ircs://irc.incorrigo.io/
}

sysop {
  if (o isincs $usermode) { return $true }
  else return $false
}

changeposition {
  mode $$1 -qaohv $$2 $$2 $$2 $$2 $$2
  %modechg = +
  if ($$3 == top) {
    %modechg = %modechg $+ oq
  }
}

fatseagal {
  ;; light a fat one
  msg $$1  0,7:.` ,:;0,0;::1,0TEST CIGARETTE0,0::::::4,1:4,1;`15~~~~~~
}

getit {
  if ($nick($$1, $$2, ~) {
    return q
  }

  if $nick($$1, $$2.
}

cF12 {
  exit -rn
}

F5 {
  if ($ironnik(knock.channel) != $null) {
    if ($ironnik(knock.knick) != $null) {
      invite $ironnik(knock.knick) $ironnik(knock.channel)
    }
  }
}

;; lH- NGEN
lHngen {
  ;; generate a single lH number
  %lH.look = lH-
  :k0ng
  %lH.hook = $r(0,1)
  if (%lH.hook) { goto middle }
  :top
  %lH.line = $r(0,9)
  goto bottom
  :middle
  %lH.sink = $r(A,Z)
  :bottom
  %lH.look = %lH.look $+ $iif(%lH.hook,%lH.sink,%lH.line)
  if ($len(%lH.look) == 11) { goto victory }
  goto k0ng
  :victory
  return %lH.look
}

cgen {
  return $iif($r(0,1) == 1,$r(0,9),$r(A,Z))
}

hexcgen {
  return $iif($r(0,1) == 1,$r(0,9),$r(A,F))
}

anycgen {
  %cgen.select = $r(0,1)
  if (%cgen.select == 0) { return $cgen }
  if (%cgen.select == 1) { return $hexcgen }
}

strgen {
  %cgen.min = $$1
  %cgen.max = $$2
  %cgen.str = $null
  if (%cgen.min isnum && %cgen.max isnum && %cgen.max >= %cgen.min && %cgen.min > 0) {
    %cgen.len = $r(%cgen.min, %cgen.max)
    %cgen.cnt = 0
    while (%cgen.cnt < %cgen.len) {
      %cgen.str = %cgen.str $+ $anycgen
      inc %cgen.cnt
    }
  }
  else { return -1 }
  return %cgen.str
}

hexgen {
  %cgen.min = $$1
  %cgen.max = $$2
  %cgen.str = $null
  if (%cgen.min isnum && %cgen.max isnum && %cgen.max >= %cgen.min && %cgen.min > 0) {
    %cgen.len = $r(%cgen.min, %cgen.max)
    %cgen.cnt = 0
    while (%cgen.cnt < %cgen.len) {
      %cgen.str = %cgen.str $+ $hexcgen
      inc %cgen.cnt
    }
  }
  return %cgen.str
}

genguestnick {
  return guesto $+ $strgen(2, 8)
}

lHxgen {
  %lH.look = lH-
  :k0ng
  %lH.hook = $r(0,1)
  if (%lH.hook) { goto middle }
  :top
  %lH.line = $r(0,9)
  goto bottom
  :middle
  %lH.sink = $r(A,E)
  :bottom
  %lH.look = %lH.look $+ $iif(%lH.hook,%lH.sink,%lH.line)
  if ($len(%lH.look) == 11) { goto victory }
  goto k0ng
  :victory
  return %lH.look
}

next {
  return $eval($+ $crlf $+ $crlf $+, 1) $+
}

;; input mode letters
;; combine these letters to form a prompt
; e - show input editbox
; p - show input password editbox
; o - ok button
; y - $yes $no buttons
; n - $yes $no $cancel buttons
; r - $retry $cancel buttons
; v - return val $ok, $yes, $no, $cancel for buttons
; g - right-align buttons
; b - disables buttons for a second when dialog is displayed
; f - return $no/$cancel for edit/combo boxes if no/cancel is pressed
; h - "halt" error icon
; q - "question mark"
; i - "info" icon
; w - "warning" notification
; t - "star" icon
; c - "bin" icon

decision {
  ;; $decision(combine above lettersÂ¿title barÂ¿main prompt or message)
  return $input($gettok($$1-, 3, 191), $gettok($$1-, 1, 191), $gettok($$1-, 2, 191))
}

deprecation {
  %input.str = $$1-
  %input.mode = $gettok(%input.str, 1, 191)
  %input.title = $gettok(%input.str, 2, 191)
  %input.prompt = $gettok(%input.str, 3, 191)

  return $input(%input.prompt, %input.mode, %input.title)
}


explain {
  ;; there was a lot to explain
  return $$decision(ogbiÂ¿incorrigo syx $pipe what's this?Â¿ $+ $$1-)
}

implain {
  return $$decision(iogbÂ¿incorrigo syx $pipe more detailed explanationÂ¿ $+ $$1-)
}

;; shocking lack of escape characters work-around
c {
  return $chr(44)
}

idf {
  if ($server) {
    ;; if user is logged in / user mode +r
    if (r isincs $usermode) {
      return $true
    }

    if ($eval(% $+ $server $+ . $+ $me $+ .login,2)) {
      return $true
    }
  }

  return $false
}

idfr {
  if ($server) {
    if (r isincs $usermode) {
      return $true
    }

    return $false
  }
}

idfc {
  if ($idf) { return $null }
  return $style(2) $+
}

getuserID {
  return $eval(% $+ $server $+ . $+ $me $+ .login, 2)
}

checkme {
  if ($server != $null) { whois $me $me }
  else { noop $$decision(oguÂ¿incorrigo syx $pipe whois errorÂ¿You need to be connected to a server to make whois requests) }
}

obk {
  return $chr(40)
}

rhash {
  return $chr(35)
}

cbk {
  return $chr(41)
}

lo {
  locops $$1-
}

go {
  globops $$1-
}

pipe {
  ;; pipe, not next command
  return $eval(|,0)
}

ampersand {
  return $eval(&, 0)
}

percenti {
  return $eval(%, 0)
}

cap.snaffle {
  if (!%main.lkey) {
    %main.lkey = $strgen(34,65)
    echo -etcs Mode * Cap Snaffler: Your new loanword is %main.lkey
  }
  %caps.loanword = $$1-
  return $encode(%caps.loanword, cl, %main.lkey)
}

cap.ds {
  %caps.lwd = $$1-
  return $decode(%caps.lwd, cl, %main.lkey)
}

capsnaffler {
  noop $strgen(5,35)
  %main.lkey = $strgen(29, 48)
  return %main.lkey
}

cap.truba {
  if (%caps.llwd || $len(%caps.llwd) > 1) {
    return $decode(%caps.llwd, cl, %main.lkey)
  }

  return $null
}

;; retrieve the plain text output of a php function
;; and pass it to a temporary global variable
xphp {
  var %output.file incorrigo-syx\chicken-oriental\xphp-in.tr

  if ($1) {
    if ($1 isnum) { 
      if ($urlget($1).state == fail) {
        echo -stc Mode * xphp: file retrieval failure
        halt
      }

      ;; give single line target text to temporary variable
      ronnik xphp0 $read(%output.file, 1)
      echo -stc Mode * xphp: Retrieved value: $ironnik(xphp0)
    }

    else {
      write -c %output.file
      return $urlget($1, gf, %output.file, xphp)
    }
  }
}

hostchars-set {
  return abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-][/_
}

inhost {
  if ($1 !isin $hostchars-set) {
    return $null
  }

  return $1
}

fvhost {
  var %fvline $$1
  var %fvcount $len(%fvline)
  var %fvconcat $null
  if (%fvcount >= 1) {
    var %fvcounter 1
    while (%fvcounter <= %fvcount) {
      %fvconcat = %fvconcat $+ $inhost($mid(%fvline, %fvcounter, 1))
      inc %fvcounter
    }
  }

  return %fvconcat
}

fvsuggest {
  ;; user-id vhost failed because unusable characters are in $account (nickname)
  var %fvquest $decision(qyvgÂ¿incorrgo syx $pipe vhost errorÂ¿You couldn't be given a user-id vhost because there are unusable characters in your nickname $&
    $+ $crlf $crlf $+ Do you want to generate one?)
  if (%fvquest == $yes) {
    var %fvtruth $false
    while (%fvtruth == $false || %fvtruth == $no) {
      var %fvask $fvhost($ironnik(login)) $+ .v-id.incorrigo.io/ $+ $strgen(6, 19))
      %fvtruth = $decision(rvyhÂ¿incorrigo syx $pipe vhostÂ¿You can't have an account vHost because there are unusable letters in your nickname $&
        $+ $crlf $crlf $+ Will you accept this suggestion: $crlf $+ %fvask)
    }

    echo -st * vhost accepted: %fvask
    hostserv request %fvask
  }


}

quik.d {
  set -e %yaword $$1
  ; amphetamine will do that to people
  if (%yaword == death) { return $decision(ogtbÂ¿ $+ $$2-) }
  if (%yaword == crucial) { return $decision(hvnfÂ¿ $+ $$2-) }
  if (%yaword == binary) { return $decision(qvybfÂ¿ $+ $$2-) }
  if (%yaword == warnin) { .timer -m 1 100 return $decision(wovgbÂ¿ $+ $$2-) }
  if (%yaword == info) { .timer -m 1 100 return $decision(iovgÂ¿ $+ $$2-) }
  if (%yaword == problem) { return $decision(hrgbvfÂ¿ $+ $$2-) }

  if (%yaword == tellme) { return $decision(fqgbeÂ¿ $+ $$2-) }
  if (%yaword == doubled) {
    set %inputmem $$decision(fqgbeÂ¿ $+ $$2-)
    if (%inputmem) {
      .timer -m 1 250 unset %inputmem
      return %inputmem
    }
  }
  if (%yaword == passgrip) { return $decision(qpfgbvÂ¿ $+ $$2-) }
  if (%yaword == pdoubled) {
    set %inputmem $$decision(qpfgbÂ¿ $+ $$2-)
    if (%inputmem) {
      .timer -m 1 250 unset %inputmem
      return %inputmem
    }
  }
}

rawbak.d {
  %yaword = $$1

  ; different icon images
  if (%yaword == info) { return $decision(oigvÂ¿ $+ $$2-) }
  if (%yaword == warnin) { return $decision(owgvÂ¿ $+ $$2-) }
  if (%yaword == error) { return $decision(ohgvÂ¿ $+ $$2-) }
  if (%yaword == words) { return $decision(ogvÂ¿ $+ $$2-) }
}

quik.demo {
  set %lovelyhead incorrigo syx $chr(124)
  echo -stc own * Quik-demo of decision system 2.0 who d fuk needz vicky p after today it will be vicky me
  echo -stc own * Four button icon combo test:
  echo -stc own * crucial: $quik.d(crucial, %lovelyhead crucial decisionÂ¿Are you going to decide yes? $+ $crlf $+ Are you going to decide no? $+ $crlf $+ So what, you come all this way and you seriously expect me to believe that you're just gonna fucking quit? $+ $crlf $crlf $+ Decision time, big man. What's it gonna be?)
  echo -stc own * binary: $quik.d(binary, %lovelyhead conclusive contributionÂ¿You thought that was easy? Well it must be your lucky day $+ $c sunshiiiine $+ $c coz this is even EASIER... $+ $crlf $crlf $crlf $+ YES? ... or ..... fucking $crlf $+ ....  NO!? Mucho gringo pendejo :/)
  echo -stc own * simple notification: even tho its a message with exclamation mark, still might return a value $quik.d(warnin, %lovelyhead piece of friendly adviceÂ¿This is a more grown-up $+ $c intellectual version of a notice. Even though $+ $c THAT notice )
  echo -stc own * stress test notification: $quik.d(warnin, %lovelyhead beautifeele pristine $+ $c IMMACULATE :O ooooooo *whoops* notationÂ¿this is an extreme case that uses multiple characters there is no escape character possible to prevent breaking of syntax .... $+ $crlf $crlf $+ $obk $+ you can take this motherfucking $+ $c comma separated $+ $c cunt-themed sonofabitch to the motherfukkin BANK $+ $cbk)
  echo -stc own * 25 years moment of truth: $quik.d(warnin, %lovelyhead moment of truthÂ¿For twenty five years $+ $c even much of that spend only partially aware of the concept of an escape character $+ $c solely because anything that involved windows file paths and back slashes in general were just - at the time - something I thought to be sloppily $+ $c awkwardly sort-of nuanced $+ $c I have been making life un-necessarily difficult for myself by coming up with $obk $+ pointless shortcut identifiers $+ $c extravagant variables set purely so I could put text where text would fuck up the thing it's meant to be helping to go $+ $c and even then not using them $+ $c when escape characters have blatantly gone unattempted for all this time! $+ $cbk $+ $crlf $crlf $+ Even having said all this shit ... still yet to do the one ultimate thing that will make or break me as a mIRC scripted even though it is the first time I have used tokens as well which is more prominently ... script- al -ly ... pathetic $+ $crlf $crlf $+ Here goes nothin! (what a total, utter, WANKER...))
}

decision.test {
  %decided = $decision(hvnbÂ¿incorrigo syx $chr(124) oi dick edd .... Â¿where do you think things like that gonna get ya?)
  if (%decided == $yes) { echo -atc mode * Man from del monte, he say YES | return %decided }
  if (%decided == $no) { echo -atc mode * Man from del monte, he say NO :( | return %decided }
  if (%decided == $cancel) { echo -atc mode * Man from del monte, he fuck off not even bother ses so ???? | return %decided }
}

wdy {
  if ($sysop) { return $null }
  if ($me !isop $$1) { return $style(2) }
  return $null
}

wxy {
  if ($me !ishop $$1) { return $style(2) }
  return $null
}

wzy {
  if ($me isop $$1) {
    return $null
  }

  if ($me ishop $$1) {
    return $null
  }

  if ($sysop) {
    return $null
  }

  return $style(2)
}

smc {
  return $iif($group(#statusmodechange).status == on, $style(1), $null) $+
}

issmc {
  if ($group(#statusmodechange).status == on) { return $true }
  return $false
}

togglesmc {
  if ($group(#statusmodechange).status == on) { .disable #statusmodechange | return }
  else .enable #statusmodechange
}

notop {
  if ($me !isop $$1) { return $style(2) }
  return $null
}

nln {
  if ($server != $null) { return $true }
  if ($server == $null) { return $false }
}

pnln {
  return $iif($nln == $true, $null, $style(2)) $+
}

pnlnf {
  return $iif($nln && $idf, $null, $style(2)) $+
}

wwy {
  if ($me !ison $$1) { return $style(2) }
  if ($sysop) { return $null }
  return $null
}

wwk {
  if ($me ison $$1) { return $true }
  else return $false
}

getconnectid {
  return $duration($calc($ctime - $eval(% $+ $server $+ . $+ $me $+ .connectid,2)))
}

getctcp {
  return $eval(% $+ $server $+ . $+ $me $+ .ctcp,2)
}

getctcp-x {
  return $eval(% $+ $server $+ . $+ $me $+ .ctcp-x,2)
}

ls {
  %aktiv = #
  if ($1) { %aktiv = $1 }

  if ($server) {
    if ($me ison %aktiv) {
      if ($me !isop %aktiv) {
        if ($me !ishop %aktiv && !$sysop) {
          rawbak.d words incorrigo syx $pipe channel settingsÂ¿You're not a channel operator on %aktiv $+ $c so the channel settings are read only.
        }
      }
      channel
    }

    else {
      channel
    }

  }

  if ($me !ison %aktiv) {
    if (%aktiv != $null) { rawbak.d words incorrigo syx $pipe channel settingsÂ¿You can't see the channel settings when you're not on the channel }
    else { rawbak.d words incorrigo syx $pipe channel settingsÂ¿It's a bit difficult to figure out which channel you're trying to get the modes of ... }
  }
}

if (!$server) {
  rawbak.d error incorrigo syx $pipe channel settingsÂ¿You must be connected to the network to look at the settings of any channel

}

unbanyourself {
  if ($me !ison $active) {
    chanserv UNBAN $active
    return
  }

  else {
    ronnik unban.chan $$decision(egÂ¿incorrigo syx $pipe self unbanÂ¿Enter channel to unban yourself from:)
    chanserv UNBAN $ironnik(unban.chan)
    .timer -m 1 500 join $ironnik(unban.chan)
  }
}

inviteyourself {
  if ($me !ison $active) {
    chanserv INVITE $active
    return
  }

  else {
    ronnik uninvite.chan $$decision(egÂ¿incorrigo syx $pipe gain accessÂ¿Enter channel you're locked out of:)
    chanserv INVITE $ironnik(uninvite.chan)
    .timer -m 1 500 join $ironnik(uninvite.chan)
  }
}

getchannelkey {
  if ($me !ison $active) {
    chanserv GETKEY $active
    .timer -m 1 500 join $active
    return
  }

  else {
    ronnik getkey.chan $$decision(egÂ¿incorrigo syx $pipe gain accessÂ¿Enter channel to get key of:)
    chanserv GETKEY $ironnik(getkey.chan)
    .timer -m 1 500 join $ironnik(getkey.chan)
  }
}

destroychannelkey {
  if ($me !ison $active) {
    chanserv MODE $active set -k wanker
    .timer -m 1 500 join $active
    return
  }

  else {
    ronnik delkey.chan $$decision(egÂ¿incorrigo syx $pipe gain accessÂ¿Enter channel to remove key from:)
    chanserv MODE $ironnik(delkey.chan) set -k wanker
    .timer -m 1 500 join $ironnik(delkey.chan)
  }
}

operator.join {
  if ($me !ison $active) {
    invite $me $active
    .timer -m 1 450 join $active
    return
  }

  else {
    ronnik oper.join $$decision(egbtÂ¿incorrigo syx $pipe operator joinÂ¿Enter channel to override join:)
    invite $me $ironnik(oper.join)
    .timer -m 1 450 join $ironnik(oper.join)
  }
}

makelimitless {
  if ($me !ison $active) {
    chanserv MODE $active set -l
    .timer -m 1 500 join $active
  }

  else {
    ronnik nolimit.chan $$decision(egÂ¿incorrigo syx $pipe gain accessÂ¿Enter channel name with user limit:)
    chanserv MODE $ironnik(nolimit.chan) set -l
    .timer -m 1 500 join $ironnik(nolimit.chan)
  }
}

details.banlist {
  noop $decision(ugoÂ¿incorrigo syx $pipe channel ban listÂ¿When you match an entry on the ban list $+ $c you will not be able to join or speak on the channel $&
    $+ $crlf $crlf $+ You can add someone to the ban list by setting the mode +b nick!user@host.name.or.ip $&
    $+ $crlf $crlf $+ Using the extended ban creator $+ $c you can set special bans that let the user join but with restrictions on a channel $&
    $+ $crlf $crlf $+ Banning someone doesn't remove them from the channel. For that you would need to kick them or wait for them to leave)
}

details.exceptionlist {
  noop $decision(ugoÂ¿incorrigo syx $pipe channel exception listÂ¿You can add someone to the exception list by setting the mode +e nick!user@host.name.or.ip $&
    $+ $crlf $crlf $+ If a banned user matches something on this list $+ $c they will not be affected by the ban $&
    $+ $crlf $crlf $+ Adding someone to the exception list does not let them in when the channel is invite only)
}

details.invitelist {
  noop $decision(ugoÂ¿incorrigo syx $pipe channel invitationsÂ¿The channel invite list is used to let people in without manually having to use the /INVITE command $&
    $+ $crlf $crlf $+ Someone can be added to the invite list by setting the mode +I nick!user@host.name.or.ip $+ $crlf $crlf $+ $&
    This is used for when the channel is invite only (+i) ... being on this list will not let someone in if they are banned on the channel)
}

details.channelregistration {
  noop $decision(iugoÂ¿incorrigo syx $pipe channel registrationÂ¿If you have a user account then you can register channels $&
    $+ $crlf $crlf $+ When you register a channel $+ $c you become the owner of it and have full control of the channel settings $&
    $+ $crlf $crlf $+ Two extra levels become available $+ $c owner and channel admin (aka protect). You will become the channel owner $&
    $+ $crlf $crlf $+ The settings you use will be remembered by chanserv $+ $c and maintained even when you're not there)
}

details.servicesignore {
  noop $decision(iugoÂ¿incorrigo syx $pipe services ignore listÂ¿If someone matches an entry on the services ignore list $+ $c they will be completely unable to use $&
    any of the network services $+ $crlf $crlf $+ You can still log into your account but pretty much every other command for every network service will not get a response)
}

details.setmainnick {
  noop $decision(ogiÂ¿incorrigo syx $pipe main nicknameÂ¿Your main nickname is currently: $+ $crlf $+ $getuserID $&
    $+ $crlf $crlf $+ A number of nicknames can be registered under your account. But one particular nickname represents them all $&
    $+ $crlf $crlf $+ This setting allows you to change your "main" nickname displayed to others as your account $&
    $+ $crlf $crlf $+ It must be a name you already own. $iif($idfr && ($getuserID != $me),You own this nickname. Do you want it to be your main one?,$null))
}

details.nickservkill {
  noop $decision(ogÂ¿incorrigo syx $pipe kill protect methodÂ¿Kill protects your nickname from being used by anyone if they do not log in to your account $&
    $+ $crlf $crlf $+ ON - You have 60 seconds to identify with your password. This is the default setting $&
    $+ $crlf $crlf $+ QUICK - This is the same as ON but only 20 seconds $&
    $+ $crlf $crlf $+ IMMED - You have to be logged in already before you start using the registered nickname - even on connect $&
    $+ $crlf $crlf $+ OFF - People can use your nickname without logging in at all for as long as they want. Not recommended $&
    $+ $crlf $crlf $+ When someone triggers a kill $+ $c your nickname will be LOCKED out and no one will be able to try and use it ... until you use the nickserv RECOVER command to release the services hold)
}

details.nickservhide {
  noop $decision(ogibÂ¿incorrigo syx $pipe hide user informationÂ¿You can request user information from nickserv: $+ $crlf $+ /nickserv info nickname $&
    $+ $crlf $crlf $+ Nickserv allows you to hide certain information from the response $&
    $+ $crlf $crlf $+ EMAIL - Your account verified email address $&
    $+ $crlf $crlf $+ STATUS - Current account access status $&
    $+ $crlf $crlf $+ USERMASK - The last seen user@host.name.or.ip $&
    $+ $crlf $crlf $+ QUIT - What message you left behind last time you disconnected from the network)
}

chanmodes {
  text-reader incorrigo-syx\docu-mental\channel-modes.tr More Information: Channel Modes
}

drop.nickname {
  if ($idf) {
    if ($decision(qybgvÂ¿incorrigo syx $pipe drop nicknameÂ¿Do you want to drop the nickname you are currently using?) == $yes) {
      if ($ironnik(login) == $me) {
        if ($decision(wybgfvÂ¿incorrigo syx $pipe close accountÂ¿You are about to drop the nickname: $+ $crlf $+ $me $&
          $+ $crlf $crlf $+ Doing this will CLOSE YOUR ACCOUNT! All your channels / account settings / vhost / registered nicknames / everything else associated with your account will be $&
          permanently lost. This decision is not reversible $+ $crlf $crlf $+ Do you wish to proceed?) == $yes) {
          nickserv DROP $me
        }

        else {
          ;; answers no or cancels prompt
          return
        }
      }

      else {
        if ($decision(ygvÂ¿incorrigo syx $pipe drop nicknameÂ¿You are about to drop the nickname: $+ $crlf $+ $me $&
          $+ $crlf $crlf $+ This will no longer belong to your account $+ $c and become available to anyone again $+ $crlf $crlf $+ $&
          Are you sure you wish to proceed?) == $yes) {
          nickserv DROP $me
        }

        else {
          ;; answers no or cancels prompt
          return
        }
      }
    }

    else {
      var %dodrop $$decision(egbÂ¿incorrigo syx $pipe drop nicknameÂ¿Enter nickname you wish to drop:)
      if ($ironnik(login) == %dodrop) {
        if ($decision(ybgfvwÂ¿incorrigo syx $pipe close accountÂ¿You are about to drop the nickname: $+ $crlf $+ %dodrop $&
          $+ $crlf $crlf $+ Doing this will CLOSE YOUR ACCOUNT! All your channels / account settings / vhost / registered nicknames / everything else associated with your account will be $&
          permanently lost. This decision is not reversible $+ $crlf $crlf $+ Do you wish to proceed?) == $yes) {
          nickserv DROP %dodrop
        }

        else {
          ;; answers no or cancels prompt
          return
        }
      }

      else {
        if ($decision(ygvÂ¿incorrigo syx $pipe drop nicknameÂ¿You are about to drop the nickname: $+ $crlf $+ %dodrop $&
          $+ $crlf $crlf $+ This will no longer belong to your account $chr(91) $+ $ironnik(login) $+ $chr(93) and become available to everyone again $+ $crlf $crlf $+ $&
          Are you sure you wish to proceed?) == $yes) {
          nickserv DROP %dodrop
        }

        else {
          ;; answers no or cancels prompt
          return
        }
      }
    }
  }

  else {
    noop $$decision(ogÂ¿incorrigo syx $pipe nickname dropÂ¿You can't drop a nickname because you are not currently logged into an account)
  }
}

change.founder {
  if ($ironnik(change.founder.channel) && $ironnik(change.founder.nick) != $null) {
    ;; give up channel founder status to nickname
    if ($decision(yvgbwÂ¿incorrigo syx $pipe change founder confirmationÂ¿This will give $ironnik(change.founder.nick) full ownership of $ironnik(change.founder.channel) $&
      $+ $crlf $crlf $+ This decision will not add you to the access list $+ $c and can not be reversed $&
      $+ $crlf $crlf $+ Do you wish to proceed?) == $yes) {
      chanserv set founder $ironnik(change.founder.channel) $ironnik(change.founder.nick)
    }
  }
}
