;;; INCORRIGO SYX DIGITAL COMMUNICATION SYSTEMS
;;; making a new feature before it exists yet

;; +draft/reply using mIRC

on *:START: {
  titlebar :: Incorrigo Syx
  set -e %main.id-cache incorrigo-syx\chicken-oriental\session-cache.syx
  if (!$exists(%main.id-cache)) {
    ;; this command is just for the sake of it to create the file
    cachewr fileinit file initialised
  }
}

on *:CONNECT: {
  ;; echo-message is required
  cap req echo-message
}

on *:EXIT: {
  ;; no need to keep a local copy, in any context
  remove incorrigo-syx\chicken-oriental\session-cache.syx
}

alias cachewr {
  ;; this adds a message to a chat / channel in the cache file
  writeini incorrigo-syx\chicken-oriental\session-cache.syx $$1-
}

alias -l lopoff {
  ;; remove oldest message in section $1
  remini incorrigo-syx\chicken-oriental\session-cache.syx $1 $ini(incorrigo-syx\chicken-oriental\session-cache.syx, $1, 1)
}

alias -l replyline {
  ;; this is the reply line in other user message event
  echo -tc Info $1 Reply: $chr(91) $+ $2 $+ $chr(93)  $+ $replacex($3-,ACTION,-->,,$null) $+ 
}

alias printreplyline {
  ;; reply line when the response to something is yours
  echo -tc Info $1 Reply: $chr(91) $+ $2 $+ $chr(93)  $+ $replacex($3-,ACTION,-->,,$null) $+ 
}

on *:PARSELINE:*:*msgid=*PRIVMSG*: {
  ;; uses echo-message cap to obtain the msgid of your own messages
  if ($parsetype == in) {
    ronnik echo-tags $parseline
    self-msgid $ironnik(echo-tags)
  }
}

alias r {
  ;; this command (re-)opens / populates @reply, from which you select a message
  .window -c @reply
  var %reply.channel $$1
  ;; create reply window in listbox window format
  window -al +f @reply 100 100 1075 300 incorrigo-syx\chicken-oriental\replymenu.syx
  ;; the following code populates the reply window using cache file, showing most recent first
  var %reply.lines = $ini(%main.id-cache, $1, 0)
  var %countdown = %reply.lines
  while (%countdown >= 1) {
    aline @reply $ini(%main.id-cache, %reply.channel, %countdown) %reply.channel $readini(%main.id-cache, %reply.channel, $ini(%main.id-cache, %reply.channel, %countdown))
    dec %countdown
  }
}

alias send-reply-line {
  echo -tc Mode $2 * < $+ $3 $+ > $4-
}

alias -l self-msgid {
  ;; this command is fed the entire @tags command target :message
  ronnik echo-message $right($2, -1)
  ronnik echo-nick $gettok($ironnik(echo-message), 1, 33)
  if ($ironnik(echo-nick) == $me) {
    ;; do nothing if this message was not your own
    ronnik tagss $1
    ronnik msgid $right($wildtok($ironnik(tagss), msgid=*, 1, 59), -6)
    ;; variable uses (i)ronnik - dynamie %server.nick.variablename
    cachewr $4 $ironnik(msgid) $me $right($5-, -1)
    if ($ini(%main.id-cache, $4, 0) >= 101) {
      lopoff $4
    }
  }
}

on ^*:TEXT:*:#: {
  ;; on join playback will put the messages in order first
  if ($msgtags(msgid)) {
    ;; cache format: [#channel] msgid=nick message
    cachewr # $msgtags(msgid).key $nick $1-
    if ($ini(%main.id-cache, #, 0) >= 101) {
      ;; when cache [per channel] reaches this amount, 1 new message replace the oldest
      lopoff #
    }
  }

  if ($msgtags(+draft/reply)) {
    ;; this implementation supports reply tag regardless of which client is using it
    if ($readini(%main.id-cache, #, $msgtags(+draft/reply).key)) {
      ;; message not in cache will just have no reply line. note: if the message ref
      ;; is cached later in the channel session, it seamlessly appears with the reply
      ;; line during channel playback. message reply counts as only 1 line in playback batch
      var %readline $readini(%main.id-cache, #, $msgtags(+draft/reply).key)
      replyline # %readline
    }
  }
}

on ^*:TEXT:*:?: {
  ;; when the session cache file is in place this just worked on its own
  if ($msgtags(msgid)) {
    ;; using ^* for the event puts a query window in place to associate reply line echos
    query $nick
    ;; this just gives a user their own section to segregate replies in private / on channel
    cachewr $nick $msgtags(msgid).key $nick $1-
    if ($ini(%main.id-cache, $nick, 0) >= 101) {
      ;; works straight out of the box
      lopoff $nick
    }
  }

  if ($msgtags(+draft/reply)) {
    ;; this also works to the draft/reply specification
    if ($readini(%main.id-cache, $nick, $msgtags(+draft/reply).key)) {
      ;; same format in cache file for reply lines
      var %readline $readini(%main.id-cache, $nick, $msgtags(+draft/reply).key)
      replyline $nick %readline
    }
  }
}

on ^*:ACTION:*:#: {
  ;; Action is preserved in the cache and stays that way during playback
  if ($msgtags(msgid)) {
    ;; action cache format: [#channel] msgid=nick ACTION message
    cachewr # $msgtags(msgid).key $nick ACTION $1- $+ 
    if ($ini(%main.id-cache, #, 0) >= 101) {
      lopoff #
    }
  }

  if ($msgtags(+draft/reply)) {
    if ($readini(%main.id-cache, #, $msgtags(+draft/reply).key)) {
      ;; actions are naturally supported by onjoy/history playback
      var %readline $readini(%main.id-cache, #, $msgtags(+draft/reply).key)
      replyline # %readline
    }
  }
}

on ^*:ACTION:*:?: {
  query $nick
  ;; on join playback will put the messages in order first
  if ($msgtags(msgid)) {
    ;; opens query window to print reply lines in correct places
    cachewr $nick $msgtags(msgid).key $nick ACTION $1- $+ 
    if ($ini(%main.id-cache, $nick, 0) >= 101) {
      ;; when cache [per channel] reaches this amount, 1 new message replace the oldest
      lopoff $nick
    }
  }

  if ($msgtags(+draft/reply)) {
    ;; this is a private message referring to a different message
    if ($readini(%main.id-cache, $nick, $msgtags(+draft/reply).key)) {
      ;; same cache file but section will be their nick instead of channel
      var %readline $readini(%main.id-cache, $nick, $msgtags(+draft/reply).key)
      replyline $nick %readline
    }
  }
}
